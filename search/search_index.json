{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"docker","text":"<ul> <li>01.-Introducci\u00f3n</li> <li>02.-Instalaci\u00f3n</li> <li>03.-Conceptos Clave</li> <li>04.Manos a la obra</li> <li>05.-Gesti\u00f3n de im\u00e1genes</li> <li>Comandos b\u00e1sicos de Docker CLI para la gesti\u00f3n de im\u00e1genes y contenedores [2]</li> <li>Creaci\u00f3n de im\u00e1genes personalizadas y registro en Docker Hub [1]</li> <li>Implementaci\u00f3n de una aplicaci\u00f3n en contenedor de Docker [1]</li> <li>Integraci\u00f3n de Docker con herramientas de orquestaci\u00f3n como Kubernetes o Docker Compose [3]</li> <li>Buenas pr\u00e1cticas y consideraciones de seguridad para el uso de Docker [3] 01.-Introducci\u00f3n Docker en python y django</li> </ul>"},{"location":"01.-Introducci%C3%B3n/","title":"01.-Introducci\u00f3n","text":"<p>La configuraci\u00f3n adecuada de un entorno de desarrollo local sigue siendo un gran reto a pesar de todos los otros avances de la programaci\u00f3n moderna. Simplemente hay demasiadas variables: diferentes ordenadores, sistemas operativos, versiones de lenguajes y frameworks, opciones de entornos virtuales,  y as\u00ed sucesivamente. Cuando se a\u00f1ade el reto de trabajar en equipo en un entorno en el que todos necesitan tener la misma configuraci\u00f3n, el problema se magnifica.</p> <p>En los \u00faltimos a\u00f1os ha surgido una soluci\u00f3n: Docker. Aunque s\u00f3lo tiene unos pocos a\u00f1os, Docker se ha convertido r\u00e1pidamente en la opci\u00f3n por defecto para muchos desarrolladores que trabajan en proyectos a nivel de producci\u00f3n.</p> <p>Docker es un proyecto open source que ha revolucionado la manera de desarrollar software gracias a la sencillez con la que permite gestionar contenedores. Los contenedores LXC (LinuX Containers) son un concepto relativamente antiguo y utilizado desde hace tiempo por grandes empresas como Amazon o Google, pero cuyo gesti\u00f3n era complicada. Sin embargo, Docker define APIs y herramientas de l\u00ednea de comandos que hacen casi trivial la creaci\u00f3n, distribuci\u00f3n y ejecuci\u00f3n de contenedores. De ah\u00ed que el lema de Docker sea: \u201cBuild, Ship and Run. Any application, Anywhere\u201d y se haya convertido en una herramienta fundamental tanto para desarrolladores como para administradores de sistemas.</p> <p>Con Docker finalmente es posible reproducir un entorno de producci\u00f3n de forma fiel y fiable localmente, desde la versi\u00f3n adecuada del lenguaje hasta la instalaci\u00f3n de las librer\u00edas necesarias, a la par de ejecutar servicios adicionales como una base de datos a nivel de producci\u00f3n. Esto significa que ya no es importante si se desarrolla en un equipo Linux, Mac o Windows. Todo funciona dentro del mismo Docker.</p> <p>Docker tambi\u00e9n facilita exponencialmente la colaboraci\u00f3n en equipo. Atr\u00e1s quedaron los d\u00edas de compartir archivos README largos y obsoletos para a\u00f1adir un nuevo desarrollador a un proyecto de grupo.</p> <p>En lugar de eso, con Docker s\u00f3lo se tienen que compartir dos archivos: <code>Dockerfile</code> y  <code>docker-compose.yml</code> y el desarrollador puede tener la confianza de que su entorno de desarrollo local es exactamente igual que el del resto del equipo.</p> <p>Docker no es una tecnolog\u00eda perfecta. Todav\u00eda es relativamente nueva y compleja en sus entra\u00f1as; a\u00fan est\u00e1 en desarrollo activo. Pero aspira a la promesa de una pol\u00edtica coherente y a un entorno de desarrollo compartible, que pueda ejecutarse localmente en cualquier ordenador o desplegado en cualquier servidor, lo que lo convierte en una opci\u00f3n s\u00f3lida.</p>"},{"location":"01.-Introducci%C3%B3n/#que-es-docker","title":"\u00bfQu\u00e9 es Docker?","text":"<p>Docker es una forma de aislar todo un sistema operativo a trav\u00e9s de contenedores Linux que son un tipo de virtualizaci\u00f3n.</p> <p>La virtualizaci\u00f3n tiene sus ra\u00edces en los inicios de la inform\u00e1tica cuando las computadoras grandes y caras eran la norma. \u00bfC\u00f3mo podr\u00edan varios programadores utilizar la misma m\u00e1quina?. La respuesta fue la virtualizaci\u00f3n y espec\u00edficamente las m\u00e1quinas virtuales que son copias completas de un sistema inform\u00e1tico desde el sistema operativo en adelante. </p> <p>Cuando se alquila un espacio en un proveedor de cloud computing como Amazon Web Services (AWS) normalmente no se proporciona una pieza de hardware dedicada. En lugar de eso, se comparte un servidor f\u00edsico con otros clientes. Pero como cada cliente tiene su propio sistema virtual que se ejecuta en el servidor, le parece que tiene el suyo propio.</p> <p>Esta tecnolog\u00eda es la que hace posible a\u00f1adir o eliminar servidores de un servicio de cloud de forma r\u00e1pida y sencilla. Se trata en gran medida de software entre bastidores, no de hardware real.</p> <p>\u00bfCu\u00e1l es el inconveniente de una m\u00e1quina virtual? Tama\u00f1o y velocidad. Un sistema operativo hu\u00e9sped t\u00edpico (guest) puede ocupar f\u00e1cilmente hasta 700MB de tama\u00f1o. As\u00ed que si un servidor f\u00edsico soporta tres m\u00e1quinas virtuales, eso es al menos 2,1 GB de espacio en disco ocupado junto con el resto de necesidades para otros recursos como CPU y memoria.</p> <p>Al entrar en Docker, la idea clave es que la mayor\u00eda de los ordenadores dependen del mismo sistema operativo Linux. \u00bfY si virtualizamos desde la capa de Linux hacia arriba? \u00bfNo proporcionar\u00eda eso una forma m\u00e1s r\u00e1pida y ligera de duplicar gran parte de la misma funcionalidad? La respuesta es s\u00ed. Y en los \u00faltimos a\u00f1os los contenedores Linux se han vuelto muy populares. Para la mayor\u00eda de las aplicaciones, especialmente las aplicaciones web, una m\u00e1quina virtual proporciona mucho m\u00e1s recursos de los que se necesitan y un contenedor es m\u00e1s que suficiente.</p> <p>Esto, fundamentalmente, es Docker: \u00a1una forma de implementar contenedores Linux!</p> <p>Una analog\u00eda que podemos usar es la de los edificios y los apartamentos. Las m\u00e1quinas virtuales son como viviendas: edificios independientes con su propia infraestructura, incluida la fontaner\u00eda y calefacci\u00f3n, as\u00ed como cocina, ba\u00f1os, dormitorios, etc. Los contenedores Docker son como los apartamentos: comparten una infraestructura com\u00fan como la fontaner\u00eda y la calefacci\u00f3n, pero vienen en varios tama\u00f1os que se ajustan a las necesidades exactas de un propietario.</p>"},{"location":"01.-Introducci%C3%B3n/#contenedores-vs-entornos-virtuales","title":"Contenedores vs. Entornos Virtuales","text":"<p>Como programador de Python, por ejemplo, se debe estar familiarizado con el concepto de entornos virtuales que son una forma de aislar los paquetes Python. Gracias al entorno virtual, una computadora puede ejecutar m\u00faltiples proyectos localmente. Por ejemplo, el Proyecto A podr\u00eda usar Python 3.10 y Django 4.1 entre otras dependencias; mientras que el Proyecto B usa Python 3.8 y Django 2.2. Configurando un entorno virtual dedicado en cada proyecto se puede gestionar estos diferentes paquetes de software sin contaminar nuestro entorno global.</p> <p>Hay una peque\u00f1a confusi\u00f3n derivada de que hay m\u00faltiples herramientas en este momento para implementar un entorno virtual: desde <code>virtualenv</code>, <code>venv</code> a <code>pipenv</code> o <code>poetry</code>, pero fundamentalmente todas hacen lo mismo.</p> <p>La mayor distinci\u00f3n entre los entornos virtuales y Docker es que los entornos virtuales s\u00f3lo pueden aislar paquetes Python. No pueden aislar a los no-Python como una base de datos PostgreSQL o MySQL. Y siguen dependiendo del sistema global; de la instalaci\u00f3n de Python a nivel de sistema (en otras palabras, de su ordenador). Los entornos virtuales apuntan a una instalaci\u00f3n Python existente; no contienen Python en s\u00ed mismos.</p> <p>Los contenedores Linux van un paso m\u00e1s all\u00e1 y a\u00edslan todo el sistema operativo, no s\u00f3lo las partes de Python. En otras palabras, instalaremos el propio Python dentro de Docker, as\u00ed como se instalar\u00e1 y ejecutar\u00e1 en \u00e9l la base de datos a nivel de producci\u00f3n.</p>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/","title":"05.-Gesti\u00f3n de im\u00e1genes","text":"<p>Para crear una imagen de Docker, se sigue el siguiente proceso b\u00e1sico:</p> <ol> <li>Crear un archivo <code>dockerfile</code>: El archivo <code>dockerfile</code> es un archivo de texto que contiene las instrucciones para construir una imagen de Docker. En el archivo <code>dockerfile</code>, se especifican el sistema operativo base, las dependencias, las bibliotecas y las configuraciones necesarias para la aplicaci\u00f3n.</li> <li>Escribir las instrucciones de <code>dockerfile</code>: En el archivo <code>dockerfile</code>, se incluyen las instrucciones para construir la imagen. Por ejemplo, se pueden utilizar las instrucciones <code>FROM</code> para especificar el sistema operativo base, <code>RUN</code> para instalar dependencias y bibliotecas, y <code>COPY</code> para copiar archivos de la aplicaci\u00f3n.</li> <li>Construir la imagen: Una vez que se ha creado el archivo <code>dockerfile</code>, se puede construir la imagen utilizando el comando <code>docker build</code>. Este comando lee las instrucciones en el archivo <code>dockerfile</code> y construye la imagen de Docker.</li> <li>Etiquetar la imagen: Despu\u00e9s de construir la imagen, se puede etiquetar con un nombre y una versi\u00f3n utilizando el comando <code>docker tag</code>.</li> <li>Subir la imagen a un registro de im\u00e1genes: Por \u00faltimo, se puede subir la imagen a un registro de im\u00e1genes de Docker, como Docker Hub, para que otras personas puedan descargarla y utilizarla para crear contenedores.</li> </ol> <p>Aqu\u00ed un ejemplo de archivo <code>dockerfile</code> para construir una imagen de una aplicaci\u00f3n de Python:</p> <pre><code># Imagen base\nFROM python:3.9-alpine\n\n# Variables de entorno para configurar el entorno de la aplicaci\u00f3n\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n# Directorio de trabajo\nWORKDIR /app\n\n# Copiar los archivos de la aplicaci\u00f3n\nCOPY requirements.txt .\nCOPY . .\n\n# Instalar las dependencias\nRUN pip install --upgrade pip &amp;&amp; \\\n    pip install -r requirements.txt\n\n# Exponer el puerto 8000\nEXPOSE 8000\n\n# Comando para iniciar la aplicaci\u00f3n\nCMD [\"python\", \"app.py\"]\n</code></pre> <p>Este archivo <code>dockerfile</code> se basa en la imagen de Python 3.9 Alpine y configura el entorno de la aplicaci\u00f3n. A continuaci\u00f3n, copia los archivos de la aplicaci\u00f3n y los requisitos en el directorio de trabajo y los instala. Finalmente, expone el puerto 8000 y utiliza el comando <code>python app.py</code> para iniciar la aplicaci\u00f3n.</p> <p>Para construir la imagen, se debe ejecutar el siguiente comando en la terminal, asegur\u00e1ndote de estar en la misma ubicaci\u00f3n que el archivo <code>dockerfile</code>:</p> <pre><code>docker build -t nombre-de-la-imagen:version .\n</code></pre> <p>Despu\u00e9s de construir y etiquetar la imagen, se puede subir a un registro de im\u00e1genes de Docker utilizando el comando <code>docker push</code>. Por ejemplo:</p> <pre><code>docker push nombre-de-la-imagen:version\n</code></pre> <p>Una vez subida la imagen, se puede descargar y ejecutar en cualquier sistema que admita Docker utilizando el comando <code>docker run</code>.</p>"},{"location":"02.-Instalaci%C3%B3n/","title":"02.-Instalaci\u00f3n","text":"<p>La documentaci\u00f3n oficial incluye instrucciones de instalaci\u00f3n de Docker Community para\u00a0MacOS,\u00a0Windows,\u00a0Linux\u00a0o servicios en la\u00a0nube.</p> <ul> <li>Instalaci\u00f3n en Ubuntu</li> <li>Instalaci\u00f3n en Arch</li> <li>Instalaci\u00f3n del plugin de ZSH</li> </ul> <p>Sin embargo existen modos m\u00e1s pr\u00e1cticos apoy\u00e1ndonos en el trabajo desarrollado por la comunidad en cada una de las distribuciones.</p> <ul> <li>01.-Instalaci\u00f3n r\u00e1pida en Arch Linux</li> <li>02.-Instalaci\u00f3n r\u00e1pida en Fedora by H\u00e9ctor Del Real L\u00f3pez</li> <li>03.-Instalaci\u00f3n r\u00e1pida en Ubuntu by Yana Zhu</li> <li>04.-Instalaci\u00f3n r\u00e1pida en Ubuntu by Jorge Naranjo Jim\u00e9nez</li> <li>05.-Instalaci\u00f3n r\u00e1pida en Ubuntu por Alberto Romero Rubiales</li> <li> <p>06.-Instalaci\u00f3n r\u00e1pida en Ubuntu por Estefany LIzeth Silva Robles</p> </li> <li> <p>Enlaces:</p> </li> </ul> <p>Conocimiento Libre en la Universidad de Costa Rica (UCR): Docker, aplicaciones en cualquier parte</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/","title":"01.-Instalaci\u00f3n r\u00e1pida en Arch Linux","text":""},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#actualizamos-repositorios","title":"Actualizamos repositorios","text":"<pre><code>sudo pacman -Syy\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalamos-docker-y-docker-compose","title":"Instalamos <code>docker</code> y <code>docker-compose</code>","text":"<pre><code>sudo pacman -S docker docker-compose\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#iniciamos-docker-y-lo-habilitamos-para-que-se-inicie-al-reiniciar","title":"Iniciamos Docker y lo habilitamos para que se inicie al reiniciar","text":"<pre><code>sudo systemctl enable docker\nsudo systemctl start docker\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#comprobamos-la-version-de-docker-y-si-esta-instalado","title":"Comprobamos la versi\u00f3n de docker y si est\u00e1 instalado","text":"<p><code>docker -v</code></p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#anadimos-a-nuestro-usuario-para-controlar-docker","title":"A\u00f1adimos a nuestro usuario para controlar Docker","text":"<p>Creamos el grupo <code>docker</code>:</p> <pre><code>sudo groupadd docker\n</code></pre> <p>A\u00f1adimos al usuario:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>Para que los cambios surtan efecto habr\u00e1 que reiniciar la sesi\u00f3n completamente, no basta con cerrar el terminal.</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#comprobar-la-instalacion","title":"Comprobar la instalaci\u00f3n","text":"<p>Para comprobar si Docker est\u00e1 instalado correctamente en tu sistema, puedes ejecutar el siguiente comando:</p> <pre><code>docker run hello-world\n</code></pre> <p>Este comando descargar\u00e1 la imagen <code>hello-world</code> de Docker Hub y la ejecutar\u00e1 en un contenedor. Si todo funciona correctamente, deber\u00edas ver un mensaje que indica que Docker est\u00e1 instalado y funcionando correctamente.</p> <pre><code>Unable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n2db29710123e: Pull complete \nDigest: sha256:4e83453afed1b4fa1a3500525091dbfca6ce1e66903fd4c01ff015dbcb1ba33e\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#docker-compose-en-arch-con-python","title":"Docker-Compose en Arch con Python","text":"<p>En principio ya se ha realizado la instalaci\u00f3n de <code>docker-compose</code>. Otra forma de hacer lo propio es mediante la herramienta de instalaci\u00f3n de paquetes de python <code>pip</code>.</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalando","title":"Instalando","text":"<p>Si no tienes instalado <code>pip</code>, deber\u00e1s instalarlo</p> <pre><code>sudo pacman -S  python-pip\n</code></pre> <p>Ahora vamos a instalar docker-compose</p> <pre><code>sudo pip3 install docker-compose\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#version","title":"Versi\u00f3n","text":"<p>Vamos a verificar la versi\u00f3n de docker-compose</p> <pre><code>docker-compose -v\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#levantar-un-docker-con-docker-compose","title":"Levantar un docker con docker-compose","text":"<p>Ahora cuando tenga un archivo\u00a0docker-compose.yml, lo levantar\u00e9 con:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalando-portainer","title":"Instalando Portainer","text":"<p>Portainer gestiona los contenedores de un modo gr\u00e1fico:</p> <pre><code>portainer:\n  image: portainer/portainer-ce:latest\n  container_name: portainer\n  restart: unless-stopped\n  security_opt:\n    - no-new-privileges:true\n  volumes:\n    - /etc/localtime:/etc/localtime:ro\n    - /var/run/docker.sock:/var/run/docker.sock:ro\n    - ./portainer-data:/data\n  ports:\n    - 9000:9000\n</code></pre> <p>Publicado por Angel el 07/12/2022</p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/","title":"Instalaci\u00f3n de Docker Desktop en Fedora 37","text":"<p>La versi\u00f3n de Docker Desktop nos permite lanzar contenedores tanto en modo gr\u00e1fico como desde la terminal.</p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/#requisitos-previos","title":"Requisitos previos","text":"<p>Para instalar Docker necesitamos la terminal de Gnome, como uso KDE, voy a instalar la terminal con el siguiente comando</p> <p><code>sudo dnf install gnome-terminal-3.46.8-1.fc37.x86_64</code></p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/#instalacion","title":"Instalaci\u00f3n","text":"<p>Una vez instalada vamos a a\u00f1adir los repositorios de Docker</p> <pre><code>sudo dnf -y install dnf-plugins-core\n\nsudo dnf config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/fedora/docker-ce.repo\n</code></pre> <p>Despu\u00e9s descargamos el archivo rpm de docker y abrimos la carpeta de descarga en la terminal. He descargado la versi\u00f3n 4.18.0 as\u00ed que la instalo con el siguiente comando</p> <pre><code>sudo dnf install ./docker-desktop-4.18.0-x86_64.rpm\n</code></pre> <p>El instalador nos pedir\u00e1 que importemos la clave gpg de Docker, le damos a Y para aceptar.</p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/#comprobaciones","title":"Comprobaciones","text":"<p>Una vez instalado lo iniciaremos con el siguiente comando</p> <pre><code>systemctl --user enable docker-desktop\n</code></pre> <p>Si queremos que Docker se inicialice cada vez que se reinicie el ordenador ejecutamos lo siguiente</p> <pre><code>systemctl --user enable docker-desktop\n</code></pre> <p>Podemos comprobar si se ha instalado correctamente viendo la version de Docker y tambi\u00e9n ejecutando un contenedor de prueba.</p> <pre><code>docker -v\ndocker run hello-world\n</code></pre> <p>Docker descargar\u00e1 el contenedor y lo ejecutar\u00e1. Si lo ejecuta correctamente mostrar\u00e1 este mensaje</p> <pre><code>Hello from Docker!  \nThis message shows that your installation appears to be working correctly.  \n\nTo generate this message, Docker took the following steps:  \n1. The Docker client contacted the Docker daemon.  \n2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.  \n\u00a0\u00a0\u00a0(amd64)  \n3. The Docker daemon created a new container from that image which runs the  \n\u00a0\u00a0\u00a0executable that produces the output you are currently reading.  \n4. The Docker daemon streamed that output to the Docker client, which sent it  \n\u00a0\u00a0\u00a0to your terminal.  \n\nTo try something more ambitious, you can run an Ubuntu container with:  \n$ docker run -it ubuntu bash  \n\nShare images, automate workflows, and more with a free Docker ID:  \nhttps://hub.docker.com/  \n\nFor more examples and ideas, visit:  \nhttps://docs.docker.com/get-started/\n</code></pre> <p>Hecho esto, ya est\u00e1 instalado docker desktop y podremos iniciar contenedores en modo gr\u00e1fico.</p> <p>por H\u00e9ctor Del Real L\u00f3pez</p>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"03.-Instalaci\u00f3n r\u00e1pida en Ubuntu","text":"<p>Para instalar Docker Desktop, se sigue los siguientes pasos:</p> <p>1). Configurar el repositorio del paquete de Docker.</p> <p>\u200b       1.- Configuraci\u00f3n del paquete.</p> <ul> <li>Para configurar el repositorio con <code>apt</code> , se necesita instalar lo siguiente paquetes:</li> </ul> <p><code>bash   $ sudo apt-get update   $ sudo apt-get install ca-certificates                 install curl                 install gnupg</code></p> <ul> <li>A\u00f1adir la clave GPG oficial de Docker:</li> </ul> <p><code>bash   $ sudo install -m 0755 -d /etc/apt/keyrings   $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg   $ sudo chmod a+r /etc/apt/keyrings/docker.gpg</code></p> <ul> <li>Configurar el repositorio con el siguiente comando:</li> </ul> <p><code>bash   $ echo \\     \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\     \"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\     sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></p> <p>\u200b       2.- Instalaci\u00f3n del Docker Engine.</p> <ul> <li>Actualizar el paquete <code>apt</code> :</li> </ul> <p><code>bash   $ sudo apt-get update</code></p> <ul> <li>Instalar Docker Engine y Docker Compose:</li> </ul> <p><code>bash   $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></p> <ul> <li>Verificar que la instalaci\u00f3n es completada, con una imagen de hello-world:</li> </ul> <p><code>bash   $ sudo docker run hello-world</code></p> <p>2). Descargar el paquete de DEB correspondiente.</p> <p>Lo puede descargar autom\u00e1ticamente en el siguiente enlace:</p> <p>https://desktop.docker.com/linux/main/amd64/docker-desktop-4.18.0-amd64.deb?utm_source=docker&amp;utm_medium=webreferral&amp;utm_campaign=docs-driven-download-linux-amd64</p> <p>3). Instalar el paquete con <code>apt</code> como indica a continuaci\u00f3n (con la versi\u00f3n 4.18.0):</p> <pre><code>$ sudo apt-get update\n$ sudo apt-get install ./docker-desktop-4.18.0-amd64.deb\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#version-que-utiliza-mi-ubuntu","title":"Versi\u00f3n que utiliza (mi) Ubuntu:","text":"<pre><code>$ docker compose version\nDocker Compose version v2.17.2\n\n$ docker --version \nDocker version 23.0.4, build f480fb1\n\n$ docker version \nClient: Docker Engine - Community\n Cloud integration: v1.0.31\n Version:           23.0.4\n API version:       1.41 (downgraded from 1.42)\n Go version:        go1.19.8\n Git commit:        f480fb1\n Built:             Fri Apr 14 10:32:03 2023\n OS/Arch:           linux/amd64\n Context:           desktop-linux\n\nServer: Docker Desktop 4.18.0 (104112)\n Engine:\n  Version:          20.10.24\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.19.7\n  Git commit:       5d6db84\n  Built:            Tue Apr  4 18:18:42 2023\n  OS/Arch:          linux/amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.18\n  GitCommit:        2456e983eb9e37e47538f59ea18f2043c9a73640\n runc:\n  Version:          1.1.4\n  GitCommit:        v1.1.4-0-g5fd4c4d\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#instalacion-de-docker-en-arch","title":"Instalaci\u00f3n de Docker en Arch.","text":"<p>Para instalar Docker en Arch sigue los siguientes pasos:</p> <p>1). Instalar el paquete de Docker Desktop manualmente porque Docker no tiene un repositorio de paquetes Arch.</p> <p>2). Instalar Docker client binary en Linux.</p> <ul> <li> <p>Descargar el archivo binario est\u00e1tico en https://download.docker.com/linux/static/stable/, elige la correspondiente y descarga el archivo <code>.tgz</code>.</p> </li> <li> <p>Extraer el archivo usando el comando <code>tar</code>:</p> </li> </ul> <p><code>bash   $ tar xzvf /path/to/&lt;FILE&gt;.tar.gz</code></p> <ul> <li>OPCIONAL. Mover el archivo binario a un directorio de path.</li> </ul> <p><code>bash   $ sudo cp docker/* /usr/bin/</code></p> <ul> <li>Empezar el Docker daemon:</li> </ul> <p><code>bash   $ sudo dockerd &amp;</code></p> <ul> <li>Verificar que Docker esta instalado correctamente, con una imagen de hello-world:</li> </ul> <p><code>bash    $ sudo docker run hello-world</code></p> <p>3). Descargar el paquete Arch en la siguiente pagina:</p> <p>https://docs.docker.com/desktop/release-notes/</p> <p>4). Instalar el paquete: </p> <pre><code>$ sudo pacman -U ./docker-desktop-&lt;version&gt;-&lt;arch&gt;.pkg.tar.zst\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#version","title":"Versi\u00f3n:","text":"<pre><code>$ docker compose version\nDocker Compose version v2.5.0\n\n$ docker --version\nDocker version 20.10.14, build a224086349\n\n$ docker version\nClient: Docker Engine - Community\nCloud integration: 1.0.24\nVersion:           20.10.14\nAPI version:       1.41\n...\n</code></pre> <p>by Yana Zhu</p>"},{"location":"02.-Instalaci%C3%B3n/04.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"Instalar Docker en Ubuntu","text":"<p>Vamos a seguir los pasos que hay que realizar para instalar Docker versi\u00f3n 20.04 en Ubuntu.</p> <p>Primero debemos de actualizar nuestra lista de paquetes:</p> <pre><code>$ sudo apt update\n</code></pre> <p>Luego, debemos instalar algunos paquetes de requisitos previos que permitan a <code>apt</code> usar paquetes a trav\u00e9s de HTTPS:</p> <pre><code>$ sudo apt install apt-transport-https ca-certificates curl software-properties-common\n</code></pre> <p>A continuaci\u00f3n, a\u00f1adimos la clave de GPG para el repositorio oficial de Docker en nuestro sistema:</p> <pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre> <p>Agregamos el repositorio de Docker a las fuentes de APT:</p> <pre><code> $ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\"\n</code></pre> <p>Actualizamos el paquete de base de datos con los paquetes de Docker del repositorio reci\u00e9n agregado:</p> <pre><code>$ sudo apt update\n</code></pre> <p>Ahora nos aseguramos de estar en el repositorio de Docker en lugar del repositorio predeterminado de Ubuntu para realizar la instalaci\u00f3n:</p> <pre><code>$ apt-cache policy docker-ce\n</code></pre> <p>Por \u00faltimo, instalamos Docker:</p> <pre><code>$ sudo apt install docker-ce\n</code></pre> <p>Ya est\u00e1 Docker instalado, para comprobarlo usamos:</p> <pre><code>$ sudo systemctl status docker\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/05.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"Instalaci\u00f3n de Docker en Ubuntu","text":"<p>Instalaremos la \u00faltima versi\u00f3n 23.0.4 de Docker en las versiones de Ubuntu 18.04, 20.04, 21.10 y 22.04.</p>"},{"location":"02.-Instalaci%C3%B3n/05.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#instalar-docker-con-el-repositorio-apt","title":"Instalar Docker con el Repositorio apt","text":"<p>Para instalar Docker desde el repositorio apt lo primero que deberemos de realizar es utilizar el siguiente comando:</p> <pre><code>sudo apt update\n</code></pre> <p>Este comando ser\u00e1 utilizado para ver si tenemos todos nuestros paquetes del sistema actualizados.</p> <p>Una vez finalizado ese paso deberemos instalar los certificados necesarios:</p> <pre><code>sudo apt install ca-certificates curl gnupg lsb-release\n</code></pre> <p>A continuaci\u00f3n, registra el llavero GPG de Docker con apt. Esto permitir\u00e1 a apt validar los paquetes Docker que instales.</p> <pre><code>sudo mkdir -p /etc/apt/keyrings\n</code></pre> <pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n</code></pre> <pre><code>$ sudo chmod a+r /etc/apt/keyrings/docker.gpg\n</code></pre> <p>Con el comando <code>curl</code> nos descargaremos la clave GPG de Docker para Ubuntu, la cual se guarda en el directorio de llaveros de apt. </p> <p>Para a\u00f1adir la fuente del paquete Docker al sistema debemos ejecutar el comando <code>echo</code> de la siguiente forma:</p> <pre><code>echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> <p>Esto utiliza la sustituci\u00f3n del shell para detectar autom\u00e1ticamente la arquitectura de tu sistema y descargar la lista de paquetes adecuada.</p> <p>Actualizamos de nuevo la lista de paquetes para que apt sepa que los paquetes Docker existen:</p> <pre><code>sudo apt update\n</code></pre> <p>Ahora podemos utilizar el comando apt install para a\u00f1adir los componentes de Docker al sistema.</p> <pre><code>sudo apt install docker-ce docker-ce-cli containerd.io\n</code></pre> <p>Por ultimo para comprobar que tenemos bien instalado Docker realizaremos el comando siguiente para su funcionamiento:</p> <pre><code>docker run hello-world\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/06.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"06.-Instalaci\u00f3n r\u00e1pida en Ubuntu","text":""},{"location":"02.-Instalaci%C3%B3n/06.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#pasos-para-instalar-docker","title":"Pasos para instalar Docker","text":"<p>Instalaci\u00f3n de Docker en Ubuntu 20.04 de Ubuntu.</p> <p>Primero, actualice su lista de paquetes existente:</p> <pre><code>sudo apt update\n</code></pre> <p>A continuaci\u00f3n, instale algunos paquetes de requisitos previos que permitan a <code>apt</code> usar paquetes a trav\u00e9s de HTTPS:</p> <pre><code>sudo apt install apt-transport-https ca-certificates curl software-properties-common\n</code></pre> <p>Luego, a\u00f1ada la clave de GPG para el repositorio oficial de Docker en su sistema:</p> <pre><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre> <p>Agregue el repositorio de Docker a las fuentes de APT:</p> <pre><code>sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\"\n</code></pre> <p>A continuaci\u00f3n, actualice el paquete de base de datos con los paquetes de Docker del repositorio reci\u00e9n agregado:</p> <pre><code>sudo apt update\n</code></pre> <p>Aseg\u00farese de estar a punto de realizar la instalaci\u00f3n desde el  repositorio de Docker en lugar del repositorio predeterminado de Ubuntu:</p> <pre><code>apt-cache policy docker-ce\n</code></pre> <p>Si bien el n\u00famero de versi\u00f3n de Docker puede ser distinto, ver\u00e1 un resultado como el siguiente:</p> <p>Output of apt-cache policy docker-ce</p> <p></p> <p>Observe que <code>docker-ce</code> no est\u00e1 instalado, pero la opci\u00f3n m\u00e1s viable para la instalaci\u00f3n es del repositorio de Docker para Ubuntu 20.04 (<code>focal</code>).</p> <p>Por \u00faltimo, instale Docker:</p> <pre><code>sudo apt install docker-ce\n</code></pre> <p>Con esto, Docker quedar\u00e1 instalado, el demonio se iniciar\u00e1 y el  proceso se habilitar\u00e1 para ejecutarse en el inicio. Compruebe que  funcione:</p> <pre><code>sudo systemctl status docker\n</code></pre> <p>El resultado debe ser similar al siguiente, y mostrar que el servicio est\u00e1 activo y en ejecuci\u00f3n:</p> <p></p> <p>La instalaci\u00f3n de Docker ahora le proporcionar\u00e1 no solo el servicio  de Docker (demonio) sino tambi\u00e9n la utilidad de l\u00ednea de comandos <code>docker</code> o el cliente de Docker. </p>"},{"location":"02.-Instalaci%C3%B3n/06.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#como-asegurarte-de-que-el-motor-docker-funciona-en-ubuntu","title":"C\u00f3mo Asegurarte de que el Motor Docker Funciona en Ubuntu.","text":"<p>Utilizar esta linea de comando, para asegurarte de que todo funciona iniciando un contenedor:</p> <pre><code>$ sudo docker run hello-world\n</code></pre> <p>Ver\u00e1s que el cliente Docker extrae el <code>hello-world:latest</code> a tu m\u00e1quina, desde el repositorio Docker Hub:</p> <p>A continuaci\u00f3n, se iniciar\u00e1 autom\u00e1ticamente un nuevo contenedor. La  imagen de inicio \u00abhola-mundo\u00bb est\u00e1 configurada para ejecutar un simple  comando que emite alguna informaci\u00f3n b\u00e1sica sobre Docker y luego sale  inmediatamente:</p> <p></p> <p>Al ver la salida mostrada arriba, significa que Docker est\u00e1 listo para ser utilizado.</p>"},{"location":"03.-Conceptos%20Clave/","title":"Conceptos Clave","text":"<p>01.-Im\u00e1genes</p> <p>02.-Contenedores</p> <p>03.-Vol\u00famenes</p> <p>04.-Capas</p> <p>05.-Redes</p> <p>06.-Estructura de docker</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/","title":"02.-Contenedores","text":"<p>En pocas palabras, un contenedor es un proceso de espacio aislado en su m\u00e1quina que est\u00e1 al margen de todos los dem\u00e1s procesos en la m\u00e1quina host. Ese aislamiento aprovecha los\u00a0espacios de nombres del kernel y cgroups, caracter\u00edsticas que han estado en Linux durante mucho tiempo. Docker ha trabajado para que estas capacidades sean accesibles y f\u00e1ciles de usar. Para resumir, un contenedor:</p> <ul> <li>Un contenedor es una imagen instanciada (en ejecuci\u00f3n). Se puede crear, iniciar, detener, mover o eliminar un contenedor mediante DockerAPI o CLI.</li> <li>No albergan un sistema operativo sino que a\u00edslan el espacio de usuario.</li> <li>Son muy ligeros porque corren como un proceso sobre el SO del host.</li> <li>Puede ejecutarse en m\u00e1quinas locales, m\u00e1quinas virtuales o implementarse en la nube.</li> <li>Escalan en funci\u00f3n de la demanda, mientras que las M\u00e1quinas Virtuales (MV) tienen que ser aprovisionadas de recursos previamente.</li> <li>Est\u00e1 aislado de otros contenedores y ejecuta su propio software, binarios y configuraciones.</li> </ul> <p>Una imagen de Docker es un archivo compuesto por m\u00faltiples capas que se utiliza para ejecutar c\u00f3digo en un contenedor de Docker. Estas im\u00e1genes son las plantillas base desde la que partimos ya sea para crear una nueva imagen o crear nuevos contenedores para ejecutar las aplicaciones.</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#contenedores-windows-y-contenedores-linux","title":"Contenedores Windows y contenedores Linux","text":"<p>Los contenedores Windows corren sobre Windows y los contenedores Linux sobre Linux Se diferencian en los tipos de aislamiento que tienen ambos</p> <p>Los contenedores Linux:</p> <ul> <li>Se ejecutan sobre el host de modo que son visibles a ellos</li> <li>Se ejecutan sobre el kernel como un proceso visible desde el host</li> </ul> <p>Los contenedores Windows:</p> <ul> <li>Se ejecutan sobre una m\u00e1quina virtual l\u00ednux controlada por el hipervisor de windows (Hyper-V)</li> <li>En Hyper-V Windows lanza una MV super fina que tiene su propio kernel y por tanto los contenedores no son visibles desde el propio SO.</li> </ul>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#portabilidad","title":"Portabilidad","text":"<p>Un contenedor es ejecutado por lo que se denomina el Docker Engine, un demonio que es f\u00e1cilmente instalable en todas las distribuciones Linux y tambi\u00e9n en Windows. Un contenedor ejecuta una imagen de docker, que es una representaci\u00f3n del sistema de ficheros y otros metadatos que el contenedor va a utilizar para su ejecuci\u00f3n. Una vez que hemos generado una imagen de Docker, ya sea en nuestro ordenador o v\u00eda una herramienta externa, esta imagen podr\u00e1 ser ejecutada por cualquier Docker Engine, independientemente del sistema operativo y la infraestructura que haya por debajo.</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#inmutabilidad","title":"Inmutabilidad","text":"<p>Una aplicaci\u00f3n la componen tanto el c\u00f3digo fuente como las librer\u00edas del sistema operativo y del lenguaje de programaci\u00f3n necesarias para la ejecuci\u00f3n de dicho c\u00f3digo. Estas dependencias van en funci\u00f3n, a su vez, del sistema operativo donde nuestro c\u00f3digo va a ser ejecutado, y por esto mismo ocurre muchas veces aquello de que \u201cno s\u00e9, en mi m\u00e1quina funciona\u201d. Sin embargo, el proceso de instalaci\u00f3n de dependencias en Docker no depende del sistema operativo, sino que este proceso se realiza cuando se genera una imagen de docker. Es decir, una imagen de docker (tambi\u00e9n llamada repositorio por su parecido con los repositorios de git) contiene tanto el c\u00f3digo de la aplicaci\u00f3n como las dependencias que necesita para su ejecuci\u00f3n. Una imagen se genera una vez y puede ser ejecutada las veces que sean necesarias, y siempre ejecutar\u00e1 con las misma versi\u00f3n del c\u00f3digo fuente y sus dependencias, por lo que se dice que es inmutable. Si unimos inmutabilidad con el hecho de que Docker es portable, decimos que Docker es una herramienta fiable, ya que una vez generada una imagen, \u00e9sta se comporta de la misma manera independientemente del sistema operativo y de la infraestructura donde se est\u00e9 ejecutando.</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#ligereza","title":"Ligereza","text":"<p>Los contenedores corriendo en la misma m\u00e1quina comparten entre ellos el sistema operativo, pero cada contenedor es un proceso independiente con su propio sistema de ficheros y su propio espacio de procesos y usuarios (para este fin Docker utiliza cgroups y namespaces, recursos de aislamiento basados en el kernel de Linux). Esto hace que la ejecuci\u00f3n de contenedores sea mucho m\u00e1s ligera que otros mecanismos de virtualizaci\u00f3n. Comparemos por ejemplo con otra tecnolog\u00eda muy utilizada como es Virtualbox. Virtualbox permite del orden de 4 \u00f3 5 m\u00e1quinas virtuales en un ordenador convencional, mientras que en el mismo ordenador podremos correr cientos de containers sin mayor problema, adem\u00e1s de que su gesti\u00f3n es mucho m\u00e1s sencilla.</p>"},{"location":"03.-Conceptos%20Clave/03.-Vol%C3%BAmenes/","title":"03.-Vol\u00famenes","text":"<p>En Docker, un volumen es un mecanismo para persistir los datos que se generan dentro de un contenedor de Docker, de manera que puedan ser compartidos y reutilizados por otros contenedores.</p> <p>Un volumen de Docker es un \u00e1rea de almacenamiento de datos que se encuentra fuera del sistema de archivos del contenedor y que se mantiene separada del ciclo de vida del contenedor. Esto significa que los datos almacenados en un volumen persistir\u00e1n incluso despu\u00e9s de que se elimine el contenedor.</p> <p>Los vol\u00famenes de Docker se pueden utilizar para diferentes fines, como por ejemplo:</p> <ul> <li>Compartir datos entre varios contenedores: Los vol\u00famenes permiten compartir datos entre varios contenedores de Docker, lo que facilita el intercambio de informaci\u00f3n entre diferentes aplicaciones y servicios.</li> <li>Almacenar datos persistentes: Los vol\u00famenes se pueden utilizar para almacenar datos que deben persistir m\u00e1s all\u00e1 del ciclo de vida de un contenedor, como por ejemplo datos de una base de datos.</li> <li>Hacer copias de seguridad de datos: Los vol\u00famenes permiten hacer copias de seguridad de los datos almacenados en un contenedor, lo que ayuda a proteger la informaci\u00f3n importante en caso de fallos en el sistema o errores humanos.</li> </ul>"},{"location":"03.-Conceptos%20Clave/04.-Capas/","title":"04.-Capas","text":"<p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas:</p> <ul> <li> <p>Para crear una imagen, generalmente se crea el archivo de texto <code>dockerfile</code> formado por diferentes instrucciones. Cada l\u00ednea representa una instrucci\u00f3n, y cada vez que se ejecuta el dockerfile se ejecutan dichas instrucciones de arriba a abajo.</p> </li> <li> <p>Estos <code>dockerfile</code>-s se almacenan como texto y se pueden compartir con facilidad, as\u00ed como almacenarse en sistemas de control de versiones.</p> </li> <li> <p>Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior.</p> </li> <li> <p>La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa.</p> </li> <li> <p>Cada imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados.</p> </li> <li> <p>Al final del <code>dockerfile</code>, la \u00faltima instrucci\u00f3n define el comando que se ejecutar\u00e1 cuando arranquemos el contenedor.</p> </li> <li> <p>Al ejecutar un comando a partir de la imagen creada, se ejecuta el comando especificado y se convierte en el proceso con PID 1 dentro del \u00e1rbol virtual de procesos.</p> </li> <li> <p>Cada vez que se ejecuta una instrucci\u00f3n, se crea un contenedor y se etiqueta con un hash creado para obtener un nombre \u00fanico. De este modo, podemos reutilizar estas capas intermedias y solo tener que construirlas una vez.</p> </li> </ul> <p>El contenedor seguir\u00e1 en marcha mientras el proceso creado siga en ejecuci\u00f3n.</p>"},{"location":"03.-Conceptos%20Clave/05.-Redes/","title":"05.-Redes","text":"<p>En Docker, las redes son una forma de conectar contenedores y permitir que se comuniquen entre s\u00ed y con otros servicios en la red. Las redes de Docker se utilizan para facilitar la comunicaci\u00f3n entre contenedores y para aislar los contenedores de otras redes. Docker proporciona varios tipos de redes, que se utilizan para diferentes prop\u00f3sitos:</p> <ul> <li> <p>Bridge network (red puente): Es la red predeterminada en Docker. Cada contenedor se conecta a una red puente virtual, que se encuentra en el host. Los contenedores en la misma red puente pueden comunicarse entre s\u00ed mediante sus nombres de host.</p> </li> <li> <p>Host network (red de host): En esta red, los contenedores se conectan directamente a la red del host, en lugar de a una red virtual. Esto permite que los contenedores tengan acceso directo a los recursos de red del host, pero tambi\u00e9n puede presentar problemas de seguridad.</p> </li> <li> <p>Overlay network (red de superposici\u00f3n): Esta red se utiliza para conectar contenedores que se ejecutan en diferentes hosts. Los contenedores en la misma red de superposici\u00f3n pueden comunicarse entre s\u00ed como si estuvieran en la misma red local.</p> </li> <li> <p>Macvlan network (red de Macvlan): Esta red se utiliza para conectar contenedores directamente a una interfaz de red f\u00edsica del host. Esto permite que los contenedores tengan direcciones IP \u00fanicas y se comuniquen directamente con otros dispositivos en la red.</p> </li> </ul> <p>Adem\u00e1s de estos tipos de redes, Docker tambi\u00e9n permite crear redes personalizadas para satisfacer las necesidades espec\u00edficas de una aplicaci\u00f3n o servicio.</p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/","title":"06.-Estructura de docker","text":"<p>Docker est\u00e1 formado fundamentalmente por tres componentes:</p> <ul> <li>Docker Engine</li> <li>Docker Client</li> <li>Docker Registry</li> </ul> <p></p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/#docker-engine-o-demonio-docker","title":"Docker Engine o Demonio Docker:","text":"<p>Es un demonio que corre sobre cualquier distribuci\u00f3n de Linux (y ahora tambi\u00e9n en Windows) y que expone una API externa para la gesti\u00f3n de im\u00e1genes y contenedores (y otras entidades que se van a\u00f1adiendo en sucesivas distribuciones de docker como vol\u00famenes o redes virtuales). Podemos destacar entre sus funciones principales:</p> <ul> <li>Creaci\u00f3n de im\u00e1genes docker.</li> <li>Publicaci\u00f3n de im\u00e1genes en un Docker Registry o Registro de Docker (otro componente  Docker que se explicar\u00e1 a continuaci\u00f3n).</li> <li>Descarga de im\u00e1genes desde un Registro de Docker</li> <li>Ejecuci\u00f3n de contenedores usando im\u00e1genes locales.</li> </ul> <p>Otra funci\u00f3n fundamental del Docker Engine es la gesti\u00f3n de los contenedores en ejecuci\u00f3n, permitiendo parar su ejecuci\u00f3n, rearrancarla, ver sus logs o sus estad\u00edsticas de uso de recursos.</p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/#docker-registry-o-registro-docker","title":"Docker Registry o Registro Docker","text":"<p>El Registro es otro componente de Docker que suele correr en un servidor independiente y donde se publican las im\u00e1genes que generan los Docker Engine de tal manera que est\u00e9n disponibles para su utilizaci\u00f3n por cualquier otra m\u00e1quina. Es un componente fundamental dentro de la arquitectura de Docker ya que permite distribuir nuestras aplicaciones. El Registro de Docker es un proyecto open source que puede ser instalado gratuitamente en cualquier servidor, pero Docker ofrece Docker Hub, un sistema SaaS de pago donde puedes subir tus propias im\u00e1genes, acceder a im\u00e1genes p\u00fablicas de otros usuarios, e incluso a im\u00e1genes oficiales de las principales aplicaciones como son: MySQL, MongoDB, RabbitMQ, Redis, etc.</p> <p>El registro de Docker funciona de una manera muy parecida a git (de la misma manera que Dockerhub y us m\u00e9todos de pago funcionan de una manera muy parecida a Github). Cada imagen, tambi\u00e9n conocida como repositorio, es una sucesi\u00f3n de capas. Es decir, cada vez que hacemos un build en local de nuestra imagen, el Registro de Docker s\u00f3lo almacena el diff respecto de la versi\u00f3n anterior, haciendo mucho m\u00e1s eficiente el proceso de creaci\u00f3n y distribuci\u00f3n de im\u00e1genes.</p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/#docker-client-o-cliente-docker","title":"Docker Client o Cliente Docker","text":"<p>Es cualquier herramienta que hace uso de la api remota del Docker Engine, pero suele hacer referencia al comando <code>docker</code> que hace las veces de herramienta de l\u00ednea de comandos (cli) para gestionar un Docker Engine. La cli de docker se puede configurar para hablar con un Docker Engine local o remoto, permitiendo gestionar tanto nuestro entorno de desarrollo local, como nuestros servidores de producci\u00f3n.</p>"},{"location":"03.-Conceptos%20Clave/01.-Im%C3%A1genes/01.-Im%C3%A1genes/","title":"01.-Im\u00e1genes","text":"<p>Una imagen de Docker es un paquete de software que contiene todo lo necesario para ejecutar una aplicaci\u00f3n, incluyendo el c\u00f3digo, las dependencias, el sistema operativo, las bibliotecas y las configuraciones.</p> <p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas.</p> <p>Las im\u00e1genes de Docker se utilizan como plantillas para crear contenedores de Docker, que son instancias en tiempo de ejecuci\u00f3n de una imagen.</p> <p>Las im\u00e1genes se crean a partir de un archivo de configuraci\u00f3n llamado <code>dockerfile</code>, que especifica los componentes y configuraciones necesarios para la aplicaci\u00f3n. Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior.</p> <p>La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa, por tanto, una imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados.</p> <p>Una vez que se ha creado una imagen de Docker, se puede almacenar en un registro de im\u00e1genes de Docker, como Docker Hub o un registro privado, para que otros usuarios puedan descargarla y utilizarla en la creaci\u00f3n de contenedores.</p> <p>Las im\u00e1genes de Docker son portables y se pueden ejecutar en cualquier sistema que admita la plataforma Docker. Adem\u00e1s, como las im\u00e1genes est\u00e1n aisladas del sistema operativo del host, se pueden ejecutar varias instancias de la misma imagen en diferentes contenedores sin interferir entre s\u00ed.</p>"},{"location":"03.-Conceptos%20Clave/01.-Im%C3%A1genes/02.-Docker%20Hub/","title":"02.-Docker Hub","text":"<p>Docker Hub es el mayor repositorio del mundo de im\u00e1genes de contenedores con una gran variedad de fuentes de contenido, incluidos desarrolladores, proyectos de c\u00f3digo abierto y proveedores de software independientes (ISV Independent Software Vendor) que construyen y distribuyen su c\u00f3digo en contenedores. Los usuarios tienen acceso a repositorios p\u00fablicos gratuitos para almacenar y compartir im\u00e1genes o pueden elegir un plan de suscripci\u00f3n para repositorios privados.</p>"},{"location":"04.-Manos%20a%20la%20obra/","title":"04.-Manos a la obra","text":"<p>Una vez instalado <code>docker</code> en nuestro sistema o en una m\u00e1quina virtual, empezamos con la parte pr\u00e1ctica y divertida del uso de esta tecnolog\u00eda. Para empezar vamos a familiarizarnos con el gesti\u00f3n de im\u00e1genes y contenedores desde nuestra querida l\u00ednea de comandos:</p> <p>01.-Versi\u00f3n y Gesti\u00f3n del Servicio</p> <p>02.-Usar el comando docker</p> <p>03.- Trabajar con im\u00e1genes de docker</p> <p>04.-Ejecutar un contenedor de Docker</p>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/","title":"01.-Versi\u00f3n y Gesti\u00f3n del Servicio","text":""},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#version","title":"Versi\u00f3n","text":"<pre><code>$ docker -version\n$ docker -v\n</code></pre> <pre><code>Docker version 23.0.3, build 3e7cbfdee1\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#estado-del-servicio","title":"Estado del servicio","text":"<pre><code>$ sudo systemctl status docker\n</code></pre> <pre><code>\u25cf docker.service - Docker Application Container Engine\n     Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; preset: disabled)\n     Active: active (running) since Fri 2023-04-21 10:10:47 CEST; 13min ago\nTriggeredBy: \u25cf docker.socket\n       Docs: https://docs.docker.com\n   Main PID: 685 (dockerd)\n      Tasks: 17\n     Memory: 123.2M\n        CPU: 438ms\n     CGroup: /system.slice/docker.service\n             \u2514\u2500685 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock\n\nabr 21 10:10:46 SDD dockerd[685]: time=\"2023-04-21T10:10:46.219884270+02:00\" level=info msg=\"Firewalld: i&gt;\nabr 21 10:10:46 SDD dockerd[685]: time=\"2023-04-21T10:10:46.744731604+02:00\" level=info msg=\"Default brid&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.019068520+02:00\" level=info msg=\"Firewalld: i&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.290530069+02:00\" level=info msg=\"Loading cont&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.415183339+02:00\" level=warning msg=\"Not using&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.415390693+02:00\" level=info msg=\"Docker daemo&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.415694639+02:00\" level=info msg=\"Daemon has c&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.470857994+02:00\" level=info msg=\"[core] [Serv&gt;\nabr 21 10:10:47 SDD systemd[1]: Started Docker Application Container Engine.\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.494255040+02:00\" level=info msg=\"API listen o&gt;\nlines 1-22/22 (END)\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#arranque-del-servicio","title":"Arranque del servicio","text":"<pre><code>$ sudo sytemctl start docker\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#parada-del-servicio","title":"Parada del servicio","text":"<pre><code>$ sudo sytemctl stop docker\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#habilitacion-del-servicio","title":"Habilitaci\u00f3n del servicio","text":"<p>Podemos hacer que el servicio arranque con el sistema con el siguiente comando:</p> <pre><code>$ sudo systemctl enable docker\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#deshabilitacion-del-servicio","title":"Deshabilitaci\u00f3n del servicio","text":"<p>Podemos hacer que el servicio NO arranque con el sistema con el siguiente comando:</p> <pre><code>$ sudo systemctl disable docker\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/02.-Usar%20el%20comando%20docker/","title":"02.-Usar el comando docker","text":"<p>El uso de docker consiste en pasar a este una cadena de opciones y comandos seguida de argumentos. La sintaxis adopta esta forma:</p> <pre><code>$ docker [opciones] [comando] [argumento]\n</code></pre> <p>Para ver todos los subcomandos disponibles, escribimos lo siguiente:</p> <pre><code>$ docker\n</code></pre> <p>Si deseamos ver las opciones disponibles para un comando espec\u00edfico, escribimos lo siguiente:</p> <pre><code>$ docker &lt;subcomando-docker&gt; \u2013help\n</code></pre> <p>Para ver informaci\u00f3n sobre <code>docker</code> relacionada con todo el sistema, utilizamos el siguiente comando:</p> <pre><code>$ docker info\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/03.-%20Trabajar%20con%20im%C3%A1genes%20de%20docker/","title":"03.- Trabajar con im\u00e1genes de docker","text":"<p>Los contenedores de Docker se construyen con im\u00e1genes de Docker. Por defecto, Docker obtiene estas im\u00e1genes de Docker Hub, un registro de Docker gestionado por Docker, la empresa responsable del proyecto Docker. Cualquiera puede alojar sus im\u00e1genes en Docker Hub, de modo que la mayor\u00eda de las aplicaciones y las distribuciones de Linux que necesitaremos tendr\u00e1n im\u00e1genes alojadas all\u00ed.</p> <p>Podemos buscar im\u00e1genes disponibles en Docker Hub usando el comando <code>docker</code> con el subcomando <code>search</code>. Por ejemplo, para buscar la imagen de Ubuntu, escribimos lo siguiente:</p> <pre><code>$ docker search ubuntu\n</code></pre> <p>El comando que acabamos de ejecutar buscar\u00e1 en los repositorios de Docker Hub en busca de im\u00e1genes que coincidan con el criterio de b\u00fasqueda y devuelve los posibles candidatos.</p> <p>En la columna de OFFICIAL, OK indica que la imagen creada est\u00e1 avalada por la empresa responsable del proyecto. Una vez que identifique la imagen que desear\u00eda usar, podemos descargarla utilizando el subcomando docker pull.</p> <pre><code>$ docker pull ubuntu\n</code></pre> <p>Para ver las im\u00e1genes que tenemos disponibles localmente utilizamos el comando:</p> <pre><code>$ docker images\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/04.-Ejecutar%20un%20contenedor%20de%20Docker/","title":"04.-Ejecutar un contenedor de Docker","text":"<p>El contenedor <code>hello-world</code> que creamos en la instalaci\u00f3n es un ejemplo de un contenedor que se ejecuta y se cierra tras emitir un mensaje de prueba. Los contenedores pueden ofrecer una utilidad mucho mayor y ser interactivos</p> <p>Como ejemplo, ejecutemos un contenedor usando la imagen m\u00e1s reciente de Ubuntu. La combinaci\u00f3n de los conmutadores <code>-i</code> y <code>-t</code> le proporcionan un acceso interactivo del shell al contenedor:</p> <pre><code>$ docker run -it ubuntu\n</code></pre> <p>Nuestros s\u00edmbolos del sistema deben cambiar para reflejar el hecho de que ahora estamos trabajando dentro del contenedor.</p> <p>Ahora podemos ejecutar cualquier comando dentro del contenedor. Por ejemplo, actualizar los repositorios. No es necesario prefijar ning\u00fan comando con sudo, ya que todas las operaciones dentro del contenedor se ejecutan por defecto con el usuario root:</p> <pre><code>$ apt update\n</code></pre> <p>Importante: Cuando trabajamos con contenedores debemos tener en cuenta un detalle y es que las im\u00e1genes que implementamos en muchas ocasiones pueden no tener instaladas algunas aplicaciones que por defecto s\u00ed vienen instaladas en otras im\u00e1genes. Un claro ejemplo es que el contenedor de Ubuntu que estamos utilizando no tiene el editor de texto <code>nano</code>.</p> <p>El motivo por el que no est\u00e1 instalado por defecto este editor es simple, las im\u00e1genes de Docker buscan ser lo m\u00e1s ligeras y modulares posibles para ofrecer servicios de una manera sencilla y r\u00e1pida. Por lo que instalar programas innecesarios que har\u00edan que el tama\u00f1o de la m\u00e1quina fuese mayor va en contra del prop\u00f3sito por el que fue creada esta tecnolog\u00eda.</p> <p>Para instalar nano ejecutamos el comando apt seguido del programa que deseamos instalar.</p> <pre><code>$ apt install nano\n</code></pre>"},{"location":"intermezzo/Docker%20Compose/","title":"Docker Compose","text":"<p>Docker Compose es una herramienta que se utiliza para definir y ejecutar aplicaciones Docker de m\u00faltiples contenedores. Con Docker Compose, se puede definir una aplicaci\u00f3n en un archivo YAML y luego ejecutarla con un solo comando. Docker Compose tambi\u00e9n permite la creaci\u00f3n de redes personalizadas y vol\u00famenes de datos para los contenedores.</p> <p>Docker Compose es \u00fatil para simplificar la gesti\u00f3n de aplicaciones Docker complejas. Por ejemplo, si una aplicaci\u00f3n consta de varios contenedores que deben comunicarse entre s\u00ed, Docker Compose puede definir f\u00e1cilmente las relaciones entre los contenedores y las redes que los conectan. Tambi\u00e9n puede definir vol\u00famenes de datos para los contenedores, lo que permite el almacenamiento persistente de datos.</p> <p>Presentamos a continuaci\u00f3n un ejemplo de un archivo YAML de Docker Compose para una aplicaci\u00f3n Django:</p> <pre><code>version: '3'\n\nservices:\n    db:\n        image: postgres\n    environment:\n        POSTGRES_DB: django_db\n        POSTGRES_USER: django_user\n        POSTGRES_PASSWORD: django_password\n\n    web:\n        build: .\n            command: python manage.py runserver 0.0.0.0:8000\n        volumes:\n        -  .:/code\n\nports:\n    - \"8000:8000\"\n\ndepends_on:\n    - db\n</code></pre> <p>En este ejemplo, se definen dos servicios: <code>db</code> y <code>web</code>. El servicio <code>db</code> utiliza la imagen de <code>postgres</code> y se definen las variables de entorno para la base de datos. El servicio <code>web</code> se construye a partir del directorio actual y se ejecuta el comando para iniciar el servidor Django. Tambi\u00e9n se define un volumen para el c\u00f3digo fuente y se expone en el puerto 8000. El servicio <code>web</code> depende del servicio <code>db</code>.</p>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/","title":"Docker en python y django","text":"<p>Ok, suficiente teor\u00eda. Empecemos a usar Docker y Django juntos. El primer paso es registrarse en Docker Hub para obtener una cuenta gratuita y luego instalar la aplicaci\u00f3n de escritorio Docker en nuestra m\u00e1quina local:</p> <ul> <li>Docker para Linux</li> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker</code></li> <li>Docker para Mac</li> <li>Docker para Windows</li> </ul> <p>Esta descarga puede tomarse alg\u00fan tiempo ya que es un archivo grande.</p> <p>Una vez que Docker se haya terminado de instalar, podemos confirmar que se est\u00e1 ejecutando la versi\u00f3n correcta escribiendo <code>docker --version</code> en la l\u00ednea de comandos. Debe ser al menos la versi\u00f3n 18.</p> <pre><code>$ docker --version\nDocker versi\u00f3n 19.03.5-ce, build 633a0ea838\n</code></pre> <p>Docker se utiliza a menudo con una herramienta adicional, Docker Compose, para ayudar a automatizar los comandos. Docker Compose se incluye con las descargas de Mac y Windows, pero si se est\u00e1 en Linux, tendr\u00e1 que a\u00f1adirse manualmente. Puede hacerse ejecutando el comando <code>sudo pip install docker-compose</code> despu\u00e9s de que la instalaci\u00f3n de Docker haya finalizado.</p> <ul> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker-compose</code>. (Si surgen problemas con alg\u00fan fichero ya instalado en el sistema, borrar todos aquellos ficheros que est\u00e9n involucrados y proceder con la instalaci\u00f3n como se indica)</li> </ul>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#docker-hola-mundo","title":"Docker, Hola Mundo","text":"<p>Docker se env\u00eda con su propia imagen de \"Hello, World\" que es un primer paso \u00fatil para comprobar la instalaci\u00f3n. Introducir en la l\u00ednea de comandos el comando <code>docker run hello-world</code>. Esto descargar\u00e1 una imagen Docker oficial y luego se ejecutar\u00e1 dentro de un contenedor. Se discutir\u00e1 sobre las im\u00e1genes y los contenedores en breve.</p> <pre><code>$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete\nDigest: sha256:b8ba256769a0ac28dd126d584e0a2011cd2877f3f76e093a7ae560f2a5301c00\nStatus: Downloaded newer image for hello-world:latest\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n(amd64)\n 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.\nTo try something more ambitious, you can run an Ubuntu container with:\n$ docker run -it ubuntu bash\nShare images, automate workflows, and more with a free Docker ID:\nhttps://hub.docker.com/\nFor more examples and ideas, visit:\nhttps://docs.docker.com/get-started/\n</code></pre> <p>El comando <code>docker info</code> nos permite inspeccionar Docker. Contendr\u00e1 una gran cantidad de informaci\u00f3n, pero si nos centramos en las l\u00edneas superiores tenemos 1 contenedor que se detenido y 1 imagen.</p> <pre><code>$ docker info\nClient:\n Debug Mode: false\n\nServer:\n Containers: 1\n  Running: 0\n  Paused: 0\n  Stopped: 1\n Images: 1\n...\n</code></pre>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#django-hola-mundo","title":"Django, Hola mundo","text":"<p>Ahora vamos a crear un proyecto de Django \"Hello, World\" que se ejecuta localmente en nuestro ordenador y luego lo moveremos por completo dentro de Docker para que se pueda ver c\u00f3mo encajan todas las piezas.</p> <p>El primer paso es elegir una ubicaci\u00f3n para nuestro c\u00f3digo. Esto puede ser en cualquier parte del ordenador pero si est\u00e1s en Linux, una ubicaci\u00f3n f\u00e1cil de encontrar es el Escritorio . Desde la l\u00ednea de comandos navegamos hasta el <code>Escritorio</code> y creamos un directorio <code>code</code> para todos los ejemplos:</p> <pre><code>$ cd ~/Desktop\n$ mkdir code &amp;&amp; cd code\n</code></pre> <p>Luego creeamos un directorio <code>hello</code> donde  instalaremos Django usando Pipenv que crea un archivo Pipfile y un archivo Pipfile.lock.  Activamos el entorno virtual con el comando <code>shell</code>.</p> <pre><code>$ mkdir hello &amp;&amp; cd hello\npipenv install django==2.2.7\n$ pipenv shell\n(hello) $\n</code></pre> <p>Si se necesita ayuda para instalar Pipenv o Python 3, se pueden encontrar m\u00e1s detalles aqu\u00ed. Ahora podemos usar el comando <code>startproject</code> para crear un nuevo proyecto de Django llamado <code>hello_project</code>. A\u00f1adir un punto, <code>.</code>, al final del comando es un paso opcional pero muchos desarrolladores de Django lo hacen. Sin el punto, Django a\u00f1ade un directorio adicional al proyecto; con el <code>.</code>, esto no ocurre. Por \u00faltimo, utilice el comando <code>migrate</code> para inicializar la base de datos e iniciar la web local con el comando <code>runserver</code>.</p> <pre><code>(hola) $ django-admin startproject hello_project .\n(hola) $ python manage.py migrate\n(hola) $ python manage.py runserver\n</code></pre> <p>Suponiendo que todo ha funcionado correctamente, ahora deber\u00edamos poder navegar para ver el la p\u00e1gica de bienvenida de Django en http://127.0.0.1:8000/ en su navegador web.</p> <p></p>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#pages-app","title":"Pages App","text":"<p>Ahora haremos una p\u00e1gina de inicio simple creando una <code>pages</code> app espec\u00edfica  para ello. Parar el servidor local escribiendo Control+c y luego usar el comando <code>startapp</code> a\u00f1adiendo el nombre de la <code>pages</code> que se desee.</p> <pre><code>(hola) $ python manage.py startapp pages\n</code></pre> <p>Django instala autom\u00e1ticamente un nuevo directorio de p\u00e1ginas y varios archivos para nosotros. Pero incluso aunque la app ha sido creada, nuestro <code>hello_project</code> no la reconocer\u00e1 hasta que la a\u00f1adamos a la configuraci\u00f3n de <code>INSTALLED_APPS</code> de archivo <code>hello_project/settings.py</code>.</p> <p>Django carga las apps de arriba a abajo, por lo que, en general, es una buena pr\u00e1ctica a\u00f1adir las nuevas aplicaciones debajo de las aplicaciones incorporadas en las que pueden confiar, tales como <code>admin</code>, <code>auth</code>, y todas las aplicaciones restantes.</p> <p>T\u00e9ngase en cuenta que si bien es posible simplemente escribir el nombre de la app, <code>pages</code>,  es mejor escribir la <code>pages.apps.apps.PagesConfig</code> completa lo que abre m\u00e1s posibilidades en la configuraci\u00f3n de las apps.</p> <pre><code># hello_project/settings.py\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'pages.apps.apps.PagesConfig', # nuevo\n]\n</code></pre> <p>Ahora podemos establecer la ruta URL para la app <code>pages</code>. Ya que queremos que nuestro mensaje aparezca en la p\u00e1gina de inicio usaremos la cadena vac\u00eda <code>''</code> . No olvidar a\u00f1adir la importaci\u00f3n de <code>include</code> en la segunda l\u00ednea tambi\u00e9n.</p> <pre><code># hello_project/urls.py\nfrom django.contrib import admin\nfrom django.urls import path, include # nuevo\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('pages.urls')), # nuevo\n]\n</code></pre> <p>En lugar de crear una plantilla en este punto, podemos simplemente codificar un mensaje en nuestra capa de la vista <code>pages/views.py</code> que producir\u00e1 la cadena <code>Hello, World!</code>.</p> <pre><code># pages/views.py\nfrom django.http import HttpResponse\n\ndef home_page_view(request):\n    return HttpResponse('Hello, World!')\n</code></pre> <p>\u00bfQu\u00e9 es lo siguiente? El \u00faltimo paso es crear un archivo <code>urls.py</code> dentro de la app <code>pages</code>y enlazarlo to <code>home_page_view</code>. Si se encuentra en un ordenador Mac o Linux, el comando <code>touch</code> se puede usar desde la l\u00ednea de comandos para crear nuevos archivos. En Windows habr\u00e1 que crear el nuevo archivo con un editor de texto.</p> <pre><code>(hola) $ touch pages/urls.py\n</code></pre> <p>En el editor de texto importar <code>path</code> en la primera l\u00ednea, a\u00f1adir la <code>home_page_view</code>, y colocar su ruta para otra vez ser la cadena vac\u00eda ''. N\u00f3tese que tambi\u00e9n provee un nombre opcional, <code>home</code>, para esta ruta lo cual es una buena pr\u00e1ctica.</p> <pre><code># pages/urls.py\nfrom django.urls import path\n\nfrom .views import home_page_view\n\n\nurlpatterns = [\npath('', home_page_view, name='home')\n]\n\n</code></pre> <p>El flujo completo de nuestra p\u00e1gina web Django es el siguiente:</p> <ul> <li>cuando un usuario va a su homepage ser\u00e1 primero encaminado a <code>hello_project/urls.py</code></li> <li>luego a <code>pages/urls.py</code></li> <li>y finalmente dirigido a la <code>home_page_view</code> que devuelve la cadena <code>Hello, World!</code></li> </ul> <p>El trabajo para una p\u00e1gina de inicio b\u00e1sica ha terminado. Iniciemos de nuevo el servidor local.</p> <pre><code>(hola) $ python manage.py runserver\n</code></pre> <p>Si se actualiza el navegador web en http://127.0.0.1:8000/, ahora saldr\u00e1 nuestro deseado mensaje.</p> <p></p> <p>Ahora es el momento de cambiar a Docker. Detengamos de nuevo el servidor local con Ctrl+C y salgamos de nuestro entorno virtual, que ya no necesitamos, escribiendo <code>exit</code>.</p> <pre><code>(hello) $ exit\n$\n</code></pre> <p>\u00bfC\u00f3mo sabemos que nuestro entorno virtual ya no est\u00e1 activo? No habr\u00e1 un par\u00e9ntesis alrededor del nombre de directorio en el prompt. Cualquier comando Django normal que se intente ejecutar en este punto fallar\u00e1. Por ejemplo, probar <code>python manage.py runserver</code> para ver lo que ocurre.</p> <pre><code>$ python manage.py runserver\nFile \"./manage.py\", line 14\n  ) from exc\n       ^\nSyntaxError: invalid syntax\n</code></pre> <p>Esto significa que estamos totalmente fuera del entorno virtual y preparados para Docker.</p>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#imagenes-contenedores-y-el-docker-host","title":"Im\u00e1genes, Contenedores y el \"Docker Host\"","text":"<p>Una imagen Docker es una instant\u00e1nea en el tiempo de lo que contiene un proyecto. Est\u00e1 representado por un <code>Dockerfile</code> y es literalmente una lista de instrucciones que deben ser construidas/ejecutadas. Un contenedor Docker es una instancia en ejecuci\u00f3n de una imagen. Para continuar con la analog\u00eda de nuestro apartamento de antes, la imagen es el plano o conjunto de planos del apartamento; el contenedor es el edificio real totalmente construido.</p> <p>El tercer concepto central es el Docker host, que es el sistema operativo subyacente. Es posible tener varios contenedores ejecut\u00e1ndose dentro de un mismo Docker host. Cuando nos referimos a c\u00f3digo o procesos que se ejecutan en el Docker, significa que se ejecutan en el Docker host.</p> <p>Creemos nuestro primer <code>Dockerfile</code> para ver toda esta teor\u00eda en acci\u00f3n.</p> <pre><code>$ touch Dockerfile\n</code></pre> <p>Dentro del <code>Dockerfile</code> agregamos el siguiente c\u00f3digo que recorreremos l\u00ednea por l\u00ednea m\u00e1s abajo.</p> <pre><code># Pull base image\nFROM python:3.8\n\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n\n# Set work directory\nWORKDIR /code\n\n\n# Install dependencies\nCOPY Pipfile Pipfile.lock /code/\nRUN pip install pipenv &amp;&amp; pipenv install --system\n\n\n# Copy project\nCOPY . /code/\n</code></pre> <p>Los <code>Dockerfiles</code> se leen de arriba hacia abajo cuando se crea una imagen. La primera instrucci\u00f3n debe ser el comando <code>FROM</code> que nos permite importar una imagen base que usar, en nuestro caso Python 3.8.</p> <p>Luego usamos el comando <code>ENV</code> para establecer dos variables de entorno:</p> <ul> <li><code>PYTHONUNBUFFERED</code> asegura que la salida de nuestra consola se vea familiar y que no est\u00e9 almacenada en un b\u00fafer de Docker, lo cual no queremos</li> <li><code>PYTHONDONTWRITEBYTECODE</code> significa que Python no intentar\u00e1 escribir archivos <code>.pyc</code>, que tampoco deseamos</li> </ul> <p>A continuaci\u00f3n usamos <code>WORKDIR</code> para establecer una ruta de directorio de trabajo por defecto dentro de nuestra imagen llamada <code>code</code>que es donde guardaremos nuestro c\u00f3digo. Si no lo hicimos, entonces cada vez que queramos ejecutar comandos dentro de nuestro contenedor tendr\u00edamos que escribir una ruta muy larga. En su lugar, Docker asumir\u00e1 que queremos ejecutar todos los comandos desde este directorio.</p> <p>Para nuestras dependencias estamos usando <code>pipenv</code>, as\u00ed que copiamos tanto el archivo <code>Pipfile</code> como el archivo <code>Pipfile.lock</code> en el directorio <code>/code/</code> en Docker.</p> <p>Vale la pena tomarse un momento para explicar por qu\u00e9 <code>pipenv</code> crea un <code>Pipfile.lock</code>. El concepto de bloqueo de archivos no es exclusivo de Python o Pipenv; de hecho ya est\u00e1 presente en los gestores de paquetes de los lenguajes de programaci\u00f3n m\u00e1s modernos: <code>Gemfile.lock</code> en Ruby, <code>yarn.lock</code> en JavaScript, <code>composer.lock</code> en PHP, etc. Pipenv fue el primer proyecto popular en incorporarlos en la paqueter\u00eda de Python.</p> <p>La ventaja de un archivo de bloqueo es que esto conduce a una construcci\u00f3n determinista: no importa cu\u00e1ntas veces se instalen los paquetes de software, se obtendr\u00e1 el mismo resultado. Sin un fichero lock que \"bloquee\" las dependencias y su orden, no se cumplir\u00eda necesariamente. Lo que significa que dos miembros del equipo que instalan la misma lista de software pueden tener instalaciones de construcci\u00f3n ligeramente diferentes.</p> <p>Cuando estamos trabajando con Docker donde hay c\u00f3digo tanto local en nuestro ordenador como tambi\u00e9n dentro de Docker, el potencial de conflictos de <code>Pipfile.lock</code> surge cuando se actualizan paquetes de software.</p> <p>Siguiendo adelante usamos el comando <code>RUN</code> para instalar primero <code>pipenv</code> y luego <code>pipenv install</code> para instalar los paquetes de software listados en nuestro Pipfile.lock, actualmente s\u00f3lo Django. Es un es importante a\u00f1adir tambi\u00e9n el indicador <code>--system</code>, ya que por defecto Pipenv buscar\u00e1 el par\u00e1metro en el que instalar cualquier paquete, pero como estamos dentro de Docker ahora, t\u00e9cnicamente no hay ning\u00fan entorno virtual. En cierto modo, el contenedor Docker es nuestro entorno virtual y mucho m\u00e1s. As\u00ed que debemos usar la bandera <code>--system</code> para asegurarnos de que nuestros paquestes est\u00e1n disponibles en todo el Docker para nosotros.</p> <p>Como paso final copiamos el resto de nuestro c\u00f3digo local en el directorio <code>/code/</code> dentro de Docker. \u00bfPor qu\u00e9 copiamos el c\u00f3digo local dos veces, primero el Pipfile y Pipfile.lock y luego el resto? La raz\u00f3n es que las im\u00e1genes se crean en base a instrucciones de arriba hacia abajo por lo que queremos que las cosas que cambian a menudo -como nuestro c\u00f3digo local- sea el \u00faltimo. De esta manera s\u00f3lo tenemos que regenerar esa parte de la imagen ante un cambio y no se reinstala todo cada vez que lo haya. Como el software de los paquetes contenidos en nuestros <code>Pipfile</code> y <code>Pipfile.lock</code> cambian con poca frecuencia, implica que no tiene sentido copiarlos e instalarlos antes.</p> <p>Nuestras instrucciones de imagen ya est\u00e1n hechas, as\u00ed que vamos a construir la imagen usando el comando <code>docker build .</code>. El punto <code>.</code> indica que el directorio actual es donde se debe ejecutar el comando comando. Se genera una gran cantidad de texto en pantalla; s\u00f3lo se incluye las dos primeras l\u00edneas y las tres \u00faltimas.</p> <pre><code>$ docker build .\nSending build context to Docker daemon 154.1kB\nStep 1/7 : FROM python:3.8\n...\nStep 7/7 : COPY . /code/\n---&gt; a48b2acb1fcc\nSuccessfully built a48b2acb1fcc\n</code></pre> <p>Pasando a lo siguiente, ahora necesitamos crear un archivo <code>docker-composition.yml</code> para controlar c\u00f3mo ejecutar el comando que ser\u00e1 construido en base a nuestra imagen de <code>Dockerfile</code>.</p> <pre><code>$ touch docker-compose.yml\n</code></pre> <p>Contendr\u00e1 el siguiente c\u00f3digo</p> <pre><code>version: '3.7'\n\nservices:\n  web:\n    build: .\n    command: python /code/manage.py runserver 0.0.0.0:8000\n    volumes:\n      - .:/code\n    ports:\n      - 8000:8000\n</code></pre> <p>En la l\u00ednea superior se especifica la versi\u00f3n m\u00e1s reciente de Docker Compose que es actualmente 3.7  (no confundir con la versi\u00f3n de Python que puede ser bien parecida) A continuaci\u00f3n, especificamos qu\u00e9 <code>services</code> (o contenedores) queremos que funcionen en nuestro \"Docker host\". Es posible tener varios <code>services</code> funcionando, pero por ahora s\u00f3lo tenemos uno para el servidor <code>web</code>. Especificaremos c\u00f3mo construir el contenedor diciendo, \"Busca el directorio en curso <code>.</code> el <code>Dockerfile</code>\" . Luego, dentro del contenedor, ejecute el comando para arrancar el servidor local. El montaje de los vol\u00famenes sincroniza autom\u00e1ticamente el sistema de archivos Docker con nuestro sistema de archivos local. \u00a1Esto significa que no tenemos que reconstruir la imagen cada vez que cambiamos un solo fichero!.</p> <p>Por \u00faltimo especificamos los puertos (<code>ports</code>) a exponer dentro de Docker que solo ser\u00e1 el 8000, que es el puerto Django por defecto.</p> <p>Si es la primera vez que utiliza Docker, es muy probable que se est\u00e9 muy confundido en este momento. No hay motivo de preocupaci\u00f3n. Crearemos m\u00faltiples im\u00e1genes y contenedores Docker y, con la pr\u00e1ctica, el flujo comenzar\u00e1 a tener m\u00e1s sentido. Se ver\u00e1 como se usan archivos <code>Dockerfile</code> y <code>docker-composition.yml</code> muy similares en cada uno de los proyectos.</p> <p>El paso final es ejecutar nuestro contenedor Docker usando el comando <code>docker-compose up</code>. Este comando resultar\u00e1 en otro largo flujo de texto de salida en la l\u00ednea de comandos.</p> <pre><code>$ docker-compose up\nCreating network \"hello_default\" with the default driver\nBuilding web\nStep 1/7 : FROM python:3.8\n...\nCreating hello_web_1 ... done\nAttaching to hello_web_1\nweb_1 | Performing system checks...\nweb_1 |\nweb_1 | System check identified no issues (0 silenced).\nweb_1 | September 20, 2019 - 17:21:57\nweb_1 | Django version 2.2.5, using settings 'hello_project.settings'\nweb_1 | Starting development server at http://0.0.0.0:8000/\nweb_1 | Quit the server with CONTROL-C.\n</code></pre> <p>Para confirmar que realmente funcion\u00f3, volveremos a poner http://127.0.0.1:8000/ en el navegador web. Actualizaremos la p\u00e1gina y aparecer\u00e1 la p\u00e1gina \"Hello, World\".</p> <p>Django se est\u00e1 ejecutando ahora puramente dentro de un contenedor Docker. No estamos trabajando dentro de un entorno virtual local. No ejecutamos el comando <code>runserver</code>. Todo nuestro c\u00f3digo y nuestro servidor Django se est\u00e1 ejecutando desde dentro de un Docker aut\u00f3nomo. !Todo un \u00e9xito!</p> <p>Detendremos el contenedor con Ctrl+C y adem\u00e1s escribiremos <code>docker-compose down</code>. Los contenedores absorben una gran cantidad de memoria, as\u00ed que es una buena idea detenerlos de esta manera cuando hayamos terminado de usarlos.</p> <p>Los contenedores se han concebido para ser est\u00e1ticos (no pueden cambiar), por lo que utilizamos <code>volumes</code> para copiar nuestro c\u00f3digo en sitios donde si que pueda guardarse.</p> <pre><code>$ docker-compose down\nRemoving hello_web_1 ... done\nRemoving network hello_default\n</code></pre>"},{"location":"intermezzo/Instalaci%C3%B3n%20de%20zsh%20en%20ubuntu/","title":"Instalaci\u00f3n de zsh en ubuntu","text":"<p>Para instalar Zsh en Ubuntu, sigue los siguientes pasos:</p> <ul> <li>Abre una terminal en tu sistema Ubuntu.</li> <li>Actualiza la lista de paquetes de Ubuntu con el siguiente comando:</li> </ul> <pre><code>$ sudo apt update\n</code></pre> <ul> <li>Ahora, instala Zsh con el siguiente comando:</li> </ul> <pre><code> sudo apt install zsh\n</code></pre> <ul> <li>Despu\u00e9s de la instalaci\u00f3n, verifica que la versi\u00f3n de Zsh instalada es la \u00faltima disponible con:</li> </ul> <pre><code>zsh --version\n</code></pre> <ul> <li>Para configurar Zsh como tu shell predeterminada, utiliza el siguiente comando:</li> </ul> <pre><code>sudo chsh -s $(which zsh)\n</code></pre> <ul> <li>Cierra la sesi\u00f3n actual (saliendo del modo gr\u00e1fico) e inicia sesi\u00f3n nuevamente para que los cambios surtan efecto.</li> <li>Instalar Oh-my-zsh seg\u00fan las instrucciones de su p\u00e1gina web es decir, ejecutar el comando:</li> </ul> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre> <ul> <li>Abre tu terminal y ejecuta el siguiente comando para abrir el archivo de configuraci\u00f3n de Oh My Zsh:</li> </ul> <pre><code>vi ~/.zshrc\n</code></pre> <ul> <li>Busca la l\u00ednea que comienza con <code>ZSH_THEME</code> y cambia el valor despu\u00e9s del signo igual por el nombre del te   ma que quieres utilizar. Por ejemplo, si quieres utilizar el tema agnoster, la l\u00ednea deber\u00eda verse as\u00ed:</li> </ul> <pre><code>ZSH_THEME=\"agnoster\"\n</code></pre> <ul> <li> <p>Guarda los cambios y cierra el archivo de configuraci\u00f3n.</p> </li> <li> <p>Sal de tu sesi\u00f3n de terminal actual y vuelve a iniciarla para que los cambios tengan efecto.</p> </li> </ul> <p>instalacion_del_plugin_en_ZSH</p>"},{"location":"intermezzo/instalacion_del_plugin_en_ZSH/","title":"Instalaci\u00f3n del plugin de ZSH","text":"<p>La instalaci\u00f3n del plugin de Docker en Zsh puede variar dependiendo del m\u00e9todo que se utilice para instalar Zsh en tu sistema operativo. A continuaci\u00f3n, se describe el proceso de instalaci\u00f3n en sistemas operativos basados en Linux:</p> <ol> <li>Abre una terminal y aseg\u00farate de tener instalado Zsh en tu sistema y el gestor de paquetes Oh My Zsh. </li> <li>Ahora, abre el archivo de configuraci\u00f3n de Zsh en un editor de texto. Puedes hacerlo ejecutando el siguiente comando en la terminal:</li> </ol> <p><code>vim ~/.zshrc</code></p> <ol> <li>Busca la l\u00ednea que comienza con <code>plugins=</code> y agrega <code>docker</code> al final de la lista de plugins separados por espacios. Debe quedar algo como esto:</li> </ol> <p><code>plugins=(git docker)</code></p> <ol> <li> <p>Guarda los cambios y cierra el archivo.</p> </li> <li> <p>Ahora, reinicia Zsh para que los cambios tengan efecto:</p> </li> </ol> <p><code>source ~/.zshrc</code></p> <p>Una vez completados estos pasos, el plugin de Docker deber\u00eda estar instalado y listo para usarse en Zsh. Puedes probarlo ejecutando un comando de Docker en la terminal.</p>"},{"location":"intermezzo/instalacion_del_plugin_en_ZSH/#otros-plugins","title":"Otros plugins","text":"<p>Aparte del plugin oficial de Docker, hay varios otros plugins que puedes instalar en Zsh para trabajar con Docker. Algunos de los plugins m\u00e1s populares son:</p> <ul> <li>zsh-autosuggestions-docker: Este plugin agrega sugerencias autom\u00e1ticas para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/hlissner/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</code></p> <ul> <li>zsh-completion-docker: Este plugin agrega completado de tabulaci\u00f3n para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/docker/cli.git ~/.oh-my-zsh/custom/plugins/zsh-completion-docker</code></p> <ul> <li>zsh-syntax-highlighting-docker: Este plugin agrega resaltado de sintaxis para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting-docker</code></p> <p>Para utilizar estos plugins, debes agregarlos a la lista de plugins en el archivo de configuraci\u00f3n de Zsh (<code>~/.zshrc</code>) de la misma manera que se agreg\u00f3 el plugin de Docker. Por ejemplo:</p> <pre><code>plugins=(git docker zsh-autosuggestions zsh-completion-docker zsh-syntax-highlighting-docker)\n</code></pre> <p>Igual que antes y una vez que hayas agregado estos plugins, reinicia <code>zsh</code> para que los cambios tengan efecto. Luego, podr\u00e1s utilizar las funciones adicionales que ofrecen estos plugins para trabajar con <code>docker</code> en <code>zsh</code>.</p>"}]}