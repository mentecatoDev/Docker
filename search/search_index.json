{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li>01.-Introducci\u00f3n</li> <li>index</li> <li>03.-Conceptos Clave</li> <li>Gesti\u00f3n de im\u00e1genes</li> <li>Comandos b\u00e1sicos de Docker CLI para la gesti\u00f3n de im\u00e1genes y contenedores [2]</li> <li>Creaci\u00f3n de im\u00e1genes personalizadas y registro en Docker Hub [1]</li> <li>Implementaci\u00f3n de una aplicaci\u00f3n en contenedor de Docker [1]</li> <li>Integraci\u00f3n de Docker con herramientas de orquestaci\u00f3n como Kubernetes o Docker Compose [3]</li> <li>Buenas pr\u00e1cticas y consideraciones de seguridad para el uso de Docker [3] 01.-Introducci\u00f3n Docker en python y django</li> </ul>"},{"location":"01.-Introducci%C3%B3n/","title":"01.-Introducci\u00f3n","text":"<p>La configuraci\u00f3n adecuada de un entorno de desarrollo local sigue siendo un gran reto a pesar de todos los otros avances de la programaci\u00f3n moderna. Simplemente hay demasiadas variables: diferentes ordenadores, sistemas operativos, versiones de lenguajes y frameworks, opciones de entornos virtuales,  y as\u00ed sucesivamente. Cuando se a\u00f1ade el reto de trabajar en equipo en un entorno en el que todos necesitan tener la misma configuraci\u00f3n, el problema se magnifica.</p> <p>En los \u00faltimos a\u00f1os ha surgido una soluci\u00f3n: Docker. Aunque s\u00f3lo tiene unos pocos a\u00f1os, Docker se ha convertido r\u00e1pidamente en la opci\u00f3n por defecto para muchos desarrolladores que trabajan en proyectos a nivel de producci\u00f3n.</p> <p>Con Docker finalmente es posible reproducir un entorno de producci\u00f3n de forma fiel y fiable localmente, desde la versi\u00f3n adecuada del lenguaje hasta la instalaci\u00f3n de las librer\u00edas necesarias, a la par de ejecutar servicios adicionales como una base de datos a nivel de producci\u00f3n. Esto significa que ya no es importante si se desarrolla en un equipo Linux, Mac o Windows. Todo funciona dentro del mismo Docker.</p> <p>Docker tambi\u00e9n facilita exponencialmente la colaboraci\u00f3n en equipo. Atr\u00e1s quedaron los d\u00edas de compartir archivos README largos y obsoletos para a\u00f1adir un nuevo desarrollador a un proyecto de grupo.</p> <p>En lugar de eso, con Docker s\u00f3lo se tienen que compartir dos archivos: <code>Dockerfile</code> y  <code>docker-compose.yml</code> y el desarrollador puede tener la confianza de que su entorno de desarrollo local es exactamente igual que el del resto del equipo.</p> <p>Docker no es una tecnolog\u00eda perfecta. Todav\u00eda es relativamente nueva y compleja en sus entra\u00f1as; a\u00fan est\u00e1 en desarrollo activo. Pero aspira a la promesa de una pol\u00edtica coherente y a un entorno de desarrollo compartible, que pueda ejecutarse localmente en cualquier ordenador o desplegado en cualquier servidor, lo que lo convierte en una opci\u00f3n s\u00f3lida.</p>"},{"location":"01.-Introducci%C3%B3n/#que-es-docker","title":"\u00bfQu\u00e9 es Docker?","text":"<p>Docker es una forma de aislar todo un sistema operativo a trav\u00e9s de contenedores Linux que son un tipo de virtualizaci\u00f3n.</p> <p>La virtualizaci\u00f3n tiene sus ra\u00edces en los inicios de la inform\u00e1tica cuando las computadoras grandes y caras eran la norma. \u00bfC\u00f3mo podr\u00edan varios programadores utilizar la misma m\u00e1quina?. La respuesta fue la virtualizaci\u00f3n y espec\u00edficamente las m\u00e1quinas virtuales que son copias completas de un sistema inform\u00e1tico desde el sistema operativo en adelante. </p> <p>Cuando se alquila un espacio en un proveedor de cloud computing como Amazon Web Services (AWS) normalmente no se proporciona una pieza de hardware dedicada. En lugar de eso, se comparte un servidor f\u00edsico con otros clientes. Pero como cada cliente tiene su propio sistema virtual que se ejecuta en el servidor, le parece que tiene el suyo propio.</p> <p>Esta tecnolog\u00eda es la que hace posible a\u00f1adir o eliminar servidores de un servicio de cloud de forma r\u00e1pida y sencilla. Se trata en gran medida de software entre bastidores, no de hardware real.</p> <p>\u00bfCu\u00e1l es el inconveniente de una m\u00e1quina virtual? Tama\u00f1o y velocidad. Un sistema operativo hu\u00e9sped t\u00edpico (guest) puede ocupar f\u00e1cilmente hasta 700MB de tama\u00f1o. As\u00ed que si un servidor f\u00edsico soporta tres m\u00e1quinas virtuales, eso es al menos 2,1 GB de espacio en disco ocupado junto con el resto de necesidades para otros recursos como CPU y memoria.</p> <p>Al entrar en Docker, la idea clave es que la mayor\u00eda de los ordenadores dependen del mismo sistema operativo Linux. \u00bfY si virtualizamos desde la capa de Linux hacia arriba? \u00bfNo proporcionar\u00eda eso una forma m\u00e1s r\u00e1pida y ligera de duplicar gran parte de la misma funcionalidad? La respuesta es s\u00ed. Y en los \u00faltimos a\u00f1os los contenedores Linux se han vuelto muy populares. Para la mayor\u00eda de las aplicaciones, especialmente las aplicaciones web, una m\u00e1quina virtual proporciona mucho m\u00e1s recursos de los que se necesitan y un contenedor es m\u00e1s que suficiente.</p> <p>Esto, fundamentalmente, es Docker: \u00a1una forma de implementar contenedores Linux!</p> <p>Una analog\u00eda que podemos usar es la de los edificios y los apartamentos. Las m\u00e1quinas virtuales son como viviendas: edificios independientes con su propia infraestructura, incluida la fontaner\u00eda y calefacci\u00f3n, as\u00ed como cocina, ba\u00f1os, dormitorios, etc. Los contenedores Docker son como los apartamentos: comparten una infraestructura com\u00fan como la fontaner\u00eda y la calefacci\u00f3n, pero vienen en varios tama\u00f1os que se ajustan a las necesidades exactas de un propietario.</p>"},{"location":"01.-Introducci%C3%B3n/#contenedores-vs-entornos-virtuales","title":"Contenedores vs. Entornos Virtuales","text":"<p>Como programador de Python, por ejemplo, se debe estar familiarizado con el concepto de entornos virtuales que son una forma de aislar los paquetes Python. Gracias al entorno virtual, una computadora puede ejecutar m\u00faltiples proyectos localmente. Por ejemplo, el Proyecto A podr\u00eda usar Python 3.10 y Django 4.1 entre otras dependencias; mientras que el Proyecto B usa Python 3.8 y Django 2.2. Configurando un entorno virtual dedicado en cada proyecto se puede gestionar estos diferentes paquetes de software sin contaminar nuestro entorno global.</p> <p>Hay una peque\u00f1a confusi\u00f3n derivada de que hay m\u00faltiples herramientas en este momento para implementar un entorno virtual: desde <code>virtualenv</code>, <code>venv</code> a <code>pipenv</code> o <code>poetry</code>, pero fundamentalmente todas hacen lo mismo.</p> <p>La mayor distinci\u00f3n entre los entornos virtuales y Docker es que los entornos virtuales s\u00f3lo pueden aislar paquetes Python. No pueden aislar a los no-Python como una base de datos PostgreSQL o MySQL. Y siguen dependiendo del sistema global; de la instalaci\u00f3n de Python a nivel de sistema (en otras palabras, de su ordenador). Los entornos virtuales apuntan a una instalaci\u00f3n Python existente; no contienen Python en s\u00ed mismos.</p> <p>Los contenedores Linux van un paso m\u00e1s all\u00e1 y a\u00edslan todo el sistema operativo, no s\u00f3lo las partes de Python. En otras palabras, instalaremos el propio Python dentro de Docker, as\u00ed como se instalar\u00e1 y ejecutar\u00e1 en \u00e9l la base de datos a nivel de producci\u00f3n.</p>"},{"location":"02.-Instalaci%C3%B3n/","title":"02.-Instalaci\u00f3n","text":"<p>La documentaci\u00f3n oficial incluye instrucciones de instalaci\u00f3n de Docker Community para\u00a0MacOS,\u00a0Windows,\u00a0Linux\u00a0o servicios en la\u00a0nube.</p> <ul> <li>Instalaci\u00f3n en Ubuntu</li> <li>Instalaci\u00f3n en Arch</li> <li>Instalaci\u00f3n del plugin de ZSH</li> </ul> <p>Sin embargo existen modos m\u00e1s pr\u00e1cticos apoy\u00e1ndonos en el trabajo desarrollado por la comunidad en cada una de las distribuciones.</p> <p>01.-Instalaci\u00f3n r\u00e1pida en Arch Linux</p> <ul> <li>Enlaces:</li> </ul> <p>Conocimiento Libre en la Universidad de Costa Rica (UCR): Docker, aplicaciones en cualquier parte</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/","title":"01.-Instalaci\u00f3n r\u00e1pida en Arch Linux","text":""},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#actualizamos-repositorios","title":"Actualizamos repositorios","text":"<pre><code>sudo pacman -Syy\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalamos-docker-y-docker-compose","title":"Instalamos <code>docker</code> y <code>docker-Compose</code>","text":"<pre><code>sudo pacman -S docker docker-compose\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#iniciamos-docker-y-lo-habilitamos-para-que-se-inicie-al-reiniciar","title":"Iniciamos Docker y lo habilitamos para que se inicie al reiniciar","text":"<pre><code>sudo systemctl enable docker\nsudo systemctl start docker\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#comprobamos-la-version-de-docker-y-si-esta-instalado","title":"Comprobamos la versi\u00f3n de docker y si est\u00e1 instalado","text":"<p><code>docker -v</code></p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#anadimos-a-nuestro-usuario-para-controlar-docker","title":"A\u00f1adimos a nuestro usuario para controlar Docker","text":"<p>Creamos el grupo <code>docker</code>:</p> <pre><code>sudo groupadd docker\n</code></pre> <p>A\u00f1adimos al usuario:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <pre><code>Para que los cambios surtan efecto habr\u00e1 que reiniciar la sesi\u00f3n completamente, no basta con cerrar el terminal.\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#comprobar-la-instalacion","title":"Comprobar la instalaci\u00f3n","text":"<p>Para comprobar si Docker est\u00e1 instalado correctamente en tu sistema, puedes ejecutar el siguiente comando:</p> <pre><code>docker run hello-world\n</code></pre> <p>Este comando descargar\u00e1 la imagen <code>hello-world</code> de Docker Hub y la ejecutar\u00e1 en un contenedor. Si todo funciona correctamente, deber\u00edas ver un mensaje que indica que Docker est\u00e1 instalado y funcionando correctamente.</p> <pre><code>Unable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n2db29710123e: Pull complete \nDigest: sha256:4e83453afed1b4fa1a3500525091dbfca6ce1e66903fd4c01ff015dbcb1ba33e\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#docker-compose-en-arch-con-python","title":"Docker-Compose en Arch con Python","text":"<p>En principio ya se ha realizado la instalaci\u00f3n de <code>docker-compose</code>. Otra forma de hacer lo propio es mediante la herramienta de instalaci\u00f3n de paquetes de python <code>pip</code>.</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalando","title":"Instalando","text":"<p>Si no tienes instalado <code>pip</code>, deber\u00e1s instalarlo</p> <pre><code>sudo pacman -S  python-pip\n</code></pre> <p>Ahora vamos a instalar docker-compose</p> <pre><code>sudo pip3 install docker-compose\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#version","title":"Versi\u00f3n","text":"<p>Vamos a verificar la versi\u00f3n de docker-compose</p> <pre><code>docker-compose -v\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#levantar-un-docker-con-docker-compose","title":"Levantar un docker con docker-compose","text":"<p>Ahora cuando tenga un archivo\u00a0docker-compose.yml, lo levantar\u00e9 con:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalando-portainer","title":"Instalando Portainer","text":"<p>Portainer gestiona los contenedores de un modo gr\u00e1fico:</p> <pre><code>portainer:\n  image: portainer/portainer-ce:latest\n  container_name: portainer\n  restart: unless-stopped\n  security_opt:\n    - no-new-privileges:true\n  volumes:\n    - /etc/localtime:/etc/localtime:ro\n    - /var/run/docker.sock:/var/run/docker.sock:ro\n    - ./portainer-data:/data\n  ports:\n    - 9000:9000\n</code></pre> <p>Publicado por Angel el 07/12/2022</p>"},{"location":"03.-Conceptos%20Clave/","title":"Conceptos Clave","text":"<p>01.-Im\u00e1genes</p> <p>02.-Contenedores</p> <p>03.-Vol\u00famenes</p> <p>04.-Capas</p> <p>05.-Redes</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/","title":"02.-Contenedores","text":"<p>En pocas palabras, un contenedor es un proceso de espacio aislado en su m\u00e1quina que est\u00e1 al margen de todos los dem\u00e1s procesos en la m\u00e1quina host. Ese aislamiento aprovecha los\u00a0espacios de nombres del kernel y cgroups, caracter\u00edsticas que han estado en Linux durante mucho tiempo. Docker ha trabajado para que estas capacidades sean accesibles y f\u00e1ciles de usar. Para resumir, un contenedor:</p> <ul> <li>Un contenedor es una imagen instanciada (en ejecuci\u00f3n). Se puede crear, iniciar, detener, mover o eliminar un contenedor mediante DockerAPI o CLI.</li> <li>No albergan un sistema operativo sino que a\u00edslan el espacio de usuario.</li> <li>Son muy ligeros porque corren como un proceso sobre el SO del host.</li> <li>Puede ejecutarse en m\u00e1quinas locales, m\u00e1quinas virtuales o implementarse en la nube.</li> <li>Escalan en funci\u00f3n de la demanda, mientras que las M\u00e1quinas Virtuales (MV) tienen que ser aprovisionadas de recursos previamente.</li> <li>Est\u00e1 aislado de otros contenedores y ejecuta su propio software, binarios y configuraciones.</li> </ul> <p>Una imagen de Docker es un archivo compuesto por m\u00faltiples capas que se utiliza para ejecutar c\u00f3digo en un contenedor de Docker. Estas im\u00e1genes son las plantillas base desde la que partimos ya sea para crear una nueva imagen o crear nuevos contenedores para ejecutar las aplicaciones.</p>"},{"location":"03.-Conceptos%20Clave/03.-Vol%C3%BAmenes/","title":"03.-Vol\u00famenes","text":"<p>En Docker, un volumen es un mecanismo para persistir los datos que se generan dentro de un contenedor de Docker, de manera que puedan ser compartidos y reutilizados por otros contenedores.</p> <p>Un volumen de Docker es un \u00e1rea de almacenamiento de datos que se encuentra fuera del sistema de archivos del contenedor y que se mantiene separada del ciclo de vida del contenedor. Esto significa que los datos almacenados en un volumen persistir\u00e1n incluso despu\u00e9s de que se elimine el contenedor.</p> <p>Los vol\u00famenes de Docker se pueden utilizar para diferentes fines, como por ejemplo:</p> <ul> <li>Compartir datos entre varios contenedores: Los vol\u00famenes permiten compartir datos entre varios contenedores de Docker, lo que facilita el intercambio de informaci\u00f3n entre diferentes aplicaciones y servicios.</li> <li>Almacenar datos persistentes: Los vol\u00famenes se pueden utilizar para almacenar datos que deben persistir m\u00e1s all\u00e1 del ciclo de vida de un contenedor, como por ejemplo datos de una base de datos.</li> <li>Hacer copias de seguridad de datos: Los vol\u00famenes permiten hacer copias de seguridad de los datos almacenados en un contenedor, lo que ayuda a proteger la informaci\u00f3n importante en caso de fallos en el sistema o errores humanos.</li> </ul>"},{"location":"03.-Conceptos%20Clave/04.-Capas/","title":"04.-Capas","text":"<p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas:</p> <ul> <li> <p>Para crear una imagen, generalmente se crea el archivo de texto <code>dockerfile</code> formado por diferentes instrucciones. Cada l\u00ednea representa una instrucci\u00f3n, y cada vez que se ejecuta el dockerfile se ejecutan dichas instrucciones de arriba a abajo.</p> </li> <li> <p>Estos <code>dockerfile</code>-s se almacenan como texto y se pueden compartir con facilidad, as\u00ed como almacenarse en sistemas de control de versiones.</p> </li> <li> <p>Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior.</p> </li> <li> <p>La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa.</p> </li> <li> <p>Cada imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados.</p> </li> <li> <p>Al final del <code>dockerfile</code>, la \u00faltima instrucci\u00f3n define el comando que se ejecutar\u00e1 cuando arranquemos el contenedor.</p> </li> <li> <p>Al ejecutar un comando a partir de la imagen creada, se ejecuta el comando especificado y se convierte en el proceso con PID 1 dentro del \u00e1rbol virtual de procesos.</p> </li> </ul> <p>El contenedor seguir\u00e1 en marcha mientras el proceso creado siga en ejecuci\u00f3n.</p>"},{"location":"03.-Conceptos%20Clave/05.-Redes/","title":"05.-Redes","text":"<p>En Docker, las redes son una forma de conectar contenedores y permitir que se comuniquen entre s\u00ed y con otros servicios en la red. Las redes de Docker se utilizan para facilitar la comunicaci\u00f3n entre contenedores y para aislar los contenedores de otras redes. Docker proporciona varios tipos de redes, que se utilizan para diferentes prop\u00f3sitos:</p> <ul> <li> <p>Bridge network (red puente): Es la red predeterminada en Docker. Cada contenedor se conecta a una red puente virtual, que se encuentra en el host. Los contenedores en la misma red puente pueden comunicarse entre s\u00ed mediante sus nombres de host.</p> </li> <li> <p>Host network (red de host): En esta red, los contenedores se conectan directamente a la red del host, en lugar de a una red virtual. Esto permite que los contenedores tengan acceso directo a los recursos de red del host, pero tambi\u00e9n puede presentar problemas de seguridad.</p> </li> <li> <p>Overlay network (red de superposici\u00f3n): Esta red se utiliza para conectar contenedores que se ejecutan en diferentes hosts. Los contenedores en la misma red de superposici\u00f3n pueden comunicarse entre s\u00ed como si estuvieran en la misma red local.</p> </li> <li> <p>Macvlan network (red de Macvlan): Esta red se utiliza para conectar contenedores directamente a una interfaz de red f\u00edsica del host. Esto permite que los contenedores tengan direcciones IP \u00fanicas y se comuniquen directamente con otros dispositivos en la red.</p> </li> </ul> <p>Adem\u00e1s de estos tipos de redes, Docker tambi\u00e9n permite crear redes personalizadas para satisfacer las necesidades espec\u00edficas de una aplicaci\u00f3n o servicio.</p>"},{"location":"03.-Conceptos%20Clave/01.-Im%C3%A1genes/01.-Im%C3%A1genes/","title":"01.-Im\u00e1genes","text":"<p>Una imagen de Docker es un paquete de software que contiene todo lo necesario para ejecutar una aplicaci\u00f3n, incluyendo el c\u00f3digo, las dependencias, el sistema operativo, las bibliotecas y las configuraciones.  Las im\u00e1genes de Docker se utilizan como plantillas para crear contenedores de Docker, que son instancias en tiempo de ejecuci\u00f3n de una imagen. Las im\u00e1genes se crean a partir de un archivo de configuraci\u00f3n llamado <code>dockerfile</code>, que especifica los componentes y configuraciones necesarios para la aplicaci\u00f3n. Una vez que se ha creado una imagen de Docker, se puede almacenar en un registro de im\u00e1genes de Docker, como Docker Hub o un registro privado, para que otros usuarios puedan descargarla y utilizarla en la creaci\u00f3n de contenedores. Las im\u00e1genes de Docker son portables y se pueden ejecutar en cualquier sistema que admita la plataforma Docker. Adem\u00e1s, como las im\u00e1genes est\u00e1n aisladas del sistema operativo del host, se pueden ejecutar varias instancias de la misma imagen en diferentes contenedores sin interferir entre s\u00ed.</p>"},{"location":"03.-Conceptos%20Clave/01.-Im%C3%A1genes/02.-Docker%20Hub/","title":"02.-Docker Hub","text":"<p>Docker Hub es el mayor repositorio del mundo de im\u00e1genes de contenedores con una gran variedad de fuentes de contenido, incluidos desarrolladores, proyectos de c\u00f3digo abierto y proveedores de software independientes (ISV Independent Software Vendor) que construyen y distribuyen su c\u00f3digo en contenedores. Los usuarios tienen acceso a repositorios p\u00fablicos gratuitos para almacenar y compartir im\u00e1genes o pueden elegir un plan de suscripci\u00f3n para repositorios privados.</p>"},{"location":"docker/Docker%20Compose/","title":"Docker Compose","text":"<p>Docker Compose es una herramienta que se utiliza para definir y ejecutar aplicaciones Docker de m\u00faltiples contenedores. Con Docker Compose, se puede definir una aplicaci\u00f3n en un archivo YAML y luego ejecutarla con un solo comando. Docker Compose tambi\u00e9n permite la creaci\u00f3n de redes personalizadas y vol\u00famenes de datos para los contenedores.</p> <p>Docker Compose es \u00fatil para simplificar la gesti\u00f3n de aplicaciones Docker complejas. Por ejemplo, si una aplicaci\u00f3n consta de varios contenedores que deben comunicarse entre s\u00ed, Docker Compose puede definir f\u00e1cilmente las relaciones entre los contenedores y las redes que los conectan. Tambi\u00e9n puede definir vol\u00famenes de datos para los contenedores, lo que permite el almacenamiento persistente de datos.</p> <p>Presentamos a continuaci\u00f3n un ejemplo de un archivo YAML de Docker Compose para una aplicaci\u00f3n Django:</p> <pre><code>version: '3'\n\nservices:\n    db:\n        image: postgres\n    environment:\n        POSTGRES_DB: django_db\n        POSTGRES_USER: django_user\n        POSTGRES_PASSWORD: django_password\n\n    web:\n        build: .\n            command: python manage.py runserver 0.0.0.0:8000\n        volumes:\n        -  .:/code\n\nports:\n    - \"8000:8000\"\n\ndepends_on:\n    - db\n</code></pre> <p>En este ejemplo, se definen dos servicios: <code>db</code> y <code>web</code>. El servicio <code>db</code> utiliza la imagen de <code>postgres</code> y se definen las variables de entorno para la base de datos. El servicio <code>web</code> se construye a partir del directorio actual y se ejecuta el comando para iniciar el servidor Django. Tambi\u00e9n se define un volumen para el c\u00f3digo fuente y se expone en el puerto 8000. El servicio <code>web</code> depende del servicio <code>db</code>.</p>"},{"location":"docker/Docker%20en%20python%20y%20django/","title":"Docker en python y django","text":"<p>Ok, suficiente teor\u00eda. Empecemos a usar Docker y Django juntos. El primer paso es registrarse en Docker Hub para obtener una cuenta gratuita y luego instalar la aplicaci\u00f3n de escritorio Docker en nuestra m\u00e1quina local:</p> <ul> <li>Docker para Linux</li> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker</code></li> <li>Docker para Mac</li> <li>Docker para Windows</li> </ul> <p>Esta descarga puede tomarse alg\u00fan tiempo ya que es un archivo grande.</p> <p>Una vez que Docker se haya terminado de instalar, podemos confirmar que se est\u00e1 ejecutando la versi\u00f3n correcta escribiendo <code>docker --version</code> en la l\u00ednea de comandos. Debe ser al menos la versi\u00f3n 18.</p> <pre><code>$ docker --version\nDocker versi\u00f3n 19.03.5-ce, build 633a0ea838\n</code></pre> <p>Docker se utiliza a menudo con una herramienta adicional, Docker Compose, para ayudar a automatizar los comandos. Docker Compose se incluye con las descargas de Mac y Windows, pero si se est\u00e1 en Linux, tendr\u00e1 que a\u00f1adirse manualmente. Puede hacerse ejecutando el comando <code>sudo pip install docker-compose</code> despu\u00e9s de que la instalaci\u00f3n de Docker haya finalizado.</p> <ul> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker-compose</code>. (Si surgen problemas con alg\u00fan fichero ya instalado en el sistema, borrar todos aquellos ficheros que est\u00e9n involucrados y proceder con la instalaci\u00f3n como se indica)</li> </ul>"},{"location":"docker/Docker%20en%20python%20y%20django/#docker-hola-mundo","title":"Docker, Hola Mundo","text":"<p>Docker se env\u00eda con su propia imagen de \"Hello, World\" que es un primer paso \u00fatil para comprobar la instalaci\u00f3n. Introducir en la l\u00ednea de comandos el comando <code>docker run hello-world</code>. Esto descargar\u00e1 una imagen Docker oficial y luego se ejecutar\u00e1 dentro de un contenedor. Se discutir\u00e1 sobre las im\u00e1genes y los contenedores en breve.</p> <pre><code>$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete\nDigest: sha256:b8ba256769a0ac28dd126d584e0a2011cd2877f3f76e093a7ae560f2a5301c00\nStatus: Downloaded newer image for hello-world:latest\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n(amd64)\n 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.\nTo try something more ambitious, you can run an Ubuntu container with:\n$ docker run -it ubuntu bash\nShare images, automate workflows, and more with a free Docker ID:\nhttps://hub.docker.com/\nFor more examples and ideas, visit:\nhttps://docs.docker.com/get-started/\n</code></pre> <p>El comando <code>docker info</code> nos permite inspeccionar Docker. Contendr\u00e1 una gran cantidad de informaci\u00f3n, pero si nos centramos en las l\u00edneas superiores tenemos 1 contenedor que se detenido y 1 imagen.</p> <pre><code>$ docker info\nClient:\n Debug Mode: false\n\nServer:\n Containers: 1\n  Running: 0\n  Paused: 0\n  Stopped: 1\n Images: 1\n...\n</code></pre>"},{"location":"docker/Docker%20en%20python%20y%20django/#django-hola-mundo","title":"Django, Hola mundo","text":"<p>Ahora vamos a crear un proyecto de Django \"Hello, World\" que se ejecuta localmente en nuestro ordenador y luego lo moveremos por completo dentro de Docker para que se pueda ver c\u00f3mo encajan todas las piezas.</p> <p>El primer paso es elegir una ubicaci\u00f3n para nuestro c\u00f3digo. Esto puede ser en cualquier parte del ordenador pero si est\u00e1s en Linux, una ubicaci\u00f3n f\u00e1cil de encontrar es el Escritorio . Desde la l\u00ednea de comandos navegamos hasta el <code>Escritorio</code> y creamos un directorio <code>code</code> para todos los ejemplos:</p> <pre><code>$ cd ~/Desktop\n$ mkdir code &amp;&amp; cd code\n</code></pre> <p>Luego creeamos un directorio <code>hello</code> donde  instalaremos Django usando Pipenv que crea un archivo Pipfile y un archivo Pipfile.lock.  Activamos el entorno virtual con el comando <code>shell</code>.</p> <pre><code>$ mkdir hello &amp;&amp; cd hello\npipenv install django==2.2.7\n$ pipenv shell\n(hello) $\n</code></pre> <p>Si se necesita ayuda para instalar Pipenv o Python 3, se pueden encontrar m\u00e1s detalles aqu\u00ed. Ahora podemos usar el comando <code>startproject</code> para crear un nuevo proyecto de Django llamado <code>hello_project</code>. A\u00f1adir un punto, <code>.</code>, al final del comando es un paso opcional pero muchos desarrolladores de Django lo hacen. Sin el punto, Django a\u00f1ade un directorio adicional al proyecto; con el <code>.</code>, esto no ocurre. Por \u00faltimo, utilice el comando <code>migrate</code> para inicializar la base de datos e iniciar la web local con el comando <code>runserver</code>.</p> <pre><code>(hola) $ django-admin startproject hello_project .\n(hola) $ python manage.py migrate\n(hola) $ python manage.py runserver\n</code></pre> <p>Suponiendo que todo ha funcionado correctamente, ahora deber\u00edamos poder navegar para ver el la p\u00e1gica de bienvenida de Django en http://127.0.0.1:8000/ en su navegador web.</p> <p></p>"},{"location":"docker/Docker%20en%20python%20y%20django/#pages-app","title":"Pages App","text":"<p>Ahora haremos una p\u00e1gina de inicio simple creando una <code>pages</code> app espec\u00edfica  para ello. Parar el servidor local escribiendo Control+c y luego usar el comando <code>startapp</code> a\u00f1adiendo el nombre de la <code>pages</code> que se desee.</p> <pre><code>(hola) $ python manage.py startapp pages\n</code></pre> <p>Django instala autom\u00e1ticamente un nuevo directorio de p\u00e1ginas y varios archivos para nosotros. Pero incluso aunque la app ha sido creada, nuestro <code>hello_project</code> no la reconocer\u00e1 hasta que la a\u00f1adamos a la configuraci\u00f3n de <code>INSTALLED_APPS</code> de archivo <code>hello_project/settings.py</code>.</p> <p>Django carga las apps de arriba a abajo, por lo que, en general, es una buena pr\u00e1ctica a\u00f1adir las nuevas aplicaciones debajo de las aplicaciones incorporadas en las que pueden confiar, tales como <code>admin</code>, <code>auth</code>, y todas las aplicaciones restantes.</p> <p>T\u00e9ngase en cuenta que si bien es posible simplemente escribir el nombre de la app, <code>pages</code>,  es mejor escribir la <code>pages.apps.apps.PagesConfig</code> completa lo que abre m\u00e1s posibilidades en la configuraci\u00f3n de las apps.</p> <pre><code># hello_project/settings.py\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'pages.apps.apps.PagesConfig', # nuevo\n]\n</code></pre> <p>Ahora podemos establecer la ruta URL para la app <code>pages</code>. Ya que queremos que nuestro mensaje aparezca en la p\u00e1gina de inicio usaremos la cadena vac\u00eda <code>''</code> . No olvidar a\u00f1adir la importaci\u00f3n de <code>include</code> en la segunda l\u00ednea tambi\u00e9n.</p> <pre><code># hello_project/urls.py\nfrom django.contrib import admin\nfrom django.urls import path, include # nuevo\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('pages.urls')), # nuevo\n]\n</code></pre> <p>En lugar de crear una plantilla en este punto, podemos simplemente codificar un mensaje en nuestra capa de la vista <code>pages/views.py</code> que producir\u00e1 la cadena <code>Hello, World!</code>.</p> <pre><code># pages/views.py\nfrom django.http import HttpResponse\n\ndef home_page_view(request):\n    return HttpResponse('Hello, World!')\n</code></pre> <p>\u00bfQu\u00e9 es lo siguiente? El \u00faltimo paso es crear un archivo <code>urls.py</code> dentro de la app <code>pages</code>y enlazarlo to <code>home_page_view</code>. Si se encuentra en un ordenador Mac o Linux, el comando <code>touch</code> se puede usar desde la l\u00ednea de comandos para crear nuevos archivos. En Windows habr\u00e1 que crear el nuevo archivo con un editor de texto.</p> <pre><code>(hola) $ touch pages/urls.py\n</code></pre> <p>En el editor de texto importar <code>path</code> en la primera l\u00ednea, a\u00f1adir la <code>home_page_view</code>, y colocar su ruta para otra vez ser la cadena vac\u00eda ''. N\u00f3tese que tambi\u00e9n provee un nombre opcional, <code>home</code>, para esta ruta lo cual es una buena pr\u00e1ctica.</p> <pre><code># pages/urls.py\nfrom django.urls import path\n\nfrom .views import home_page_view\n\n\nurlpatterns = [\npath('', home_page_view, name='home')\n]\n\n</code></pre> <p>El flujo completo de nuestra p\u00e1gina web Django es el siguiente:</p> <ul> <li>cuando un usuario va a su homepage ser\u00e1 primero encaminado a <code>hello_project/urls.py</code></li> <li>luego a <code>pages/urls.py</code></li> <li>y finalmente dirigido a la <code>home_page_view</code> que devuelve la cadena <code>Hello, World!</code></li> </ul> <p>El trabajo para una p\u00e1gina de inicio b\u00e1sica ha terminado. Iniciemos de nuevo el servidor local.</p> <pre><code>(hola) $ python manage.py runserver\n</code></pre> <p>Si se actualiza el navegador web en http://127.0.0.1:8000/, ahora saldr\u00e1 nuestro deseado mensaje.</p> <p></p> <p>Ahora es el momento de cambiar a Docker. Detengamos de nuevo el servidor local con Ctrl+C y salgamos de nuestro entorno virtual, que ya no necesitamos, escribiendo <code>exit</code>.</p> <pre><code>(hello) $ exit\n$\n</code></pre> <p>\u00bfC\u00f3mo sabemos que nuestro entorno virtual ya no est\u00e1 activo? No habr\u00e1 un par\u00e9ntesis alrededor del nombre de directorio en el prompt. Cualquier comando Django normal que se intente ejecutar en este punto fallar\u00e1. Por ejemplo, probar <code>python manage.py runserver</code> para ver lo que ocurre.</p> <pre><code>$ python manage.py runserver\nFile \"./manage.py\", line 14\n  ) from exc\n       ^\nSyntaxError: invalid syntax\n</code></pre> <p>Esto significa que estamos totalmente fuera del entorno virtual y preparados para Docker.</p>"},{"location":"docker/Docker%20en%20python%20y%20django/#imagenes-contenedores-y-el-docker-host","title":"Im\u00e1genes, Contenedores y el \"Docker Host\"","text":"<p>Una imagen Docker es una instant\u00e1nea en el tiempo de lo que contiene un proyecto. Est\u00e1 representado por un <code>Dockerfile</code> y es literalmente una lista de instrucciones que deben ser construidas/ejecutadas. Un contenedor Docker es una instancia en ejecuci\u00f3n de una imagen. Para continuar con la analog\u00eda de nuestro apartamento de antes, la imagen es el plano o conjunto de planos del apartamento; el contenedor es el edificio real totalmente construido.</p> <p>El tercer concepto central es el Docker host, que es el sistema operativo subyacente. Es posible tener varios contenedores ejecut\u00e1ndose dentro de un mismo Docker host. Cuando nos referimos a c\u00f3digo o procesos que se ejecutan en el Docker, significa que se ejecutan en el Docker host.</p> <p>Creemos nuestro primer <code>Dockerfile</code> para ver toda esta teor\u00eda en acci\u00f3n.</p> <pre><code>$ touch Dockerfile\n</code></pre> <p>Dentro del <code>Dockerfile</code> agregamos el siguiente c\u00f3digo que recorreremos l\u00ednea por l\u00ednea m\u00e1s abajo.</p> <pre><code># Pull base image\nFROM python:3.8\n\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n\n# Set work directory\nWORKDIR /code\n\n\n# Install dependencies\nCOPY Pipfile Pipfile.lock /code/\nRUN pip install pipenv &amp;&amp; pipenv install --system\n\n\n# Copy project\nCOPY . /code/\n</code></pre> <p>Los <code>Dockerfiles</code> se leen de arriba hacia abajo cuando se crea una imagen. La primera instrucci\u00f3n debe ser el comando <code>FROM</code> que nos permite importar una imagen base que usar, en nuestro caso Python 3.8.</p> <p>Luego usamos el comando <code>ENV</code> para establecer dos variables de entorno:</p> <ul> <li><code>PYTHONUNBUFFERED</code> asegura que la salida de nuestra consola se vea familiar y que no est\u00e9 almacenada en un b\u00fafer de Docker, lo cual no queremos</li> <li><code>PYTHONDONTWRITEBYTECODE</code> significa que Python no intentar\u00e1 escribir archivos <code>.pyc</code>, que tampoco deseamos</li> </ul> <p>A continuaci\u00f3n usamos <code>WORKDIR</code> para establecer una ruta de directorio de trabajo por defecto dentro de nuestra imagen llamada <code>code</code>que es donde guardaremos nuestro c\u00f3digo. Si no lo hicimos, entonces cada vez que queramos ejecutar comandos dentro de nuestro contenedor tendr\u00edamos que escribir una ruta muy larga. En su lugar, Docker asumir\u00e1 que queremos ejecutar todos los comandos desde este directorio.</p> <p>Para nuestras dependencias estamos usando <code>pipenv</code>, as\u00ed que copiamos tanto el archivo <code>Pipfile</code> como el archivo <code>Pipfile.lock</code> en el directorio <code>/code/</code> en Docker.</p> <p>Vale la pena tomarse un momento para explicar por qu\u00e9 <code>pipenv</code> crea un <code>Pipfile.lock</code>. El concepto de bloqueo de archivos no es exclusivo de Python o Pipenv; de hecho ya est\u00e1 presente en los gestores de paquetes de los lenguajes de programaci\u00f3n m\u00e1s modernos: <code>Gemfile.lock</code> en Ruby, <code>yarn.lock</code> en JavaScript, <code>composer.lock</code> en PHP, etc. Pipenv fue el primer proyecto popular en incorporarlos en la paqueter\u00eda de Python.</p> <p>La ventaja de un archivo de bloqueo es que esto conduce a una construcci\u00f3n determinista: no importa cu\u00e1ntas veces se instalen los paquetes de software, se obtendr\u00e1 el mismo resultado. Sin un fichero lock que \"bloquee\" las dependencias y su orden, no se cumplir\u00eda necesariamente. Lo que significa que dos miembros del equipo que instalan la misma lista de software pueden tener instalaciones de construcci\u00f3n ligeramente diferentes.</p> <p>Cuando estamos trabajando con Docker donde hay c\u00f3digo tanto local en nuestro ordenador como tambi\u00e9n dentro de Docker, el potencial de conflictos de <code>Pipfile.lock</code> surge cuando se actualizan paquetes de software.</p> <p>Siguiendo adelante usamos el comando <code>RUN</code> para instalar primero <code>pipenv</code> y luego <code>pipenv install</code> para instalar los paquetes de software listados en nuestro Pipfile.lock, actualmente s\u00f3lo Django. Es un es importante a\u00f1adir tambi\u00e9n el indicador <code>--system</code>, ya que por defecto Pipenv buscar\u00e1 el par\u00e1metro en el que instalar cualquier paquete, pero como estamos dentro de Docker ahora, t\u00e9cnicamente no hay ning\u00fan entorno virtual. En cierto modo, el contenedor Docker es nuestro entorno virtual y mucho m\u00e1s. As\u00ed que debemos usar la bandera <code>--system</code> para asegurarnos de que nuestros paquestes est\u00e1n disponibles en todo el Docker para nosotros.</p> <p>Como paso final copiamos el resto de nuestro c\u00f3digo local en el directorio <code>/code/</code> dentro de Docker. \u00bfPor qu\u00e9 copiamos el c\u00f3digo local dos veces, primero el Pipfile y Pipfile.lock y luego el resto? La raz\u00f3n es que las im\u00e1genes se crean en base a instrucciones de arriba hacia abajo por lo que queremos que las cosas que cambian a menudo -como nuestro c\u00f3digo local- sea el \u00faltimo. De esta manera s\u00f3lo tenemos que regenerar esa parte de la imagen ante un cambio y no se reinstala todo cada vez que lo haya. Como el software de los paquetes contenidos en nuestros <code>Pipfile</code> y <code>Pipfile.lock</code> cambian con poca frecuencia, implica que no tiene sentido copiarlos e instalarlos antes.</p> <p>Nuestras instrucciones de imagen ya est\u00e1n hechas, as\u00ed que vamos a construir la imagen usando el comando <code>docker build .</code>. El punto <code>.</code> indica que el directorio actual es donde se debe ejecutar el comando comando. Se genera una gran cantidad de texto en pantalla; s\u00f3lo se incluye las dos primeras l\u00edneas y las tres \u00faltimas.</p> <pre><code>$ docker build .\nSending build context to Docker daemon 154.1kB\nStep 1/7 : FROM python:3.8\n...\nStep 7/7 : COPY . /code/\n---&gt; a48b2acb1fcc\nSuccessfully built a48b2acb1fcc\n</code></pre> <p>Pasando a lo siguiente, ahora necesitamos crear un archivo <code>docker-composition.yml</code> para controlar c\u00f3mo ejecutar el comando que ser\u00e1 construido en base a nuestra imagen de <code>Dockerfile</code>.</p> <pre><code>$ touch docker-compose.yml\n</code></pre> <p>Contendr\u00e1 el siguiente c\u00f3digo</p> <pre><code>version: '3.7'\n\nservices:\n  web:\n    build: .\n    command: python /code/manage.py runserver 0.0.0.0:8000\n    volumes:\n      - .:/code\n    ports:\n      - 8000:8000\n</code></pre> <p>En la l\u00ednea superior se especifica la versi\u00f3n m\u00e1s reciente de Docker Compose que es actualmente 3.7  (no confundir con la versi\u00f3n de Python que puede ser bien parecida) A continuaci\u00f3n, especificamos qu\u00e9 <code>services</code> (o contenedores) queremos que funcionen en nuestro \"Docker host\". Es posible tener varios <code>services</code> funcionando, pero por ahora s\u00f3lo tenemos uno para el servidor <code>web</code>. Especificaremos c\u00f3mo construir el contenedor diciendo, \"Busca el directorio en curso <code>.</code> el <code>Dockerfile</code>\" . Luego, dentro del contenedor, ejecute el comando para arrancar el servidor local. El montaje de los vol\u00famenes sincroniza autom\u00e1ticamente el sistema de archivos Docker con nuestro sistema de archivos local. \u00a1Esto significa que no tenemos que reconstruir la imagen cada vez que cambiamos un solo fichero!.</p> <p>Por \u00faltimo especificamos los puertos (<code>ports</code>) a exponer dentro de Docker que solo ser\u00e1 el 8000, que es el puerto Django por defecto.</p> <p>Si es la primera vez que utiliza Docker, es muy probable que se est\u00e9 muy confundido en este momento. No hay motivo de preocupaci\u00f3n. Crearemos m\u00faltiples im\u00e1genes y contenedores Docker y, con la pr\u00e1ctica, el flujo comenzar\u00e1 a tener m\u00e1s sentido. Se ver\u00e1 como se usan archivos <code>Dockerfile</code> y <code>docker-composition.yml</code> muy similares en cada uno de los proyectos.</p> <p>El paso final es ejecutar nuestro contenedor Docker usando el comando <code>docker-compose up</code>. Este comando resultar\u00e1 en otro largo flujo de texto de salida en la l\u00ednea de comandos.</p> <pre><code>$ docker-compose up\nCreating network \"hello_default\" with the default driver\nBuilding web\nStep 1/7 : FROM python:3.8\n...\nCreating hello_web_1 ... done\nAttaching to hello_web_1\nweb_1 | Performing system checks...\nweb_1 |\nweb_1 | System check identified no issues (0 silenced).\nweb_1 | September 20, 2019 - 17:21:57\nweb_1 | Django version 2.2.5, using settings 'hello_project.settings'\nweb_1 | Starting development server at http://0.0.0.0:8000/\nweb_1 | Quit the server with CONTROL-C.\n</code></pre> <p>Para confirmar que realmente funcion\u00f3, volveremos a poner http://127.0.0.1:8000/ en el navegador web. Actualizaremos la p\u00e1gina y aparecer\u00e1 la p\u00e1gina \"Hello, World\".</p> <p>Django se est\u00e1 ejecutando ahora puramente dentro de un contenedor Docker. No estamos trabajando dentro de un entorno virtual local. No ejecutamos el comando <code>runserver</code>. Todo nuestro c\u00f3digo y nuestro servidor Django se est\u00e1 ejecutando desde dentro de un Docker aut\u00f3nomo. !Todo un \u00e9xito!</p> <p>Detendremos el contenedor con Ctrl+C y adem\u00e1s escribiremos <code>docker-compose down</code>. Los contenedores absorben una gran cantidad de memoria, as\u00ed que es una buena idea detenerlos de esta manera cuando hayamos terminado de usarlos.</p> <p>Los contenedores se han concebido para ser est\u00e1ticos (no pueden cambiar), por lo que utilizamos <code>volumes</code> para copiar nuestro c\u00f3digo en sitios donde si que pueda guardarse.</p> <pre><code>$ docker-compose down\nRemoving hello_web_1 ... done\nRemoving network hello_default\n</code></pre>"},{"location":"docker/Instalaci%C3%B3n%20de%20zsh%20en%20ubuntu/","title":"Instalaci\u00f3n de zsh en ubuntu","text":"<p>Para instalar Zsh en Ubuntu, sigue los siguientes pasos:</p> <ul> <li>Abre una terminal en tu sistema Ubuntu.</li> <li>Actualiza la lista de paquetes de Ubuntu con el siguiente comando:</li> </ul> <pre><code>$ sudo apt update\n</code></pre> <ul> <li>Ahora, instala Zsh con el siguiente comando:</li> </ul> <pre><code> sudo apt install zsh\n</code></pre> <ul> <li>Despu\u00e9s de la instalaci\u00f3n, verifica que la versi\u00f3n de Zsh instalada es la \u00faltima disponible con:</li> </ul> <pre><code>zsh --version\n</code></pre> <ul> <li>Para configurar Zsh como tu shell predeterminada, utiliza el siguiente comando:</li> </ul> <pre><code>sudo chsh -s $(which zsh)\n</code></pre> <ul> <li>Cierra la sesi\u00f3n actual (saliendo del modo gr\u00e1fico) e inicia sesi\u00f3n nuevamente para que los cambios surtan efecto.</li> <li>Instalar Oh-my-zsh seg\u00fan las instrucciones de su p\u00e1gina web es decir, ejecutar el comando:</li> </ul> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre> <ul> <li>Abre tu terminal y ejecuta el siguiente comando para abrir el archivo de configuraci\u00f3n de Oh My Zsh:</li> </ul> <pre><code>vi ~/.zshrc\n</code></pre> <ul> <li>Busca la l\u00ednea que comienza con <code>ZSH_THEME</code> y cambia el valor despu\u00e9s del signo igual por el nombre del te   ma que quieres utilizar. Por ejemplo, si quieres utilizar el tema agnoster, la l\u00ednea deber\u00eda verse as\u00ed:</li> </ul> <pre><code>ZSH_THEME=\"agnoster\"\n</code></pre> <ul> <li> <p>Guarda los cambios y cierra el archivo de configuraci\u00f3n.</p> </li> <li> <p>Sal de tu sesi\u00f3n de terminal actual y vuelve a iniciarla para que los cambios tengan efecto.</p> </li> </ul> <p>instalacion_del_plugin_en_ZSH</p>"},{"location":"docker/gestion_imagenes/","title":"Gestion imagenes","text":"<p>Para crear una imagen de Docker, se sigue el siguiente proceso b\u00e1sico:</p> <ol> <li>Crear un archivo Dockerfile: El archivo Dockerfile es un archivo de texto que contiene las instrucciones para construir una imagen de Docker. En el archivo Dockerfile, se especifican el sistema operativo base, las dependencias, las bibliotecas y las configuraciones necesarias para la aplicaci\u00f3n.</li> <li>Escribir las instrucciones de Dockerfile: En el archivo Dockerfile, se incluyen las instrucciones para construir la imagen. Por ejemplo, se pueden utilizar las instrucciones <code>FROM</code> para especificar el sistema operativo base, <code>RUN</code> para instalar dependencias y bibliotecas, y <code>COPY</code> para copiar archivos de la aplicaci\u00f3n.</li> <li>Construir la imagen: Una vez que se ha creado el archivo Dockerfile, se puede construir la imagen utilizando el comando <code>docker build</code>. Este comando lee las instrucciones en el archivo Dockerfile y construye la imagen de Docker.</li> <li>Etiquetar la imagen: Despu\u00e9s de construir la imagen, se puede etiquetar con un nombre y una versi\u00f3n utilizando el comando <code>docker tag</code>.</li> <li>Subir la imagen a un registro de im\u00e1genes: Por \u00faltimo, se puede subir la imagen a un registro de im\u00e1genes de Docker, como 02.-Docker Hub, para que otras personas puedan descargarla y utilizarla para crear contenedores.</li> </ol> <p>Aqu\u00ed un ejemplo de archivo Dockerfile para construir una imagen de una aplicaci\u00f3n de Python:</p> <pre><code># Imagen base\nFROM python:3.9-alpine\n\n# Variables de entorno para configurar el entorno de la aplicaci\u00f3n\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n# Directorio de trabajo\nWORKDIR /app\n\n# Copiar los archivos de la aplicaci\u00f3n\nCOPY requirements.txt .\nCOPY . .\n\n# Instalar las dependencias\nRUN pip install --upgrade pip &amp;&amp; \\\n    pip install -r requirements.txt\n\n# Exponer el puerto 8000\nEXPOSE 8000\n\n# Comando para iniciar la aplicaci\u00f3n\nCMD [\"python\", \"app.py\"]\n</code></pre> <p>Este archivo Dockerfile se basa en la imagen de Python 3.9 Alpine y configura el entorno de la aplicaci\u00f3n. A continuaci\u00f3n, copia los archivos de la aplicaci\u00f3n y los requisitos en el directorio de trabajo y los instala. Finalmente, expone el puerto 8000 y utiliza el comando <code>python app.py</code> para iniciar la aplicaci\u00f3n.</p> <p>Para construir la imagen, se debe ejecutar el siguiente comando en la terminal, asegur\u00e1ndote de estar en la misma ubicaci\u00f3n que el archivo Dockerfile:</p> <pre><code>docker build -t nombre-de-la-imagen:version .\n</code></pre> <p>Despu\u00e9s de construir y etiquetar la imagen, se puede subir a un registro de im\u00e1genes de Docker utilizando el comando <code>docker push</code>. Por ejemplo:</p> <pre><code>docker push nombre-de-la-imagen:version\n</code></pre> <p>Una vez subida la imagen, se puede descargar y ejecutar en cualquier sistema que admita Docker utilizando el comando <code>docker run</code>.</p>"},{"location":"docker/instalacion_del_plugin_en_ZSH/","title":"Instalaci\u00f3n del plugin de ZSH","text":"<p>La instalaci\u00f3n del plugin de Docker en Zsh puede variar dependiendo del m\u00e9todo que se utilice para instalar Zsh en tu sistema operativo. A continuaci\u00f3n, se describe el proceso de instalaci\u00f3n en sistemas operativos basados en Linux:</p> <ol> <li>Abre una terminal y aseg\u00farate de tener instalado Zsh en tu sistema y el gestor de paquetes Oh My Zsh. </li> <li>Ahora, abre el archivo de configuraci\u00f3n de Zsh en un editor de texto. Puedes hacerlo ejecutando el siguiente comando en la terminal:</li> </ol> <p><code>vim ~/.zshrc</code></p> <ol> <li>Busca la l\u00ednea que comienza con <code>plugins=</code> y agrega <code>docker</code> al final de la lista de plugins separados por espacios. Debe quedar algo como esto:</li> </ol> <p><code>plugins=(git docker)</code></p> <ol> <li> <p>Guarda los cambios y cierra el archivo.</p> </li> <li> <p>Ahora, reinicia Zsh para que los cambios tengan efecto:</p> </li> </ol> <p><code>source ~/.zshrc</code></p> <p>Una vez completados estos pasos, el plugin de Docker deber\u00eda estar instalado y listo para usarse en Zsh. Puedes probarlo ejecutando un comando de Docker en la terminal.</p>"},{"location":"docker/instalacion_del_plugin_en_ZSH/#otros-plugins","title":"Otros plugins","text":"<p>Aparte del plugin oficial de Docker, hay varios otros plugins que puedes instalar en Zsh para trabajar con Docker. Algunos de los plugins m\u00e1s populares son:</p> <ul> <li>zsh-autosuggestions-docker: Este plugin agrega sugerencias autom\u00e1ticas para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/hlissner/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</code></p> <ul> <li>zsh-completion-docker: Este plugin agrega completado de tabulaci\u00f3n para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/docker/cli.git ~/.oh-my-zsh/custom/plugins/zsh-completion-docker</code></p> <ul> <li>zsh-syntax-highlighting-docker: Este plugin agrega resaltado de sintaxis para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting-docker</code></p> <p>Para utilizar estos plugins, debes agregarlos a la lista de plugins en el archivo de configuraci\u00f3n de Zsh (<code>~/.zshrc</code>) de la misma manera que se agreg\u00f3 el plugin de Docker. Por ejemplo:</p> <pre><code>plugins=(git docker zsh-autosuggestions zsh-completion-docker zsh-syntax-highlighting-docker)\n</code></pre> <p>Igual que antes y una vez que hayas agregado estos plugins, reinicia <code>zsh</code> para que los cambios tengan efecto. Luego, podr\u00e1s utilizar las funciones adicionales que ofrecen estos plugins para trabajar con <code>docker</code> en <code>zsh</code>.</p>"}]}