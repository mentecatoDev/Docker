{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"docker","text":"<ul> <li>01.-Introducci\u00f3n</li> <li>02.-Instalaci\u00f3n</li> <li>03.-Conceptos Clave</li> <li>04.-Manos a la obra</li> <li>05.-Gesti\u00f3n de im\u00e1genes</li> <li>06.-Vol\u00famenes</li> <li>07.-Redes</li> <li>08.-Escenarios multicontenedor </li> <li>09.-Ejercicios</li> <li> <p>10.-Cheatsheet</p> </li> <li> <p>Anexo: Docker en python y django</p> </li> </ul>"},{"location":"#documentacion-oficial-y-enlaces-de-interes","title":"Documentaci\u00f3n oficial y enlaces de inter\u00e9s","text":"<ul> <li>P\u00e1gina oficial</li> <li>Documentaci\u00f3n oficial</li> <li>Docker Hub</li> <li>Introducci\u00f3n a Docker - CPR de Zafra (Abril de 2021)</li> <li>Comandos b\u00e1sicos de Docker CLI para la gesti\u00f3n de im\u00e1genes y contenedores</li> <li>Creaci\u00f3n de im\u00e1genes personalizadas y registro en Docker Hub</li> <li>Implementaci\u00f3n de una aplicaci\u00f3n en un contenedor de Docker</li> <li>Integraci\u00f3n de Docker con herramientas de orquestaci\u00f3n como Kubernetes o Docker Compose</li> <li>Buenas pr\u00e1cticas y consideraciones de seguridad para el uso de Docker</li> </ul>"},{"location":"01.-Introducci%C3%B3n/","title":"01.-Introducci\u00f3n","text":"<p>La configuraci\u00f3n adecuada de un entorno de desarrollo local sigue siendo un gran reto a pesar de todos los otros avances de la programaci\u00f3n moderna. Simplemente hay demasiadas variables: diferentes ordenadores, sistemas operativos, versiones de lenguajes y frameworks, opciones de entornos virtuales,  y as\u00ed sucesivamente. Cuando se a\u00f1ade el reto de trabajar en equipo en un entorno en el que todos necesitan tener la misma configuraci\u00f3n, el problema se magnifica.</p> <p>En los \u00faltimos a\u00f1os ha surgido una soluci\u00f3n: Docker. Aunque s\u00f3lo tiene unos pocos a\u00f1os, Docker se ha convertido r\u00e1pidamente en la opci\u00f3n por defecto para muchos desarrolladores que trabajan en proyectos a nivel de producci\u00f3n.</p> <p>Docker es un proyecto open source que ha revolucionado la manera de desarrollar software gracias a la sencillez con la que permite gestionar contenedores. Los contenedores LXC (LinuX Containers) son un concepto relativamente antiguo y utilizado desde hace tiempo por grandes empresas como Amazon o Google, pero cuyo gesti\u00f3n era complicada. Sin embargo, Docker define APIs y herramientas de l\u00ednea de comandos que hacen casi trivial la creaci\u00f3n, distribuci\u00f3n y ejecuci\u00f3n de contenedores. De ah\u00ed que el lema de Docker sea: \u201cBuild, Ship and Run. Any application, Anywhere\u201d y se haya convertido en una herramienta fundamental tanto para desarrolladores como para administradores de sistemas.</p> <p>Con Docker finalmente es posible reproducir un entorno de producci\u00f3n de forma fiel y fiable localmente, desde la versi\u00f3n adecuada del lenguaje hasta la instalaci\u00f3n de las librer\u00edas necesarias, a la par de ejecutar servicios adicionales como una base de datos a nivel de producci\u00f3n. Esto significa que ya no es importante si se desarrolla en un equipo Linux, Mac o Windows. Todo funciona dentro del mismo Docker.</p> <p>Docker tambi\u00e9n facilita exponencialmente la colaboraci\u00f3n en equipo. Atr\u00e1s quedaron los d\u00edas de compartir archivos README largos y obsoletos para a\u00f1adir un nuevo desarrollador a un proyecto de grupo.</p> <p>En lugar de eso, con Docker s\u00f3lo se tienen que compartir dos archivos: <code>Dockerfile</code> y  <code>docker-compose.yml</code> y el desarrollador puede tener la confianza de que su entorno de desarrollo local es exactamente igual que el del resto del equipo.</p> <p>Docker no es una tecnolog\u00eda perfecta. Todav\u00eda es relativamente nueva y compleja en sus entra\u00f1as; a\u00fan est\u00e1 en desarrollo activo. Pero aspira a la promesa de una pol\u00edtica coherente y a un entorno de desarrollo compartible, que pueda ejecutarse localmente en cualquier ordenador o desplegado en cualquier servidor, lo que lo convierte en una opci\u00f3n s\u00f3lida.</p>"},{"location":"01.-Introducci%C3%B3n/#que-es-docker","title":"\u00bfQu\u00e9 es Docker?","text":"<p>Docker es una forma de aislar todo un sistema operativo a trav\u00e9s de contenedores Linux que son un tipo de virtualizaci\u00f3n.</p> <p>La virtualizaci\u00f3n tiene sus ra\u00edces en los inicios de la inform\u00e1tica cuando las computadoras grandes y caras eran la norma. \u00bfC\u00f3mo podr\u00edan varios programadores utilizar la misma m\u00e1quina?. La respuesta fue la virtualizaci\u00f3n y espec\u00edficamente las m\u00e1quinas virtuales que son copias completas de un sistema inform\u00e1tico desde el sistema operativo en adelante. </p> <p>Cuando se alquila un espacio en un proveedor de cloud computing como Amazon Web Services (AWS) normalmente no se proporciona una pieza de hardware dedicada. En lugar de eso, se comparte un servidor f\u00edsico con otros clientes. Pero como cada cliente tiene su propio sistema virtual que se ejecuta en el servidor, le parece que tiene el suyo propio.</p> <p>Esta tecnolog\u00eda es la que hace posible a\u00f1adir o eliminar servidores de un servicio de cloud de forma r\u00e1pida y sencilla. Se trata en gran medida de software entre bastidores, no de hardware real.</p> <p>\u00bfCu\u00e1l es el inconveniente de una m\u00e1quina virtual? Tama\u00f1o y velocidad. Un sistema operativo hu\u00e9sped t\u00edpico (guest) puede ocupar f\u00e1cilmente hasta 700MB de tama\u00f1o. As\u00ed que si un servidor f\u00edsico soporta tres m\u00e1quinas virtuales, eso es al menos 2,1 GB de espacio en disco ocupado junto con el resto de necesidades para otros recursos como CPU y memoria.</p> <p>Al entrar en Docker, la idea clave es que la mayor\u00eda de los ordenadores dependen del mismo sistema operativo Linux. \u00bfY si virtualizamos desde la capa de Linux hacia arriba? \u00bfNo proporcionar\u00eda eso una forma m\u00e1s r\u00e1pida y ligera de duplicar gran parte de la misma funcionalidad? La respuesta es s\u00ed. Y en los \u00faltimos a\u00f1os los contenedores Linux se han vuelto muy populares. Para la mayor\u00eda de las aplicaciones, especialmente las aplicaciones web, una m\u00e1quina virtual proporciona mucho m\u00e1s recursos de los que se necesitan y un contenedor es m\u00e1s que suficiente.</p> <p>Esto, fundamentalmente, es Docker: \u00a1una forma de implementar contenedores Linux!</p> <p>Una analog\u00eda que podemos usar es la de los edificios y los apartamentos. Las m\u00e1quinas virtuales son como viviendas: edificios independientes con su propia infraestructura, incluida la fontaner\u00eda y calefacci\u00f3n, as\u00ed como cocina, ba\u00f1os, dormitorios, etc. Los contenedores Docker son como los apartamentos: comparten una infraestructura com\u00fan como la fontaner\u00eda y la calefacci\u00f3n, pero vienen en varios tama\u00f1os que se ajustan a las necesidades exactas de un propietario.</p>"},{"location":"01.-Introducci%C3%B3n/#contenedores-vs-entornos-virtuales","title":"Contenedores vs. Entornos Virtuales","text":"<p>Como programador de Python, por ejemplo, se debe estar familiarizado con el concepto de entornos virtuales que son una forma de aislar los paquetes Python. Gracias al entorno virtual, una computadora puede ejecutar m\u00faltiples proyectos localmente. Por ejemplo, el Proyecto A podr\u00eda usar Python 3.10 y Django 4.1 entre otras dependencias; mientras que el Proyecto B usa Python 3.8 y Django 2.2. Configurando un entorno virtual dedicado en cada proyecto se puede gestionar estos diferentes paquetes de software sin contaminar nuestro entorno global.</p> <p>Hay una peque\u00f1a confusi\u00f3n derivada de que hay m\u00faltiples herramientas en este momento para implementar un entorno virtual: desde <code>virtualenv</code>, <code>venv</code> a <code>pipenv</code> o <code>poetry</code>, pero fundamentalmente todas hacen lo mismo.</p> <p>La mayor distinci\u00f3n entre los entornos virtuales y Docker es que los entornos virtuales s\u00f3lo pueden aislar paquetes Python. No pueden aislar a los no-Python como una base de datos PostgreSQL o MySQL. Y siguen dependiendo del sistema global; de la instalaci\u00f3n de Python a nivel de sistema (en otras palabras, de su ordenador). Los entornos virtuales apuntan a una instalaci\u00f3n Python existente; no contienen Python en s\u00ed mismos.</p> <p>Los contenedores Linux van un paso m\u00e1s all\u00e1 y a\u00edslan todo el sistema operativo, no s\u00f3lo las partes de Python. En otras palabras, instalaremos el propio Python dentro de Docker, as\u00ed como se instalar\u00e1 y ejecutar\u00e1 en \u00e9l la base de datos a nivel de producci\u00f3n.</p>"},{"location":"02.-Instalaci%C3%B3n/","title":"02.-Instalaci\u00f3n","text":"<p>La documentaci\u00f3n oficial incluye instrucciones de instalaci\u00f3n de Docker Community para\u00a0MacOS,\u00a0Windows,\u00a0Linux\u00a0o servicios en la\u00a0nube.</p> <ul> <li>Instalaci\u00f3n en Ubuntu</li> <li>Instalaci\u00f3n en Arch</li> <li>Instalaci\u00f3n del plugin de ZSH</li> </ul> <p>Sin embargo existen modos m\u00e1s pr\u00e1cticos apoy\u00e1ndonos en el trabajo desarrollado por la comunidad en cada una de las distribuciones.</p> <ul> <li>01.-Instalaci\u00f3n r\u00e1pida en Arch Linux</li> <li>02.-Instalaci\u00f3n r\u00e1pida en Fedora by H\u00e9ctor Del Real L\u00f3pez</li> <li>03.-Instalaci\u00f3n r\u00e1pida en Ubuntu by Yana Zhu</li> <li>04.-Instalaci\u00f3n r\u00e1pida en Ubuntu by Jorge Naranjo Jim\u00e9nez</li> <li>05.-Instalaci\u00f3n r\u00e1pida en Ubuntu por Alberto Romero Rubiales</li> <li> <p>06.-Instalaci\u00f3n r\u00e1pida en Ubuntu por Estefany LIzeth Silva Robles</p> </li> <li> <p>Enlaces:</p> </li> </ul> <p>Conocimiento Libre en la Universidad de Costa Rica (UCR): Docker, aplicaciones en cualquier parte</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/","title":"01.-Instalaci\u00f3n r\u00e1pida en Arch Linux","text":""},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#actualizamos-repositorios","title":"Actualizamos repositorios","text":"<pre><code>sudo pacman -Syy\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalamos-docker-y-docker-compose","title":"Instalamos <code>docker</code> y <code>docker-compose</code>","text":"<pre><code>sudo pacman -S docker docker-compose\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#iniciamos-docker-y-lo-habilitamos-para-que-se-inicie-al-reiniciar","title":"Iniciamos Docker y lo habilitamos para que se inicie al reiniciar","text":"<pre><code>sudo systemctl enable docker\nsudo systemctl start docker\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#comprobamos-la-version-de-docker-y-si-esta-instalado","title":"Comprobamos la versi\u00f3n de docker y si est\u00e1 instalado","text":"<p><code>docker -v</code></p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#anadimos-a-nuestro-usuario-para-controlar-docker","title":"A\u00f1adimos a nuestro usuario para controlar Docker","text":"<p>Creamos el grupo <code>docker</code>:</p> <pre><code>sudo groupadd docker\n</code></pre> <p>A\u00f1adimos al usuario:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>ATENCI\u00d3N: Para que los cambios surtan efecto habr\u00e1 que reiniciar la m\u00e1quina completamente, no basta con cerrar el terminal.</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#comprobar-la-instalacion","title":"Comprobar la instalaci\u00f3n","text":"<p>Para comprobar si Docker est\u00e1 instalado correctamente en tu sistema, puedes ejecutar el siguiente comando:</p> <pre><code>docker run hello-world\n</code></pre> <p>Este comando descargar\u00e1 la imagen <code>hello-world</code> de Docker Hub y la ejecutar\u00e1 en un contenedor. Si todo funciona correctamente, deber\u00edas ver un mensaje que indica que Docker est\u00e1 instalado y funcionando correctamente.</p> <pre><code>Unable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n2db29710123e: Pull complete \nDigest: sha256:4e83453afed1b4fa1a3500525091dbfca6ce1e66903fd4c01ff015dbcb1ba33e\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#docker-compose-en-arch-con-python","title":"Docker-Compose en Arch con Python","text":"<p>En principio ya se ha realizado la instalaci\u00f3n de <code>docker-compose</code>. Otra forma de hacer lo propio es mediante la herramienta de instalaci\u00f3n de paquetes de python <code>pip</code>.</p>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalando","title":"Instalando","text":"<p>Si no tienes instalado <code>pip</code>, deber\u00e1s instalarlo</p> <pre><code>sudo pacman -S  python-pip\n</code></pre> <p>Ahora vamos a instalar docker-compose</p> <pre><code>sudo pip3 install docker-compose\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#version","title":"Versi\u00f3n","text":"<p>Vamos a verificar la versi\u00f3n de docker-compose</p> <pre><code>docker-compose -v\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#levantar-un-docker-con-docker-compose","title":"Levantar un docker con docker-compose","text":"<p>Ahora cuando tenga un archivo\u00a0docker-compose.yml, lo levantar\u00e9 con:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/01.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Arch%20Linux/#instalando-portainer","title":"Instalando Portainer","text":"<p>Portainer gestiona los contenedores de un modo gr\u00e1fico:</p> <pre><code>portainer:\n  image: portainer/portainer-ce:latest\n  container_name: portainer\n  restart: unless-stopped\n  security_opt:\n    - no-new-privileges:true\n  volumes:\n    - /etc/localtime:/etc/localtime:ro\n    - /var/run/docker.sock:/var/run/docker.sock:ro\n    - ./portainer-data:/data\n  ports:\n    - 9000:9000\n</code></pre> <p>Publicado por Angel el 07/12/2022</p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/","title":"Instalaci\u00f3n de Docker Desktop en Fedora 37","text":"<p>La versi\u00f3n de Docker Desktop nos permite lanzar contenedores tanto en modo gr\u00e1fico como desde la terminal.</p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/#requisitos-previos","title":"Requisitos previos","text":"<p>Para instalar Docker necesitamos la terminal de Gnome, como uso KDE, voy a instalar la terminal con el siguiente comando</p> <p><code>sudo dnf install gnome-terminal-3.46.8-1.fc37.x86_64</code></p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/#instalacion","title":"Instalaci\u00f3n","text":"<p>Una vez instalada vamos a a\u00f1adir los repositorios de Docker</p> <pre><code>sudo dnf -y install dnf-plugins-core\n\nsudo dnf config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/fedora/docker-ce.repo\n</code></pre> <p>Despu\u00e9s descargamos el archivo rpm de docker y abrimos la carpeta de descarga en la terminal. He descargado la versi\u00f3n 4.18.0 as\u00ed que la instalo con el siguiente comando</p> <pre><code>sudo dnf install ./docker-desktop-4.18.0-x86_64.rpm\n</code></pre> <p>El instalador nos pedir\u00e1 que importemos la clave gpg de Docker, le damos a Y para aceptar.</p>"},{"location":"02.-Instalaci%C3%B3n/02.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Fedora/#comprobaciones","title":"Comprobaciones","text":"<p>Una vez instalado lo iniciaremos con el siguiente comando</p> <pre><code>systemctl --user enable docker-desktop\n</code></pre> <p>Si queremos que Docker se inicialice cada vez que se reinicie el ordenador ejecutamos lo siguiente</p> <pre><code>systemctl --user enable docker-desktop\n</code></pre> <p>Podemos comprobar si se ha instalado correctamente viendo la version de Docker y tambi\u00e9n ejecutando un contenedor de prueba.</p> <pre><code>docker -v\ndocker run hello-world\n</code></pre> <p>Docker descargar\u00e1 el contenedor y lo ejecutar\u00e1. Si lo ejecuta correctamente mostrar\u00e1 este mensaje</p> <pre><code>Hello from Docker!  \nThis message shows that your installation appears to be working correctly.  \n\nTo generate this message, Docker took the following steps:  \n1. The Docker client contacted the Docker daemon.  \n2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.  \n\u00a0\u00a0\u00a0(amd64)  \n3. The Docker daemon created a new container from that image which runs the  \n\u00a0\u00a0\u00a0executable that produces the output you are currently reading.  \n4. The Docker daemon streamed that output to the Docker client, which sent it  \n\u00a0\u00a0\u00a0to your terminal.  \n\nTo try something more ambitious, you can run an Ubuntu container with:  \n$ docker run -it ubuntu bash  \n\nShare images, automate workflows, and more with a free Docker ID:  \nhttps://hub.docker.com/  \n\nFor more examples and ideas, visit:  \nhttps://docs.docker.com/get-started/\n</code></pre> <p>Hecho esto, ya est\u00e1 instalado docker desktop y podremos iniciar contenedores en modo gr\u00e1fico.</p> <p>por H\u00e9ctor Del Real L\u00f3pez</p>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"03.-Instalaci\u00f3n r\u00e1pida en Ubuntu","text":"<p>Para instalar Docker Desktop, se sigue los siguientes pasos:</p> <p>1). Configurar el repositorio del paquete de Docker.</p> <p>\u200b       1.- Configuraci\u00f3n del paquete.</p> <ul> <li>Para configurar el repositorio con <code>apt</code> , se necesita instalar lo siguiente paquetes:</li> </ul> <p><code>bash   $ sudo apt-get update   $ sudo apt-get install ca-certificates                 install curl                 install gnupg</code></p> <ul> <li>A\u00f1adir la clave GPG oficial de Docker:</li> </ul> <p><code>bash   $ sudo install -m 0755 -d /etc/apt/keyrings   $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg   $ sudo chmod a+r /etc/apt/keyrings/docker.gpg</code></p> <ul> <li>Configurar el repositorio con el siguiente comando:</li> </ul> <p><code>bash   $ echo \\     \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\     \"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\     sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></p> <p>\u200b       2.- Instalaci\u00f3n del Docker Engine.</p> <ul> <li>Actualizar el paquete <code>apt</code> :</li> </ul> <p><code>bash   $ sudo apt-get update</code></p> <ul> <li>Instalar Docker Engine y Docker Compose:</li> </ul> <p><code>bash   $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></p> <ul> <li>Verificar que la instalaci\u00f3n es completada, con una imagen de hello-world:</li> </ul> <p><code>bash   $ sudo docker run hello-world</code></p> <p>2). Descargar el paquete de DEB correspondiente.</p> <p>Lo puede descargar autom\u00e1ticamente en el siguiente enlace:</p> <p>https://desktop.docker.com/linux/main/amd64/docker-desktop-4.18.0-amd64.deb?utm_source=docker&amp;utm_medium=webreferral&amp;utm_campaign=docs-driven-download-linux-amd64</p> <p>3). Instalar el paquete con <code>apt</code> como indica a continuaci\u00f3n (con la versi\u00f3n 4.18.0):</p> <pre><code>$ sudo apt-get update\n$ sudo apt-get install ./docker-desktop-4.18.0-amd64.deb\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#version-que-utiliza-mi-ubuntu","title":"Versi\u00f3n que utiliza (mi) Ubuntu:","text":"<pre><code>$ docker compose version\nDocker Compose version v2.17.2\n\n$ docker --version \nDocker version 23.0.4, build f480fb1\n\n$ docker version \nClient: Docker Engine - Community\n Cloud integration: v1.0.31\n Version:           23.0.4\n API version:       1.41 (downgraded from 1.42)\n Go version:        go1.19.8\n Git commit:        f480fb1\n Built:             Fri Apr 14 10:32:03 2023\n OS/Arch:           linux/amd64\n Context:           desktop-linux\n\nServer: Docker Desktop 4.18.0 (104112)\n Engine:\n  Version:          20.10.24\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.19.7\n  Git commit:       5d6db84\n  Built:            Tue Apr  4 18:18:42 2023\n  OS/Arch:          linux/amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.18\n  GitCommit:        2456e983eb9e37e47538f59ea18f2043c9a73640\n runc:\n  Version:          1.1.4\n  GitCommit:        v1.1.4-0-g5fd4c4d\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#instalacion-de-docker-en-arch","title":"Instalaci\u00f3n de Docker en Arch.","text":"<p>Para instalar Docker en Arch sigue los siguientes pasos:</p> <p>1). Instalar el paquete de Docker Desktop manualmente porque Docker no tiene un repositorio de paquetes Arch.</p> <p>2). Instalar Docker client binary en Linux.</p> <ul> <li> <p>Descargar el archivo binario est\u00e1tico en https://download.docker.com/linux/static/stable/, elige la correspondiente y descarga el archivo <code>.tgz</code>.</p> </li> <li> <p>Extraer el archivo usando el comando <code>tar</code>:</p> </li> </ul> <p><code>bash   $ tar xzvf /path/to/&lt;FILE&gt;.tar.gz</code></p> <ul> <li>OPCIONAL. Mover el archivo binario a un directorio de path.</li> </ul> <p><code>bash   $ sudo cp docker/* /usr/bin/</code></p> <ul> <li>Empezar el Docker daemon:</li> </ul> <p><code>bash   $ sudo dockerd &amp;</code></p> <ul> <li>Verificar que Docker esta instalado correctamente, con una imagen de hello-world:</li> </ul> <p><code>bash    $ sudo docker run hello-world</code></p> <p>3). Descargar el paquete Arch en la siguiente pagina:</p> <p>https://docs.docker.com/desktop/release-notes/</p> <p>4). Instalar el paquete: </p> <pre><code>$ sudo pacman -U ./docker-desktop-&lt;version&gt;-&lt;arch&gt;.pkg.tar.zst\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/03.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#version","title":"Versi\u00f3n:","text":"<pre><code>$ docker compose version\nDocker Compose version v2.5.0\n\n$ docker --version\nDocker version 20.10.14, build a224086349\n\n$ docker version\nClient: Docker Engine - Community\nCloud integration: 1.0.24\nVersion:           20.10.14\nAPI version:       1.41\n...\n</code></pre> <p>by Yana Zhu</p>"},{"location":"02.-Instalaci%C3%B3n/04.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"Instalar Docker en Ubuntu","text":"<p>Vamos a seguir los pasos que hay que realizar para instalar Docker versi\u00f3n 20.04 en Ubuntu.</p> <p>Primero debemos de actualizar nuestra lista de paquetes:</p> <pre><code>$ sudo apt update\n</code></pre> <p>Luego, debemos instalar algunos paquetes de requisitos previos que permitan a <code>apt</code> usar paquetes a trav\u00e9s de HTTPS:</p> <pre><code>$ sudo apt install apt-transport-https ca-certificates curl software-properties-common\n</code></pre> <p>A continuaci\u00f3n, a\u00f1adimos la clave de GPG para el repositorio oficial de Docker en nuestro sistema:</p> <pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre> <p>Agregamos el repositorio de Docker a las fuentes de APT:</p> <pre><code> $ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\"\n</code></pre> <p>Actualizamos el paquete de base de datos con los paquetes de Docker del repositorio reci\u00e9n agregado:</p> <pre><code>$ sudo apt update\n</code></pre> <p>Ahora nos aseguramos de estar en el repositorio de Docker en lugar del repositorio predeterminado de Ubuntu para realizar la instalaci\u00f3n:</p> <pre><code>$ apt-cache policy docker-ce\n</code></pre> <p>Por \u00faltimo, instalamos Docker:</p> <pre><code>$ sudo apt install docker-ce\n</code></pre> <p>Ya est\u00e1 Docker instalado, para comprobarlo usamos:</p> <pre><code>$ sudo systemctl status docker\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/05.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"Instalaci\u00f3n de Docker en Ubuntu","text":"<p>Instalaremos la \u00faltima versi\u00f3n 23.0.4 de Docker en las versiones de Ubuntu 18.04, 20.04, 21.10 y 22.04.</p>"},{"location":"02.-Instalaci%C3%B3n/05.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#instalar-docker-con-el-repositorio-apt","title":"Instalar Docker con el Repositorio apt","text":"<p>Para instalar Docker desde el repositorio apt lo primero que deberemos de realizar es utilizar el siguiente comando:</p> <pre><code>sudo apt update\n</code></pre> <p>Este comando ser\u00e1 utilizado para ver si tenemos todos nuestros paquetes del sistema actualizados.</p> <p>Una vez finalizado ese paso deberemos instalar los certificados necesarios:</p> <pre><code>sudo apt install ca-certificates curl gnupg lsb-release\n</code></pre> <p>A continuaci\u00f3n, registra el llavero GPG de Docker con apt. Esto permitir\u00e1 a apt validar los paquetes Docker que instales.</p> <pre><code>sudo mkdir -p /etc/apt/keyrings\n</code></pre> <pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n</code></pre> <pre><code>$ sudo chmod a+r /etc/apt/keyrings/docker.gpg\n</code></pre> <p>Con el comando <code>curl</code> nos descargaremos la clave GPG de Docker para Ubuntu, la cual se guarda en el directorio de llaveros de apt. </p> <p>Para a\u00f1adir la fuente del paquete Docker al sistema debemos ejecutar el comando <code>echo</code> de la siguiente forma:</p> <pre><code>echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> <p>Esto utiliza la sustituci\u00f3n del shell para detectar autom\u00e1ticamente la arquitectura de tu sistema y descargar la lista de paquetes adecuada.</p> <p>Actualizamos de nuevo la lista de paquetes para que apt sepa que los paquetes Docker existen:</p> <pre><code>sudo apt update\n</code></pre> <p>Ahora podemos utilizar el comando apt install para a\u00f1adir los componentes de Docker al sistema.</p> <pre><code>sudo apt install docker-ce docker-ce-cli containerd.io\n</code></pre> <p>Por ultimo para comprobar que tenemos bien instalado Docker realizaremos el comando siguiente para su funcionamiento:</p> <pre><code>docker run hello-world\n</code></pre>"},{"location":"02.-Instalaci%C3%B3n/06.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/","title":"06.-Instalaci\u00f3n r\u00e1pida en Ubuntu","text":""},{"location":"02.-Instalaci%C3%B3n/06.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#pasos-para-instalar-docker","title":"Pasos para instalar Docker","text":"<p>Instalaci\u00f3n de Docker en Ubuntu 20.04 de Ubuntu.</p> <p>Primero, actualice su lista de paquetes existente:</p> <pre><code>sudo apt update\n</code></pre> <p>A continuaci\u00f3n, instale algunos paquetes de requisitos previos que permitan a <code>apt</code> usar paquetes a trav\u00e9s de HTTPS:</p> <pre><code>sudo apt install apt-transport-https ca-certificates curl software-properties-common\n</code></pre> <p>Luego, a\u00f1ada la clave de GPG para el repositorio oficial de Docker en su sistema:</p> <pre><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre> <p>Agregue el repositorio de Docker a las fuentes de APT:</p> <pre><code>sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\"\n</code></pre> <p>A continuaci\u00f3n, actualice el paquete de base de datos con los paquetes de Docker del repositorio reci\u00e9n agregado:</p> <pre><code>sudo apt update\n</code></pre> <p>Aseg\u00farese de estar a punto de realizar la instalaci\u00f3n desde el  repositorio de Docker en lugar del repositorio predeterminado de Ubuntu:</p> <pre><code>apt-cache policy docker-ce\n</code></pre> <p>Si bien el n\u00famero de versi\u00f3n de Docker puede ser distinto, ver\u00e1 un resultado como el siguiente:</p> <p>Output of apt-cache policy docker-ce</p> <p></p> <p>Observe que <code>docker-ce</code> no est\u00e1 instalado, pero la opci\u00f3n m\u00e1s viable para la instalaci\u00f3n es del repositorio de Docker para Ubuntu 20.04 (<code>focal</code>).</p> <p>Por \u00faltimo, instale Docker:</p> <pre><code>sudo apt install docker-ce\n</code></pre> <p>Con esto, Docker quedar\u00e1 instalado, el demonio se iniciar\u00e1 y el  proceso se habilitar\u00e1 para ejecutarse en el inicio. Compruebe que  funcione:</p> <pre><code>sudo systemctl status docker\n</code></pre> <p>El resultado debe ser similar al siguiente, y mostrar que el servicio est\u00e1 activo y en ejecuci\u00f3n:</p> <p></p> <p>La instalaci\u00f3n de Docker ahora le proporcionar\u00e1 no solo el servicio  de Docker (demonio) sino tambi\u00e9n la utilidad de l\u00ednea de comandos <code>docker</code> o el cliente de Docker. </p>"},{"location":"02.-Instalaci%C3%B3n/06.-Instalaci%C3%B3n%20r%C3%A1pida%20en%20Ubuntu/#como-asegurarte-de-que-el-motor-docker-funciona-en-ubuntu","title":"C\u00f3mo Asegurarte de que el Motor Docker Funciona en Ubuntu.","text":"<p>Utilizar esta linea de comando, para asegurarte de que todo funciona iniciando un contenedor:</p> <pre><code>$ sudo docker run hello-world\n</code></pre> <p>Ver\u00e1s que el cliente Docker extrae el <code>hello-world:latest</code> a tu m\u00e1quina, desde el repositorio Docker Hub:</p> <p>A continuaci\u00f3n, se iniciar\u00e1 autom\u00e1ticamente un nuevo contenedor. La  imagen de inicio \u00abhola-mundo\u00bb est\u00e1 configurada para ejecutar un simple  comando que emite alguna informaci\u00f3n b\u00e1sica sobre Docker y luego sale  inmediatamente:</p> <p></p> <p>Al ver la salida mostrada arriba, significa que Docker est\u00e1 listo para ser utilizado.</p>"},{"location":"03.-Conceptos%20Clave/","title":"03.-Conceptos Clave","text":"<p>01.-Im\u00e1genes</p> <p>02.-Contenedores</p> <p>03.-Vol\u00famenes</p> <p>04.-Capas</p> <p>05.-Redes</p> <p>06.-Estructura de docker</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/","title":"02.-Contenedores","text":"<p>En pocas palabras, un contenedor es un proceso de espacio aislado en su m\u00e1quina que est\u00e1 al margen de todos los dem\u00e1s procesos en la m\u00e1quina host. Ese aislamiento aprovecha los\u00a0espacios de nombres del kernel y cgroups, caracter\u00edsticas que han estado en Linux durante mucho tiempo. Docker ha trabajado para que estas capacidades sean accesibles y f\u00e1ciles de usar. Para resumir, un contenedor:</p> <ul> <li>Un contenedor es una imagen instanciada (en ejecuci\u00f3n). Se puede crear, iniciar, detener, mover o eliminar un contenedor mediante DockerAPI o CLI.</li> <li>No albergan un sistema operativo sino que a\u00edslan el espacio de usuario.</li> <li>Son muy ligeros porque corren como un proceso sobre el SO del host.</li> <li>Puede ejecutarse en m\u00e1quinas locales, m\u00e1quinas virtuales o implementarse en la nube.</li> <li>Escalan en funci\u00f3n de la demanda, mientras que las M\u00e1quinas Virtuales (MV) tienen que ser aprovisionadas de recursos previamente.</li> <li>Est\u00e1 aislado de otros contenedores y ejecuta su propio software, binarios y configuraciones.</li> </ul> <p>Una imagen de Docker es un archivo compuesto por m\u00faltiples capas que se utiliza para ejecutar c\u00f3digo en un contenedor de Docker. Estas im\u00e1genes son las plantillas base desde la que partimos ya sea para crear una nueva imagen o crear nuevos contenedores para ejecutar las aplicaciones.</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#contenedores-windows-y-contenedores-linux","title":"Contenedores Windows y contenedores Linux","text":"<p>Los contenedores Windows corren sobre Windows y los contenedores Linux sobre Linux Se diferencian en los tipos de aislamiento que tienen ambos</p> <p>Los contenedores Linux:</p> <ul> <li>Se ejecutan sobre el host de modo que son visibles a ellos</li> <li>Se ejecutan sobre el kernel como un proceso visible desde el host</li> </ul> <p>Los contenedores Windows:</p> <ul> <li>Se ejecutan sobre una m\u00e1quina virtual l\u00ednux controlada por el hipervisor de windows (Hyper-V)</li> <li>En Hyper-V Windows lanza una MV super fina que tiene su propio kernel y por tanto los contenedores no son visibles desde el propio SO.</li> </ul>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#portabilidad","title":"Portabilidad","text":"<p>Un contenedor es ejecutado por lo que se denomina el Docker Engine, un demonio que es f\u00e1cilmente instalable en todas las distribuciones Linux y tambi\u00e9n en Windows. Un contenedor ejecuta una imagen de docker, que es una representaci\u00f3n del sistema de ficheros y otros metadatos que el contenedor va a utilizar para su ejecuci\u00f3n. Una vez que hemos generado una imagen de Docker, ya sea en nuestro ordenador o v\u00eda una herramienta externa, esta imagen podr\u00e1 ser ejecutada por cualquier Docker Engine, independientemente del sistema operativo y la infraestructura que haya por debajo.</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#inmutabilidad","title":"Inmutabilidad","text":"<p>Una aplicaci\u00f3n la componen tanto el c\u00f3digo fuente como las librer\u00edas del sistema operativo y del lenguaje de programaci\u00f3n necesarias para la ejecuci\u00f3n de dicho c\u00f3digo. Estas dependencias van en funci\u00f3n, a su vez, del sistema operativo donde nuestro c\u00f3digo va a ser ejecutado, y por esto mismo ocurre muchas veces aquello de que \u201cno s\u00e9, en mi m\u00e1quina funciona\u201d. Sin embargo, el proceso de instalaci\u00f3n de dependencias en Docker no depende del sistema operativo, sino que este proceso se realiza cuando se genera una imagen de docker. Es decir, una imagen de docker (tambi\u00e9n llamada repositorio por su parecido con los repositorios de git) contiene tanto el c\u00f3digo de la aplicaci\u00f3n como las dependencias que necesita para su ejecuci\u00f3n. Una imagen se genera una vez y puede ser ejecutada las veces que sean necesarias, y siempre ejecutar\u00e1 con las misma versi\u00f3n del c\u00f3digo fuente y sus dependencias, por lo que se dice que es inmutable. Si unimos inmutabilidad con el hecho de que Docker es portable, decimos que Docker es una herramienta fiable, ya que una vez generada una imagen, \u00e9sta se comporta de la misma manera independientemente del sistema operativo y de la infraestructura donde se est\u00e9 ejecutando.</p>"},{"location":"03.-Conceptos%20Clave/02.-Contenedores/#ligereza","title":"Ligereza","text":"<p>Los contenedores corriendo en la misma m\u00e1quina comparten entre ellos el sistema operativo, pero cada contenedor es un proceso independiente con su propio sistema de ficheros y su propio espacio de procesos y usuarios (para este fin Docker utiliza cgroups y namespaces, recursos de aislamiento basados en el kernel de Linux). Esto hace que la ejecuci\u00f3n de contenedores sea mucho m\u00e1s ligera que otros mecanismos de virtualizaci\u00f3n. Comparemos por ejemplo con otra tecnolog\u00eda muy utilizada como es Virtualbox. Virtualbox permite del orden de 4 \u00f3 5 m\u00e1quinas virtuales en un ordenador convencional, mientras que en el mismo ordenador podremos correr cientos de containers sin mayor problema, adem\u00e1s de que su gesti\u00f3n es mucho m\u00e1s sencilla.</p>"},{"location":"03.-Conceptos%20Clave/03.-Vol%C3%BAmenes/","title":"03.-Vol\u00famenes","text":"<p>En Docker, un volumen es un mecanismo para persistir los datos que se generan dentro de un contenedor de Docker, de manera que puedan ser compartidos y reutilizados por otros contenedores.</p> <p>Un volumen de Docker es un \u00e1rea de almacenamiento de datos que se encuentra fuera del sistema de archivos del contenedor y que se mantiene separada del ciclo de vida del contenedor. Esto significa que los datos almacenados en un volumen persistir\u00e1n incluso despu\u00e9s de que se elimine el contenedor.</p> <p>Los vol\u00famenes de Docker se pueden utilizar para diferentes fines, como por ejemplo:</p> <ul> <li>Compartir datos entre varios contenedores: Los vol\u00famenes permiten compartir datos entre varios contenedores de Docker, lo que facilita el intercambio de informaci\u00f3n entre diferentes aplicaciones y servicios.</li> <li>Almacenar datos persistentes: Los vol\u00famenes se pueden utilizar para almacenar datos que deben persistir m\u00e1s all\u00e1 del ciclo de vida de un contenedor, como por ejemplo datos de una base de datos.</li> <li>Hacer copias de seguridad de datos: Los vol\u00famenes permiten hacer copias de seguridad de los datos almacenados en un contenedor, lo que ayuda a proteger la informaci\u00f3n importante en caso de fallos en el sistema o errores humanos.</li> </ul>"},{"location":"03.-Conceptos%20Clave/04.-Capas/","title":"04.-Capas","text":"<p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas:</p> <ul> <li> <p>Para crear una imagen, generalmente se crea el archivo de texto <code>Dockerfile</code> formado por diferentes instrucciones. Cada l\u00ednea representa una instrucci\u00f3n, y cada vez que se ejecuta el Dockerfile se ejecutan dichas instrucciones de arriba a abajo.</p> </li> <li> <p>Estos <code>Dockerfile</code>-s se almacenan como texto y se pueden compartir con facilidad, as\u00ed como almacenarse en sistemas de control de versiones.</p> </li> <li> <p>Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior.</p> </li> <li> <p>La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa.</p> </li> <li> <p>Cada imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados.</p> </li> <li> <p>Al final del <code>Dockerfile</code>, la \u00faltima instrucci\u00f3n define el comando que se ejecutar\u00e1 cuando arranquemos el contenedor.</p> </li> <li> <p>Al ejecutar un comando a partir de la imagen creada, se ejecuta el comando especificado y se convierte en el proceso con PID 1 dentro del \u00e1rbol virtual de procesos.</p> </li> <li> <p>Cada vez que se ejecuta una instrucci\u00f3n, se crea un contenedor y se etiqueta con un hash creado para obtener un nombre \u00fanico. De este modo, podemos reutilizar estas capas intermedias y solo tener que construirlas una vez.</p> </li> </ul> <p>El contenedor seguir\u00e1 en marcha mientras el proceso creado siga en ejecuci\u00f3n.</p>"},{"location":"03.-Conceptos%20Clave/05.-Redes/","title":"05.-Redes","text":"<p>En Docker, las redes son una forma de conectar contenedores y permitir que se comuniquen entre s\u00ed y con otros servicios en la red. Las redes de Docker se utilizan para facilitar la comunicaci\u00f3n entre contenedores y para aislar los contenedores de otras redes. Docker proporciona varios tipos de redes, que se utilizan para diferentes prop\u00f3sitos:</p> <ul> <li> <p>Bridge network (red puente): Es la red predeterminada en Docker. Cada contenedor se conecta a una red puente virtual, que se encuentra en el host. Los contenedores en la misma red puente pueden comunicarse entre s\u00ed mediante sus nombres de host.</p> </li> <li> <p>Host network (red de host): En esta red, los contenedores se conectan directamente a la red del host, en lugar de a una red virtual. Esto permite que los contenedores tengan acceso directo a los recursos de red del host, pero tambi\u00e9n puede presentar problemas de seguridad.</p> </li> <li> <p>Overlay network (red de superposici\u00f3n): Esta red se utiliza para conectar contenedores que se ejecutan en diferentes hosts. Los contenedores en la misma red de superposici\u00f3n pueden comunicarse entre s\u00ed como si estuvieran en la misma red local.</p> </li> <li> <p>Macvlan network (red de Macvlan): Esta red se utiliza para conectar contenedores directamente a una interfaz de red f\u00edsica del host. Esto permite que los contenedores tengan direcciones IP \u00fanicas y se comuniquen directamente con otros dispositivos en la red.</p> </li> </ul> <p>Adem\u00e1s de estos tipos de redes, Docker tambi\u00e9n permite crear redes personalizadas para satisfacer las necesidades espec\u00edficas de una aplicaci\u00f3n o servicio.</p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/","title":"06.-Estructura de docker","text":"<p>Docker est\u00e1 formado fundamentalmente por tres componentes:</p> <ul> <li>Docker Engine</li> <li>Docker Client</li> <li>Docker Registry</li> </ul> <p></p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/#docker-engine-o-demonio-docker","title":"Docker Engine o Demonio Docker:","text":"<p>Es un demonio que corre sobre cualquier distribuci\u00f3n de Linux (y ahora tambi\u00e9n en Windows) y que expone una API externa para la gesti\u00f3n de im\u00e1genes y contenedores (y otras entidades que se van a\u00f1adiendo en sucesivas distribuciones de docker como vol\u00famenes o redes virtuales). Podemos destacar entre sus funciones principales:</p> <ul> <li>Creaci\u00f3n de im\u00e1genes docker.</li> <li>Publicaci\u00f3n de im\u00e1genes en un Docker Registry o Registro de Docker (otro componente  Docker que se explicar\u00e1 a continuaci\u00f3n).</li> <li>Descarga de im\u00e1genes desde un Registro de Docker</li> <li>Ejecuci\u00f3n de contenedores usando im\u00e1genes locales.</li> </ul> <p>Otra funci\u00f3n fundamental del Docker Engine es la gesti\u00f3n de los contenedores en ejecuci\u00f3n, permitiendo parar su ejecuci\u00f3n, rearrancarla, ver sus logs o sus estad\u00edsticas de uso de recursos.</p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/#docker-registry-o-registro-docker","title":"Docker Registry o Registro Docker","text":"<p>El Registro es otro componente de Docker que suele correr en un servidor independiente y donde se publican las im\u00e1genes que generan los Docker Engine de tal manera que est\u00e9n disponibles para su utilizaci\u00f3n por cualquier otra m\u00e1quina. Es un componente fundamental dentro de la arquitectura de Docker ya que permite distribuir nuestras aplicaciones. El Registro de Docker es un proyecto open source que puede ser instalado gratuitamente en cualquier servidor, pero Docker ofrece Docker Hub, un sistema SaaS de pago donde puedes subir tus propias im\u00e1genes, acceder a im\u00e1genes p\u00fablicas de otros usuarios, e incluso a im\u00e1genes oficiales de las principales aplicaciones como son: MySQL, MongoDB, RabbitMQ, Redis, etc.</p> <p>El registro de Docker funciona de una manera muy parecida a git (de la misma manera que Dockerhub y us m\u00e9todos de pago funcionan de una manera muy parecida a Github). Cada imagen, tambi\u00e9n conocida como repositorio, es una sucesi\u00f3n de capas. Es decir, cada vez que hacemos un build en local de nuestra imagen, el Registro de Docker s\u00f3lo almacena el diff respecto de la versi\u00f3n anterior, haciendo mucho m\u00e1s eficiente el proceso de creaci\u00f3n y distribuci\u00f3n de im\u00e1genes.</p>"},{"location":"03.-Conceptos%20Clave/06.-Estructura%20de%20docker/#docker-client-o-cliente-docker","title":"Docker Client o Cliente Docker","text":"<p>Es cualquier herramienta que hace uso de la api remota del Docker Engine, pero suele hacer referencia al comando <code>docker</code> que hace las veces de herramienta de l\u00ednea de comandos (cli) para gestionar un Docker Engine. La cli de docker se puede configurar para hablar con un Docker Engine local o remoto, permitiendo gestionar tanto nuestro entorno de desarrollo local, como nuestros servidores de producci\u00f3n.</p>"},{"location":"03.-Conceptos%20Clave/01.-Im%C3%A1genes/01.-Im%C3%A1genes/","title":"01.-Im\u00e1genes","text":"<p>Una imagen de Docker es un paquete de software que contiene todo lo necesario para ejecutar una aplicaci\u00f3n, incluyendo el c\u00f3digo, las dependencias, el sistema operativo, las bibliotecas y las configuraciones.</p> <p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas.</p> <p>Las im\u00e1genes de Docker se utilizan como plantillas para crear contenedores de Docker, que son instancias en tiempo de ejecuci\u00f3n de una imagen.</p> <p>Las im\u00e1genes se crean a partir de un archivo de configuraci\u00f3n llamado <code>Dockerfile</code>, que especifica los componentes y configuraciones necesarios para la aplicaci\u00f3n. Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior.</p> <p>La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa, por tanto, una imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados.</p> <p>Una vez que se ha creado una imagen de Docker, se puede almacenar en un registro de im\u00e1genes de Docker, como Docker Hub o un registro privado, para que otros usuarios puedan descargarla y utilizarla en la creaci\u00f3n de contenedores.</p> <p>Las im\u00e1genes de Docker son portables y se pueden ejecutar en cualquier sistema que admita la plataforma Docker. Adem\u00e1s, como las im\u00e1genes est\u00e1n aisladas del sistema operativo del host, se pueden ejecutar varias instancias de la misma imagen en diferentes contenedores sin interferir entre s\u00ed.</p>"},{"location":"03.-Conceptos%20Clave/01.-Im%C3%A1genes/02.-Docker%20Hub/","title":"02.-Docker Hub","text":"<p>Docker Hub es el mayor repositorio del mundo de im\u00e1genes de contenedores con una gran variedad de fuentes de contenido, incluidos desarrolladores, proyectos de c\u00f3digo abierto y proveedores de software independientes (ISV Independent Software Vendor) que construyen y distribuyen su c\u00f3digo en contenedores. Los usuarios tienen acceso a repositorios p\u00fablicos gratuitos para almacenar y compartir im\u00e1genes o pueden elegir un plan de suscripci\u00f3n para repositorios privados.</p>"},{"location":"04.-Manos%20a%20la%20obra/","title":"04.-Manos a la obra","text":"<p>Una vez instalado <code>docker</code> en nuestro sistema o en una m\u00e1quina virtual, empezamos con la parte pr\u00e1ctica y divertida del uso de esta tecnolog\u00eda. Para empezar vamos a familiarizarnos con la gesti\u00f3n de im\u00e1genes y contenedores desde nuestra querida l\u00ednea de comandos:</p> <p>01.-Versi\u00f3n y Gesti\u00f3n del Servicio</p> <p>02.-Usar el comando docker</p> <p>03.-Trabajar con im\u00e1genes de docker</p> <p>04.-Ejecutar un contenedor de Docker</p> <p>05.-Administrar contenedores de docker</p> <p>06.-Creaci\u00f3n de una imagen personalizada a partir de un contenedor</p> <p>07.-Guardar im\u00e1genes de docker en un repositorio de docker</p> <p>08.-Variables de entorno</p> <p>09.-Practica con Docker Playground</p> <p>10.-Limpi\u00e1ndolo todo</p>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/","title":"01.-Versi\u00f3n y Gesti\u00f3n del Servicio","text":""},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#version","title":"Versi\u00f3n","text":"<pre><code>$ docker --version\n$ docker -v\n</code></pre> <pre><code>Docker version 23.0.3, build 3e7cbfdee1\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#estado-del-servicio","title":"Estado del servicio","text":"<pre><code>$ sudo systemctl status docker\n</code></pre> <pre><code>\u25cf docker.service - Docker Application Container Engine\n     Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; preset: disabled)\n     Active: active (running) since Fri 2023-04-21 10:10:47 CEST; 13min ago\nTriggeredBy: \u25cf docker.socket\n       Docs: https://docs.docker.com\n   Main PID: 685 (dockerd)\n      Tasks: 17\n     Memory: 123.2M\n        CPU: 438ms\n     CGroup: /system.slice/docker.service\n             \u2514\u2500685 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock\n\nabr 21 10:10:46 SDD dockerd[685]: time=\"2023-04-21T10:10:46.219884270+02:00\" level=info msg=\"Firewalld: i&gt;\nabr 21 10:10:46 SDD dockerd[685]: time=\"2023-04-21T10:10:46.744731604+02:00\" level=info msg=\"Default brid&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.019068520+02:00\" level=info msg=\"Firewalld: i&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.290530069+02:00\" level=info msg=\"Loading cont&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.415183339+02:00\" level=warning msg=\"Not using&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.415390693+02:00\" level=info msg=\"Docker daemo&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.415694639+02:00\" level=info msg=\"Daemon has c&gt;\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.470857994+02:00\" level=info msg=\"[core] [Serv&gt;\nabr 21 10:10:47 SDD systemd[1]: Started Docker Application Container Engine.\nabr 21 10:10:47 SDD dockerd[685]: time=\"2023-04-21T10:10:47.494255040+02:00\" level=info msg=\"API listen o&gt;\nlines 1-22/22 (END)\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#arranque-del-servicio","title":"Arranque del servicio","text":"<pre><code>$ sudo sytemctl start docker\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#parada-del-servicio","title":"Parada del servicio","text":"<pre><code>$ sudo sytemctl stop docker.socket\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#habilitacion-del-servicio","title":"Habilitaci\u00f3n del servicio","text":"<p>Podemos hacer que el servicio arranque con el sistema con el siguiente comando:</p> <pre><code>$ sudo systemctl enable docker\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/01.-Versi%C3%B3n%20y%20Gesti%C3%B3n%20del%20Servicio/#deshabilitacion-del-servicio","title":"Deshabilitaci\u00f3n del servicio","text":"<p>Podemos hacer que el servicio NO arranque con el sistema con el siguiente comando:</p> <pre><code>$ sudo systemctl disable docker\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/02.-Usar%20el%20comando%20docker/","title":"02.-Usar el comando docker","text":"<p>El uso de docker consiste en pasar a este una cadena de opciones y comandos seguida de argumentos. La sintaxis adopta esta forma:</p> <pre><code>$ docker [opciones] [comando] [argumento]\n</code></pre> <p>Para ver todos los subcomandos disponibles, escribimos lo siguiente:</p> <pre><code>$ docker\n</code></pre> <p>Si deseamos ver las opciones disponibles para un comando espec\u00edfico, escribimos lo siguiente:</p> <pre><code>$ docker &lt;subcomando-docker&gt; --help\n</code></pre> <p>Para ver informaci\u00f3n sobre <code>docker</code> relacionada con todo el sistema, utilizamos el siguiente comando:</p> <pre><code>$ docker info\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/03.-Trabajar%20con%20im%C3%A1genes%20de%20docker/","title":"03.-Trabajar con im\u00e1genes de docker","text":"<p>Los contenedores de Docker se construyen con im\u00e1genes de Docker. Por defecto, Docker obtiene estas im\u00e1genes de Docker Hub, un registro de Docker gestionado por Docker, la empresa responsable del proyecto Docker. Cualquiera puede alojar sus im\u00e1genes en Docker Hub, de modo que la mayor\u00eda de las aplicaciones y las distribuciones de Linux que necesitaremos tendr\u00e1n im\u00e1genes alojadas all\u00ed.</p> <p>Podemos buscar im\u00e1genes disponibles en Docker Hub usando el comando <code>docker</code> con el subcomando <code>search</code>. Por ejemplo, para buscar la imagen de Ubuntu, escribimos lo siguiente:</p> <pre><code>$ docker search ubuntu\n</code></pre> <pre><code>NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\nubuntu                           Ubuntu is a Debian-based Linux operating sys\u2026   15864     [OK]       \nwebsphere-liberty                WebSphere Liberty multi-architecture images \u2026   293       [OK]       \nopen-liberty                     Open Liberty multi-architecture images based\u2026   59        [OK]       \nneurodebian                      NeuroDebian provides neuroscience research s\u2026   100       [OK]       \nubuntu-debootstrap               DEPRECATED; use \"ubuntu\" instead                50        [OK]       \nubuntu-upstart                   DEPRECATED, as is Upstart (find other proces\u2026   113       [OK]       \nubuntu/nginx                     Nginx, a high-performance reverse proxy &amp; we\u2026   84                   \nubuntu/cortex                    Cortex provides storage for Prometheus. Long\u2026   3                    \nubuntu/squid                     Squid is a caching proxy for the Web. Long-t\u2026   54                   \nubuntu/apache2                   Apache, a secure &amp; extensible open-source HT\u2026   57                   \nubuntu/mysql                     MySQL open source fast, stable, multi-thread\u2026   45                   \nubuntu/kafka                     Apache Kafka, a distributed event streaming \u2026   29                   \nubuntu/bind9                     BIND 9 is a very flexible, full-featured DNS\u2026   51                   \nubuntu/redis                     Redis, an open source key-value store. Long-\u2026   17                   \nubuntu/prometheus                Prometheus is a systems and service monitori\u2026   40                   \nubuntu/postgres                  PostgreSQL is an open source object-relation\u2026   27                   \nubuntu/zookeeper                 ZooKeeper maintains configuration informatio\u2026   5                    \nubuntu/grafana                   Grafana, a feature rich metrics dashboard &amp; \u2026   9                    \nubuntu/memcached                 Memcached, in-memory keyvalue store for smal\u2026   5                    \nubuntu/prometheus-alertmanager   Alertmanager handles client alerts from Prom\u2026   8                    \nubuntu/dotnet-deps               Chiselled Ubuntu for self-contained .NET &amp; A\u2026   7                    \nubuntu/dotnet-runtime            Chiselled Ubuntu runtime image for .NET apps\u2026   5                    \nubuntu/cassandra                 Cassandra, an open source NoSQL distributed \u2026   2                    \nubuntu/dotnet-aspnet             Chiselled Ubuntu runtime image for ASP.NET a\u2026   4                    \nubuntu/telegraf                  Telegraf collects, processes, aggregates &amp; w\u2026   4   \n</code></pre> <p>El comando que acabamos de ejecutar buscar\u00e1 en los repositorios de Docker Hub en busca de im\u00e1genes que coincidan con el criterio de b\u00fasqueda y devuelve los posibles candidatos.</p> <p>En la columna de OFFICIAL, OK indica que la imagen creada est\u00e1 avalada por la empresa responsable del proyecto. Una vez que identifique la imagen que desear\u00eda usar, podemos descargarla utilizando el subcomando docker pull.</p> <pre><code>$ docker pull ubuntu\n</code></pre> <p>Para ver las im\u00e1genes que tenemos disponibles localmente utilizamos el comando:</p> <pre><code>$ docker images\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/04.-Ejecutar%20un%20contenedor%20de%20Docker/","title":"04.-Ejecutar un contenedor de Docker","text":"<p>El contenedor <code>hello-world</code> que creamos en la instalaci\u00f3n es un ejemplo de un contenedor que se ejecuta y se cierra tras emitir un mensaje de prueba. Los contenedores pueden ofrecer una utilidad mucho mayor y ser interactivos</p> <p>Como ejemplo, ejecutemos un contenedor usando la imagen m\u00e1s reciente de Ubuntu. La combinaci\u00f3n de los conmutadores <code>-i</code> y <code>-t</code> le proporcionan un acceso interactivo del shell al contenedor:</p> <pre><code>$ docker run -it ubuntu\n</code></pre> <p>Nuestros s\u00edmbolos del sistema deben cambiar para reflejar el hecho de que ahora estamos trabajando dentro del contenedor.</p> <p>Ahora podemos ejecutar cualquier comando dentro del contenedor. Por ejemplo, actualizar los repositorios. No es necesario prefijar ning\u00fan comando con sudo, ya que todas las operaciones dentro del contenedor se ejecutan por defecto con el usuario root:</p> <pre><code>$ apt update\n</code></pre> <p>Importante: Cuando trabajamos con contenedores debemos tener en cuenta un detalle y es que las im\u00e1genes que implementamos en muchas ocasiones pueden no tener instaladas algunas aplicaciones que por defecto s\u00ed vienen instaladas en otras im\u00e1genes. Un claro ejemplo es que el contenedor de Ubuntu que estamos utilizando no tiene el editor de texto <code>nano</code>.</p> <p>El motivo por el que no est\u00e1 instalado por defecto este editor es simple, las im\u00e1genes de Docker buscan ser lo m\u00e1s ligeras y modulares posibles para ofrecer servicios de una manera sencilla y r\u00e1pida. Por lo que instalar programas innecesarios que har\u00edan que el tama\u00f1o de la m\u00e1quina fuese mayor va en contra del prop\u00f3sito por el que fue creada esta tecnolog\u00eda.</p> <p>Para instalar nano ejecutamos el comando apt seguido del programa que deseamos instalar.</p> <pre><code>$ apt install nano\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/05.-Administrar%20contenedores%20de%20docker/","title":"05.-Administrar contenedores de docker","text":"<p>Para mostrar los contenedores activos utilizamos el\u00a0 comando:</p> <pre><code>$\u00a0 docker ps\n</code></pre> <p>Si el comando no ha devuelto ning\u00fan contenedor es porque si no a\u00f1adimos la opci\u00f3n\u00a0<code>-d</code>\u00a0 al comando <code>docker run</code>, cuando salimos del contenedor \u00e9ste se para.</p> <p>Para comprobar los contenedores activos e inactivos utilizamos el comando:</p> <pre><code>$ docker ps -a\n</code></pre> <p>Para ver el \u00faltimo contenedor que ha sido creado utilizamos la opci\u00f3n <code>-l</code>:</p> <pre><code>$ docker ps -l\n</code></pre> <p>Para iniciar un contenedor detenido, utilizamos docker start, seguido del nombre del contenedor\u00a0o el ID. Vamos a iniciar el contenedor basado en Ubuntu con el ID cf9cc8313e87:</p> <pre><code>$ docker start cf9cc8313e87\n</code></pre> <p>Para detener un contenedor, utilizamos <code>docker stop</code>, seguido del ID o nombre del contenedor. Esta vez usaremos el nombre que Docker asign\u00f3 al contenedor, que es <code>nostalgic_grothendieck</code>:</p> <pre><code>$ docker stop nostalgic_grothendieck\n</code></pre> <p>Del mismo modo que hemos borrado el contenedor una vez detenido, tambi\u00e9n podemos eliminarlo mientras est\u00e1 a\u00fan corriendo con la opci\u00f3n -f.</p> <pre><code>$ docker rm -f nombre_contenedor\n</code></pre> <p>Podemos iniciar un nuevo contenedor y darle un nombre usando el conmutador <code>\u2013name</code>. Tambi\u00e9n podemos usar el conmutador \u2013rm para crear un contenedor que se elimine de forma autom\u00e1tica cuando se detenga. Consulte el comando docker run help para obtener m\u00e1s informaci\u00f3n sobre estas y otras opciones.</p>"},{"location":"04.-Manos%20a%20la%20obra/06.-Creaci%C3%B3n%20de%20una%20imagen%20personalizada%20a%20partir%20de%20un%20contenedor/","title":"06.-Creaci\u00f3n de una imagen personalizada a partir de un contenedor","text":"<p>Los contenedores pueden convertirse en im\u00e1genes que podremos usar para crear contenedores nuevos. Veamos c\u00f3mo funciona.</p> <p>Despu\u00e9s de instalar el editor de texto <code>nano</code> dentro del contenedor de Ubuntu, dispondremos de un contenedor que se ejecuta a partir de una imagen, pero este es diferente de la imagen que utilizamos para crearlo. Sin embargo, quiz\u00e1s deseemos reutilizar este contenedor que ya tiene instalado <code>nano</code> como base de nuevas im\u00e1genes posteriormente.</p> <pre><code>$ docker commit -m \u00abEscribimos una breve descripci\u00f3n del contenedor\u00bb -a \u00abNombre del autor\u00bb id_contenedor repositorio/nombre_nueva_imagen\n</code></pre> <p>El conmutador <code>-m</code> es el mensaje que permite a otros saber qu\u00e9 cambios realizamos, mientras que <code>-a</code> se utiliza para especificar el autor. El <code>container_id</code> es el que observamos anteriormente cuando iniciamos la sesi\u00f3n interactiva de Docker. A menos que hayamos creado repositorios adicionales en Docker Hub, el campo repositorio generalmente corresponde a nuestro nombre de usuario de Docker Hub.</p> <p>Partiendo del siguiente caso vamos a crear una imagen personalizada de ubuntu con el editor de texto preinstalado por nosotros.</p> <p>Copiamos el ID del contenedor.</p> <p>Con el comando exit salimos del contenedor y adaptamos el comando anterior a nuestro propio caso.</p> <pre><code>$ docker commit -m \"Ubuntu con editor de texto\" -a Mentecato bea6a695cbc3 ubuntu_con_nano\n</code></pre> <p>Comprobamos que se ha guardado la imagen localmente con el nombre <code>ubuntu_con_nano</code></p> <pre><code>$ docker images\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/07.-Guardar%20im%C3%A1genes%20de%20docker%20en%20un%20repositorio%20de%20docker/","title":"07.-Guardar im\u00e1genes de docker en un repositorio de docker","text":"<p>En primer lugar, nos registramos en Docker Hub accediendo a su p\u00e1gina https://hub.docker.com/.</p> <p>A continuaci\u00f3n iniciamos sesi\u00f3n en Docker Hub con el siguiente comando. </p> <p>Importante: Se le solicitar\u00e1 autenticarse usando su contrase\u00f1a de Docker Hub. </p> <pre><code>$ docker login -u nombre_de_usuario\n</code></pre> <p>Para el ejemplo que se muestra en el \u00faltimo paso, deberemos escribir lo siguiente:</p> <pre><code>$ docker tag pjvdockerhub/ubuntu_con_nano pjvdockerhub/ubuntu_con_nano\n</code></pre> <p>Para guardar la imagen de nuestro contenedor en nuestro repositorio de Docker Hub utilizamos el comando.</p> <pre><code>$ docker push nombre_de_usuario/nombre_imagen\n</code></pre> <p>Siguiendo el esquema anterior comando quedar\u00eda as\u00ed.</p> <pre><code>$ docker push pjvdockerhub/ubuntu_con_nano\n</code></pre> <p>Iniciamos sesi\u00f3n en nuestro repositorio de docker y comprobamos que ya tenemos disponible nuestra imagen.</p> <p>Para utilizar esta imagen en cualquier equipo primero iniciamos sesi\u00f3n en docker con el comando <code>docker login -u nombre_usuario</code>y luego escribimos el siguiente comando:</p> <pre><code>$ docker pull nombre_de_usuario/imagen\n</code></pre> <p>En mi caso el comando queda del siguiente modo:</p> <pre><code>$ docker pull pjvdockerhub/ubuntu_con_nano\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/08.-Variables%20de%20entorno/","title":"08.-Variables de entorno","text":"<p>Las variables de entorno en Docker son una forma de proporcionar configuraci\u00f3n din\u00e1mica a los contenedores. Podemos establecer variables de entorno en las instancias de contenedor para proporcionar configuraci\u00f3n din\u00e1mica a la aplicaci\u00f3n o el script que se ejecuta en el contenedor.</p> <p>Para establecer una variable de entorno en un contenedor, puede utilizar el argumento <code>--env</code> o <code>-e</code> con el comando <code>docker run</code>. Por ejemplo, para establecer la variable de entorno <code>MI_VAR</code> en el valor <code>mi_valor</code>, puede ejecutar lo siguiente:</p> <pre><code>docker run --env MY_VAR=my_value my_image\n</code></pre> <p>Tambi\u00e9n podemos establecer variables de entorno en un archivo <code>.env</code> y utilizar el comando <code>docker-compose</code> para ejecutar los contenedores.</p>"},{"location":"04.-Manos%20a%20la%20obra/09.-Practica%20con%20Docker%20Playground/","title":"09.-Practica con Docker Playground","text":"<p>Podemos practicar gratuitamente Docker desde la siguiente p\u00e1gina https://labs.play-with-docker.com/</p> <p>Hacemos clic sobre A\u00f1adir nueva instancia y ya podemos comenzar a practicar con Docker.</p> <p>Comprobamos la versi\u00f3n de Docker que viene instalada.</p> <p>Ejercicio: Utiliza Docker Playground para instalar un servidor web Apache.</p> <p>Soluci\u00f3n:</p> <p>En primer lugar, buscamos una imagen de apache en los repositorios de Docker Hub.</p> <pre><code>$ docker search apache\n</code></pre> <p>Descargamos la imagen oficial de apache httpd.</p> <pre><code>$ docker pull httpd\n</code></pre> <p>Creamos el contenedor de apache.</p> <pre><code>$ docker run -dit --name servidor_web -p 80:80 httpd\n</code></pre> <p>Par\u00e1metros docker run:</p> <p><code>-d</code> = permite ejecutar el contenedor en segundo plano</p> <p><code>-i</code> = permite que el contenedor sea interactivo</p> <p><code>\u2013t</code> = proporciona al contenedor una terminal</p> <p><code>--name</code> = nombre del contenedor</p> <p><code>-p</code> = permite mapear puertos desde el interior del contenedor 80:80 al exterior del contenedor 80:80. El puerto que utilizamos ha sido el 80 porque es el puerto por defecto que utiliza apache para conexiones no seguras.</p>"},{"location":"04.-Manos%20a%20la%20obra/10.-Limpi%C3%A1ndolo%20todo/","title":"10.-Limpi\u00e1ndolo todo","text":"<ul> <li>Para ver en qu\u00e9 y de cu\u00e1nto espacio estamos utilizando en nuestro sistema de contenedores docker:</li> </ul> <pre><code>$ docker system df\n</code></pre> <ul> <li>Para borrar todos los contenedores:</li> </ul> <pre><code>$ docker container prune\n</code></pre> <ul> <li>Para listar los vol\u00famenes locales existentes  <code>$ docker volume ls</code></li> <li>Para borrar todos los vol\u00famenes locales no asociados a un contenedor:</li> </ul> <pre><code>$ docker volume prune\n</code></pre> <ul> <li>Para borrar vol\u00famenes locales individualmente:</li> </ul> <pre><code>$ docker volume rm \u00abvolumen_local\u00bb\n</code></pre> <ul> <li>Para borrar todas las im\u00e1genes:</li> </ul> <pre><code>$ docker rmi $(docker images -a -q)\n</code></pre> <ul> <li>Para limpiar todos los contenedores detenidos, las im\u00e1genes no utilizadas y los vol\u00famenes no utilizados:</li> </ul> <pre><code>$ docker system prune\n</code></pre>"},{"location":"04.-Manos%20a%20la%20obra/11.-Ejercicios%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20I/","title":"11.-Ejercicios creaci\u00f3n de contenedores b\u00e1sicos I","text":""},{"location":"04.-Manos%20a%20la%20obra/11.-Ejercicios%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20I/#ejercicios-para-repasar","title":"Ejercicios para repasar","text":"<ul> <li>Instala docker en una m\u00e1quina y config\u00faralo para que se pueda usar con un usuario sin privilegios.</li> </ul> <pre><code>$ sudo pacman -Syy\n$ sudo pacman -S docker docker-compose\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n$ sudo usermod -aG docker $USER\n$ reboot\n</code></pre> <ul> <li>Ejecuta un contenedor a partir de la imagen <code>hello-word</code>. Comprueba que nos devuelve la salida adecuada. Comprueba que no se est\u00e1 ejecutando. Lista los contenedores que est\u00e1n parados. Borra el contenedor.</li> </ul> <pre><code>$ docker run --name mi_contenedor hello-world\n</code></pre> <pre><code>$ docker ps\n</code></pre> <pre><code>$ docker ps -a\n</code></pre> <pre><code>$ docker rm mi_contenedor\n</code></pre> <pre><code>$ docker image rm hello-world\n</code></pre> <ul> <li>Crea un contenedor interactivo desde una imagen <code>debian</code>. Instala un paquete (por ejemplo <code>nano</code>).  Vuelve a iniciar el contenedor y accede de nuevo a \u00e9l de forma interactiva. \u00bfSigue instalado el <code>nano</code>?. Sal del contenedor, y b\u00f3rralo. Crea un nuevo contenedor interactivo desde la misma imagen. \u00bfTiene el <code>nano</code> instalado?</li> </ul> <pre><code>$ docker search debian\n$ docker run -it --name mi_contenedor debian\n$ apt update\n$ apt upgrade\n$ apt install nano\n</code></pre> <p>Sal de la terminal, \u00bfsigue el contenedor corriendo?</p> <pre><code>$ docker ps\n\u00abNo\u00bb\n</code></pre> <p>\u00bfPor qu\u00e9?</p> <pre><code>\u00abEl contenedor se detiene porque el proceso principal que se ejecuta en el contenedor, bash en este caso, termina su ejecuci\u00f3n\u00bb\n</code></pre> <p>Vuelve a iniciar el contenedor y accede de nuevo a \u00e9l de forma interactiva. </p> <pre><code>$ docker start -i mi_contenedor\n</code></pre> <p>\u00bfSigue instalado  <code>nano</code>?.</p> <pre><code>\u00abS\u00ed\u00bb\n</code></pre> <p>Sal del contenedor, y b\u00f3rralo. Crea un nuevo contenedor interactivo desde la misma imagen.</p> <pre><code>$ docker rm debian\n$ docker ps -a\n$ docker run -it --name mi_nuevo_contenedor debian\n</code></pre> <p>\u00bfTiene <code>nano</code> instalado?</p> <pre><code>\u00abNo\u00bb\n</code></pre> <ul> <li>Crea un contenedor demonio con un servidor <code>nginx</code> usando la imagen oficial de nginx.</li> </ul> <pre><code>$ docker run -d -p 8080:80 --name servidor_nginx nginx\n</code></pre> <p>Al crear el contenedor, \u00bfhas tenido que indicar alg\u00fan comando para que lo ejecute?</p> <pre><code>\u00abNo\u00bb\n</code></pre> <p>Accede al navegador web y comprueba que el servidor est\u00e1 funcionando.   <code>$ firefox localhost</code>  Muestra los logs del contenedor.  <code>shell  $ docker logs servidor_nginx</code></p> <ul> <li>Crea un contenedor con la aplicaci\u00f3n Nextcloud, mirando la documentaci\u00f3n en docker Hub, para personalizar el nombre de la base de datos sqlite que va a utilizar.</li> </ul> <pre><code>$ docker run -d -p 8080:80 -v nextcloud:/var/www/html --name nextcloud-db -e SQLITE_DATABASE=BD nextcloud\n</code></pre> <p>Este comando crear\u00e1 un contenedor de Nextcloud con una base de datos SQLite llamada <code>BD</code>. El contenedor se ejecutar\u00e1 en segundo plano (<code>-d</code>), expondr\u00e1 el puerto <code>8080</code> (<code>-p</code>) y se vincular\u00e1 a un volumen llamado <code>nextcloud</code> (<code>-v</code>). Tambi\u00e9n se asignar\u00e1 un nombre al contenedor (<code>--name</code>) para facilitar su referencia y se especificar\u00e1 la variable de entorno <code>SQLITE_DATABASE</code> para nombrar la base de datos.</p>"},{"location":"04.-Manos%20a%20la%20obra/11.-Ejercicios%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20I/#ejercicio-para-entregar","title":"Ejercicio para entregar","text":"<p>Crearemos un contenedor demonio a partir de la imagen <code>nginx</code>, el contenedor se debe llamar <code>servidor_web</code> y se debe acceder a \u00e9l utilizando el puerto 8181 del ordenador donde tengas instalado docker.</p> <p>Entrega un fichero comprimido o un documento markdown con los siguientes pantallazos:</p> <ol> <li>Pantallazo donde se vea la creaci\u00f3n del contenedor y podamos comprobar que el contenedor est\u00e1 funcionando.</li> <li>Pantallazo donde se vea el acceso al servidor web utilizando un navegador web (recuerda que tienes que acceder a la ip del ordenador donde tengas instalado docker)</li> <li>Pantallazo donde se vean las im\u00e1genes que tienes en tu registro local.</li> <li>Pantallazo donde se vea como se elimina el contenedor (recuerda que antes debe estar parado el contenedor).</li> </ol>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/","title":"05.- Gesti\u00f3n de im\u00e1genes","text":"<p>Hasta ahora hemos creado contenedores a partir de las im\u00e1genes que encontramos en Docker Hub. Estas im\u00e1genes las han creado otras personas.</p> <p>Para crear un contenedor que sirva nuestra aplicaci\u00f3n, tendremos que crear una imagen personaliza, es lo que llamamos \u201cdockerizar\u201d una aplicaci\u00f3n.</p> <p></p> <p>Una imagen docker es un paquete autocontenido que contiene todo lo necesario para ejecutar una aplicaci\u00f3n o servicio en un contenedor docker. Hay dos formas principales de crear una imagen docker:</p> <ul> <li> <p>A partir de un contenedor: Consiste en crear un contenedor a partir de una imagen base, modificarlo seg\u00fan las necesidades y luego guardar los cambios como una nueva imagen. Esta forma es \u00fatil para hacer pruebas r\u00e1pidas o personalizar una imagen existente.</p> </li> <li> <p>A partir de un <code>Dockerfile</code>: La segunda forma consiste en escribir un Dockerfile con las instrucciones para construir la imagen desde cero. Esta forma es m\u00e1s recomendable para automatizar el proceso de creaci\u00f3n de im\u00e1genes, documentar los pasos y facilitar la reproducci\u00f3n y el mantenimiento de la imagen.</p> </li> </ul>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/01.-Imagen%20a%20partir%20de%20un%20contenedor/","title":"01.-Imagen a partir de un contenedor","text":"<p>La primera forma para personalizar im\u00e1genes es partiendo de un contenedor que hayamos modificado.</p> <ul> <li>Arranca un contenedor a partir de una imagen base.</li> </ul> <pre><code>$ docker run -it --name mi_apache debian bash\n</code></pre> <ul> <li>Realiza las modificaciones pertinentes en el contenedor (instalaciones, modificaci\u00f3n de archivos,\u2026).</li> </ul> <pre><code>root@\u00abcontenedor\u00bb:/# apt update &amp;&amp; apt install apache2 -y\nroot@\u00abcontenedor\u00bb:/# echo \"&lt;h1&gt;Dockerizando Apache&lt;/h1&gt;\" &gt; /var/www/html/index.html\nroot@\u00abcontenedor\u00bb:/# exit\n</code></pre> <p>El primer comando actualiza la lista de paquetes disponibles e instala el servidor web <code>apache2</code> en el contenedor. El operador <code>&amp;&amp;</code> indica que el segundo comando solo se ejecuta si el primero tiene \u00e9xito. El indicador <code>-y</code> permite instalar el paquete sin confirmaci\u00f3n.</p> <p>El segundo comando crea un fichero llamado <code>index.html</code> en el directorio <code>/var/www/html</code> del contenedor, que es el directorio ra\u00edz por defecto del servidor web <code>apache1</code>. El fichero contiene una etiqueta HTML que muestra el texto <code>Curso Docker</code> como un encabezado de nivel 1. El operador <code>&gt;</code> redirige la salida del comando <code>echo</code> al fichero indicado.</p> <ul> <li>Crear una nueva imagen partiendo de ese contenedor usando <code>docker commit</code>. Con esta instrucci\u00f3n se crear\u00e1 una nueva imagen con las capas de la  imagen base m\u00e1s la capa propia del contenedor. Si no indicamos etiqueta en el nombre, se pondr\u00e1 la etiqueta <code>latest</code>.</li> </ul> <pre><code>$ docker commit mi_apache mi_nuevo_apache:v1\nsha256:017a4489735f91f68366f505e4976c111129699785e1ef609aefb51615f98fc4\n\n$ docker images\nREPOSITORY       TAG       IMAGE ID       CREATED         SIZE\nmi_nuevo_apache   v1        4a5b320915d6   3 seconds ago   253MB\ndebian           latest    34b4fa67dc04   8 hours ago     124MB\n...\n</code></pre> <ul> <li>Podr\u00edamos crear un nuevo contenedor a partir de esta nueva imagen, pero al crear una imagen con este m\u00e9todo no podemos configurar el proceso que se va a ejecutar por defecto al crear el contenedor (el proceso por defecto que se ejecuta ser\u00eda el de la imagen base). Por lo tanto en la creaci\u00f3n del nuevo contenedor tendr\u00edamos que indicar el  proceso que queremos ejecutar. En este caso para ejecutar el servidor web <code>apache2</code> tendremos que ejecutar el comando <code>apache2ctl -D FOREGROUND</code>:</li> </ul> <pre><code>$ docker run -d -p 8080:80 \\\n             --name servidor_web \\\n             mi_nuevo_apache:v1 \\\n             bash -c \"apache2ctl -D FOREGROUND\"\n</code></pre> <p>Una vez lanzado podemos acceder a nuestro nuevo apache2 mediante la url http://localhost:8080/</p>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/","title":"02.-Imagen a partir de un fichero Dockerfile","text":"<p>El m\u00e9todo anterior tiene algunos inconvenientes:</p> <ul> <li> <p>No se puede reproducir la imagen. Si la perdemos tenemos que recordar toda la secuencia de \u00f3rdenes que hab\u00edamos ejecutado desde que arrancamos el contenedor hasta que ten\u00edamos una versi\u00f3n definitiva e hicimos <code>docker commit</code>.</p> </li> <li> <p>No podemos configurar el proceso que se ejecutar\u00e1 en el contenedor que hemos creado desde la imagen. Los contenedores creados a partir de la nueva imagen ejecutaran por defecto el proceso que estaba configurado en la imagen base.</p> </li> <li> <p>No podemos cambiar la imagen de base. Si ha habido alguna actualizaci\u00f3n, problemas de seguridad, etc. con la imagen de base tenemos que descargar la nueva versi\u00f3n, volver a crear un nuevo contenedor basado en ella y ejecutar de nuevo toda la secuencia de \u00f3rdenes.</p> </li> </ul> <p>Por todas estas razones, el m\u00e9todo preferido para la creaci\u00f3n de im\u00e1genes es el uso de ficheros <code>Dockerfile</code> y el comando <code>docker build</code>. Con este m\u00e9todo vamos a tener las siguientes ventajas:</p> <ul> <li> <p>Podremos reproducir la imagen f\u00e1cilmente ya que en el fichero <code>Dockerfile</code> tenemos todas y cada una de las \u00f3rdenes necesarias para la construcci\u00f3n de la imagen. Si adem\u00e1s ese Dockerfile est\u00e1 guardado en un sistema de control de versiones como git podremos, no s\u00f3lo reproducir la imagen sino asociar los cambios en el <code>Dockerfile</code> a los cambios en las versiones de las im\u00e1genes creadas.</p> </li> <li> <p>Podremos configurar el proceso que se ejecutar\u00e1 por defecto en los contenedores creados a partir de la nueva imagen.</p> </li> <li> <p>Si queremos cambiar la imagen de base esto es extremadamente sencillo con un <code>Dockerfile</code>; \u00fanicamente tendremos que modificar la primera l\u00ednea de ese fichero tal y como explicaremos m\u00e1s adelante.</p> </li> </ul>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/#gestion-de-imagenes","title":"Gesti\u00f3n de im\u00e1genes","text":"<p>Para crear una imagen de docker, se sigue el siguiente proceso b\u00e1sico:</p> <ol> <li>Crear un archivo <code>Dockerfile</code></li> <li>Escribir las instrucciones del <code>Dockerfile</code></li> <li>Construir la imagen</li> <li>Etiquetar la imagen</li> <li>Subir la imagen a un repositorio de im\u00e1genes</li> </ol>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/#ejemplo-de-dockerfile-servidor-apache","title":"Ejemplo de <code>Dockerfile</code>: Servidor Apache","text":"<p>Para simplificar el proceso de crear una imagen a partir de un contenedor podemos utilizar un <code>Dockerfile</code> y un volumen local con nuestra p\u00e1gina web en este ejemplo particular para obtener una idea de nuestros objetivos.</p> <ul> <li>Creamos un directorio en el sistema local que contendr\u00e1 el archivo <code>index.html</code>. Por ejemplo, podemos crear un directorio llamado <code>html</code> y dentro de \u00e9l colocar el archivo <code>index.html</code> con el contenido deseado.</li> </ul> <pre><code>$ mkdir html\n$ cd html\n$ echo \"&lt;h1&gt;Dockerizando Apache&lt;/h1&gt;\" &gt; index.html\n</code></pre> <ul> <li>Creamos un archivo llamado <code>Dockerfile</code> en el mismo directorio donde est\u00e1 el directorio <code>html</code> (no dentro de \u00e9l) en el que colocaremos el siguiente contenido:</li> </ul> <pre><code>FROM debian\n\nRUN apt-get update &amp;&amp; apt-get install -y apache2\n\nCOPY ./html /var/www/html\n\nEXPOSE 80\n\nCMD [\"apache2ctl\", \"-D\", \"FOREGROUND\"]\n</code></pre> <p>Este <code>Dockerfile</code> utiliza la imagen base <code>debian</code>, actualiza los repositorios, instala el servidor Apache y copia el contenido del directorio <code>html</code> local al directorio <code>/var/www/html</code> dentro del contenedor. Luego expone el puerto 80 y ejecuta el comando <code>apache2ctl -D FOREGROUND</code> para iniciar el servidor Apache.</p> <ul> <li>Ahora podemos construir la imagen de Docker ejecutando el siguiente comando en el directorio donde se encuentra el <code>Dockerfile</code>:</li> </ul> <pre><code>docker build -t mi_nuevo_apache:v1 .\n</code></pre> <p>Este comando construir\u00e1 la imagen de Docker utilizando el <code>Dockerfile</code> y la etiquetar\u00e1 como <code>mi_nuevo_apache:v1</code>.</p> <ul> <li>Una vez que la imagen se haya construido correctamente, podemos ejecutar el siguiente comando para iniciar un contenedor basado en esa imagen y utilizar un volumen local para el archivo <code>index.html</code>:</li> </ul> <pre><code>docker run -d -p 8080:80 --name servidor_web -v ./html:/var/www/html mi_nuevo_apache:v1\n</code></pre> <p>Con estos pasos, tendremos un contenedor en ejecuci\u00f3n que utiliza el archivo <code>index.html</code> desde el volumen local y expone el puerto 8080 en nuestra m\u00e1quina host.</p> <p>Finalmente accederemos con nuestro navegador a la direcci\u00f3n: http://localhost:8080</p> <p>Nota Aclaratoria sobre sincronizaci\u00f3n de directorios:</p> <p>\u00bfSe sincronizan los directorios <code>./hml</code> y <code>/var/www/html</code> autom\u00e1ticamente?</p> <pre><code>  En principio, **no**. En el fichero `dockerfile` proporcionado no se establece una sincronizaci\u00f3n en tiempo real entre el directorio `./html` de nuestro sistema local y el directorio `/var/www/html` del contenedor. La instrucci\u00f3n `COPY` en el `Dockerfile` simplemente **copia** el contenido del directorio local `html` al directorio `/var/www/html` dentro del contenedor durante el proceso de construcci\u00f3n de la imagen.\n</code></pre> <p>Una vez que se ha construido y se est\u00e1 ejecutando un contenedor a partir de la imagen, los cambios realizados en el directorio local <code>html</code> no se reflejar\u00e1n autom\u00e1ticamente en el directorio <code>/var/www/html</code> del contenedor. Esto significa que si realizamos modificaciones en los archivos en el directorio <code>html</code> de nuestro sistema local despu\u00e9s de iniciar el contenedor, los cambios no se sincronizar\u00e1n autom\u00e1ticamente en el contenedor.</p> <p>Sin embargo, hay formas de lograr la sincronizaci\u00f3n en tiempo real entre el sistema local y el contenedor. Una de las formas m\u00e1s comunes es utilizando vol\u00famenes de Docker.</p> <p>Al ejecutar el contenedor, podemos usar la opci\u00f3n <code>-v</code> o <code>--volume</code> para montar un volumen y establecer una sincronizaci\u00f3n bidireccional entre un directorio en tu sistema local y un directorio dentro del contenedor. Por ejemplo:</p> <p><code>docker run -d -p 8080:80 --name servidor_web -v /ruta/al/directorio/html:/var/www/html mi_nuevo_apache:v1</code></p> <p>En este caso, <code>/ruta/al/directorio/html</code> representa la ruta al directorio <code>html</code> en nuestro sistema local, y <code>/var/www/html</code> es el directorio dentro del contenedor. Con esta configuraci\u00f3n, cualquier cambio realizado en el directorio <code>html</code> de nuestro sistema local se sincronizar\u00e1 autom\u00e1ticamente con el directorio <code>/var/www/html</code> dentro del contenedor.</p> <p>Esta sincronizaci\u00f3n en tiempo real nos permite realizar cambios en los archivos del directorio <code>html</code> en nuestro sistema local y ver los resultados reflejados inmediatamente en el contenedor sin necesidad de reconstruir la imagen o reiniciar el contenedor.</p> <p>Es importante tener en cuenta que la sincronizaci\u00f3n de directorios utilizando vol\u00famenes solo se produce mientras el contenedor est\u00e1 en ejecuci\u00f3n. Si se elimina el contenedor, los datos del volumen no persistir\u00e1n a menos que se utilicen vol\u00famenes de Docker persistentes o se realice una configuraci\u00f3n adicional.</p>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/#el-fichero-dockerfile","title":"El fichero <code>Dockerfile</code>","text":"<p>El archivo\u00a0<code>Dockerfile</code>\u00a0es un archivo de texto que contiene las instrucciones para construir una imagen de Docker. En \u00e9l se especifican el sistema operativo base, las dependencias, las bibliotecas y las configuraciones necesarias para la aplicaci\u00f3n. Contiene un conjunto de instrucciones que ser\u00e1n ejecutadas de forma secuencial para construir una nueva imagen docker. Cada una de estas instrucciones crea una nueva capa en la imagen que estamos creando y debe empezar por una palabra clave en may\u00fasculas, como FROM, RUN, COPY, etc. <code>Dockerfile</code> tambi\u00e9n puede especificar variables de entorno, puertos expuestos, comandos de entrada y salida y otros metadatos</p> <p>En definitiva, <code>Dockerfile</code> es un fichero de texto que contiene una serie de instrucciones para construir una imagen docker. Cada instrucci\u00f3n a\u00f1ade una capa a la imagen.</p>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/#formato-de-un-dockerfile","title":"Formato de un <code>Dockerfile</code>","text":"<p>El fichero <code>Dockerfile</code> se crear\u00e1 dentro de la carpeta donde tengamos el proyecto</p> <pre><code>FROM ubuntu:14.04\nENTRYPOINT [\"/bin/echo\"]\n</code></pre>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/#ejecutar-un-comando","title":"Ejecutar un comando","text":"<p>Si en lugar de utilizar entrypoints queremos pasar par\u00e1metros, podemos utilizar CMD</p> <pre><code>CMD [\"/bin/echo\" , \"Hi Docker !\"]\n</code></pre> <p>Hay varias instrucciones que podemos usar en la construcci\u00f3n de un Dockerfile, pero la estructura fundamental del fichero es:</p> <ul> <li>Indicamos imagen base: <code>FROM</code></li> <li>Metadatos: <code>LABEL</code></li> <li>Instrucciones de construcci\u00f3n: <code>RUN, COPY, ADD, WORKDIR</code></li> <li>Configuraci\u00f3n: Variable de entornos, usuarios, puertos: <code>USER, EXPOSE, ENV</code></li> <li>Instrucciones de arranque: <code>CMD, ENTRYPOINT</code></li> </ul>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/#instrucciones-en-un-dockerfile","title":"Instrucciones en un <code>Dockerfile</code>","text":"<p>\u00c9stas son las principales instrucciones que podemos usar:</p> <ul> <li> <p><code>FROM</code>: Sirve para especificar la imagen sobre la que voy a construir la m\u00eda. Ejemplo: <code>FROM php:7.4-apache</code></p> </li> <li> <p><code>LABEL</code> : Sirve para a\u00f1adir metadatos a la imagen mediante <code>\u00abclave\u00bb=\u00abvalor\u00bb</code>. Ejemplo: <code>LABEL company=iesromerovargas</code> </p> </li> <li> <p><code>COPY</code>: Para copiar ficheros desde mi equipo a la imagen. Esos ficheros deben estar en el mismo contexto (carpeta o repositorio). Su sintaxis es <code>COPY [--chown=&lt;usuario&gt;:&lt;grupo&gt;] src dest</code>. Por ejemplo: <code>COPY --chown=www-data:www-data myapp /var/www/html</code></p> </li> <li> <p><code>ADD</code>: Es similar a <code>COPY</code> pero tiene funcionalidades adicionales como especificar URLs y tratar archivos comprimidos.</p> </li> <li> <p><code>RUN</code>: Ejecuta una orden creando una nueva capa. El comando <code>RUN</code> puede escribirse en formato SHELL (<code>RUN \u00aborden\u00bb</code>) o bajo la opci\u00f3n de escritura EXEC(<code>RUN [\u00aborden\u00bb,\u00abpar\u00e1metro1\u00bb,\u00abpar\u00e1metro2\u00bb]</code>):</p> <ul> <li>Ejemplo:      <code>RUN apt update &amp;&amp; apt install -y git</code>     En este caso es muy importante que pongamos la opci\u00f3n -y porque en el proceso de construcci\u00f3n no puede haber interacci\u00f3n con el usuario.</li> </ul> </li> <li> <p><code>WORKDIR</code>: Establece el directorio de trabajo dentro de la imagen que estamos creando para posteriormente usar las \u00f3rdenes <code>RUN</code>,<code>COPY</code>,<code>ADD</code>,<code>CMD</code> o <code>ENTRYPOINT</code>.</p> <ul> <li>Ejemplo:     `WORKDIR /usr/local/apache/htdocs</li> </ul> </li> <li> <p><code>EXPOSE</code>: Nos da informaci\u00f3n acerca de qu\u00e9 puertos tendr\u00e1 abiertos el contenedor cuando se cree uno en base a la imagen que estamos creando. Es meramente informativo.</p> <ul> <li>Ejemplo:     <code>EXPOSE 80</code></li> </ul> </li> <li> <p><code>USER</code>: Para especificar (por nombre o <code>UID/GID</code>) el usuario de trabajo para todas las \u00f3rdenes <code>RUN</code>, <code>CMD</code> y <code>ENTRYPOINT</code> posteriores.</p> <ul> <li>Ejemplos:     <code>USER gatsby / USER 1001:10001</code></li> </ul> </li> <li> <p><code>ARG</code>: Para definir variables para las cuales los usuarios pueden especificar valores a la hora de hacer el proceso de <code>build</code> mediante el <code>flag --build-arg</code>. Su sintaxis es <code>ARG \u00abnombre_variable\u00bb</code> o <code>ARG nombre_variable=valor_por_defecto</code>. Posteriormente esa variable se puede usar en el resto de la \u00f3rdenes de la siguiente manera <code>$nombre_variable</code>.</p> <ul> <li>Ejemplo:      <code>ARG usuario=www-data</code>. No se puede usar con <code>ENTRYPOINT</code> y <code>CMD</code>.</li> </ul> </li> <li><code>ENV</code>: Para establecer variables de entorno dentro del contenedor. Puede ser usado posteriormente en las \u00f3rdenes <code>RUN</code> a\u00f1adiendo <code>$</code> delante de el nombre de la variable de entorno.<ul> <li>Ejemplo:      <code>ENV WEB_DOCUMENT_ROOT=/var/www/html</code> No se puede usar con <code>ENTRYPOINT</code> y <code>CMD</code>.</li> </ul> </li> <li><code>ENTRYPOINT</code>: Para establecer el ejecutable que se lanza siempre cuando se crea el contenedor con <code>docker run</code>, salvo que se especifique expresamente algo diferente con el flag <code>--entrypoint</code>. Su sintaxis es la siguiente: <code>ENTRYPOINT \u00abcommand\u00bb</code> \u00f3 <code>ENTRYPOINT [\"executable\",\"param1\",\"param2\"]</code>.<ul> <li>Ejemplo:     <code>ENTRYPOINT [\"/usr/sbin/apache2ctl\",\"-D\",\"FOREGROUND\"]</code></li> </ul> </li> <li><code>CMD</code>: Para establecer el ejecutable por defecto (salvo que se sobreescriba desde la orden <code>docker run</code>) o para especificar par\u00e1metros para un <code>ENTRYPOINT</code>. Si tenemos varios s\u00f3lo se ejecuta el \u00faltimo. Su sintaxis es: <code>CMD param1 param2</code> \u00f3 <code>CMD [\"param1\",\"param2\"]</code> \u00f3 <code>CMD[\"command\",\"param1\"]</code>.<ul> <li>Ejemplo:     <code>CMD [\u201c-c\u201d \u201c/etc/nginx.conf\u201d] / ENTRYPOINT [\u201cnginx\u201d]</code></li> </ul> </li> </ul> <p>Para una descripci\u00f3n completa sobre el fichero Dockerfile, puedes acceder a la documentaci\u00f3n oficial.</p>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/02.-Imagen%20a%20partir%20de%20un%20fichero%20Dockerfile/#ejemplo-de-dockerfile-aplicacion-python","title":"Ejemplo de <code>Dockerfile</code>: Aplicaci\u00f3n Python","text":"<pre><code># Usar una imagen base de python\nFROM python:3.10\n\n# Instalar poetry con pip\nENV POETRY_VERSION=1.4.2\nRUN pip install \"poetry==$POETRY_VERSION\"\n\n# Copiar los archivos de configuraci\u00f3n de poetry\nWORKDIR /app\nCOPY pyproject.toml poetry.lock ./\n\n# Desactivar la creaci\u00f3n de virtualenvs\nRUN poetry config virtualenvs.create false\n\n# Instalar las dependencias con poetry\nRUN poetry install\n\n# Copiar el archivo python\nCOPY hola_mundo.py ./\n\n# Ejecutar el archivo con poetry run python\nCMD [\"poetry\", \"run\", \"python\", \"hola_mundo.py\"]\n</code></pre> <p>En este caso, el fichero <code>Dockerfile</code> se utiliza para construir una imagen de Docker que ejecuta un script de Python llamado <code>hola_mundo.py</code> utilizando Poetry como gestor de dependencias y empaquetado.</p> <p><code>Poetry</code> es una herramienta de gesti\u00f3n de dependencias y empaquetado para aplicaciones y proyectos de Python. Est\u00e1 dise\u00f1ada para simplificar y agilizar el manejo de las dependencias de Python, as\u00ed como la gesti\u00f3n del entorno virtual y la construcci\u00f3n de paquetes.</p> <p>Aqu\u00ed se explica el contenido y las acciones realizadas en cada instrucci\u00f3n de nuestro <code>Dockerfile</code>:</p> <ul> <li> <p><code>FROM python:3.10</code>: Esta l\u00ednea establece la imagen base para el contenedor, en este caso, se utiliza la imagen oficial de Python versi\u00f3n 3.10.</p> </li> <li> <p><code>ENV POETRY_VERSION=1.4.2</code>: Se establece la variable de entorno <code>POETRY_VERSION</code> con el valor \"1.4.2\", que indica la versi\u00f3n espec\u00edfica de Poetry a instalar.</p> </li> <li> <p><code>RUN pip install \"poetry==$POETRY_VERSION\"</code>: Se utiliza el comando <code>pip</code> para instalar Poetry en el contenedor, utilizando la versi\u00f3n especificada en la variable de entorno.</p> </li> <li> <p><code>WORKDIR /app</code>: Establece el directorio de trabajo dentro del contenedor como \"/app\". Los comandos posteriores se ejecutar\u00e1n en este directorio.</p> </li> <li> <p><code>COPY pyproject.toml poetry.lock ./</code>: Copia los archivos de configuraci\u00f3n de Poetry (<code>pyproject.toml</code> y <code>poetry.lock</code>) desde el directorio local al directorio de trabajo dentro del contenedor. Poetry crea por defecto un entorno virtual para cada proyecto que gestiona, pero en el caso de docker, esto no es necesario ni deseable, ya que la imagen de docker ya es un entorno aislado. Por eso, se usa ese comando para indicarle a poetry que instale las dependencias directamente en el int\u00e9rprete de python de la imagen, sin crear un entorno virtual adicional.</p> </li> <li> <p><code>RUN poetry config virtualenvs.create false</code>: Configura Poetry para que no cree entornos virtuales. Esto significa que las dependencias se instalar\u00e1n a nivel de sistema en lugar de en un entorno virtual separado.</p> </li> <li> <p><code>RUN poetry install</code>: Instala las dependencias del proyecto utilizando Poetry. Las dependencias se obtienen del archivo <code>pyproject.toml</code> y se instalan en el contenedor.</p> </li> <li> <p><code>COPY hola_mundo.py ./</code>: Copia el archivo <code>hola_mundo.py</code> desde el directorio local al directorio de trabajo dentro del contenedor.</p> </li> <li> <p><code>CMD [\"poetry\", \"run\", \"python\", \"hola_mundo.py\"]</code>: Define el comando predeterminado que se ejecutar\u00e1 cuando se inicie el contenedor. En este caso, se utiliza Poetry para ejecutar el script Python <code>hola_mundo.py</code>.</p> </li> </ul> <p>Para construir la imagen, se debe ejecutar el siguiente comando en la terminal, asegur\u00e1ndonos de estar en la misma ubicaci\u00f3n que el archivo <code>Dockerfile</code>:</p> <pre><code>docker build -t \u00abnombre-de-la-imagen:version\u00bb .\n</code></pre> <p>Despu\u00e9s de construir y etiquetar la imagen, se puede subir a un registro de im\u00e1genes de Docker utilizando el comando <code>docker push</code>. Por ejemplo:</p> <pre><code>docker push \u00abnombre-de-la-imagen:version\u00bb\n</code></pre> <p>Una vez subida la imagen, se puede descargar y ejecutar en cualquier sistema que admita Docker utilizando el comando <code>docker run</code>.</p>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/03.-Construyendo%20im%C3%A1genes%20con%20docker%20build/","title":"03.-Construyendo im\u00e1genes con <code>docker build</code>","text":"<p>El comando <code>docker build</code> construye la nueva imagen leyendo las instrucciones del fichero <code>Dockerfile</code> y la informaci\u00f3n de un entorno, que para nosotros va a ser un directorio (aunque tambi\u00e9n podemos guardar informaci\u00f3n, por ejemplo, en un repositorio git).</p> <p>La creaci\u00f3n de la imagen es ejecutada por el docker engine, que recibe toda la informaci\u00f3n del entorno, por lo tanto es recomendable guardar el <code>Dockerfile</code> en un directorio vac\u00edo y a\u00f1adir los ficheros necesarios para la creaci\u00f3n de la imagen. El comando <code>docker build</code> ejecuta las instrucciones de un <code>Dockerfile</code> l\u00ednea por l\u00ednea y va mostrando los resultados en pantalla.</p> <p>Tenemos que tener en cuenta que cada instrucci\u00f3n ejecutada crea una imagen intermedia. Una vez finalizada la construcci\u00f3n de la imagen nos devuelve su id. Algunas im\u00e1genes intermedias se guardan en cach\u00e9, otras se borran. Por lo tanto, si por ejemplo, en un comando ejecutamos <code>cd /scripts/</code> y en otra l\u00ednea le mandamos a ejecutar un script <code>./install.sh</code> no va a funcionar, ya que ha lanzado otra imagen intermedia. Teniendo esto en cuenta, la manera correcta de hacerlo ser\u00eda:</p> <p><code>cd /scripts/;./install.sh</code></p> <p>Para terminar indicar que la creaci\u00f3n de im\u00e1genes intermedias generadas por la ejecuci\u00f3n de cada instrucci\u00f3n del <code>Dockerfile</code>, es un mecanismo de cach\u00e9, es decir, si en alg\u00fan momento falla la creaci\u00f3n de la imagen, al corregir el <code>Dockerfile</code> y volver a construir la imagen, los pasos que hab\u00edan funcionado anteriormente no se repiten ya que tenemos a nuestra disposici\u00f3n las im\u00e1genes intermedias, y el proceso contin\u00faa por la instrucci\u00f3n que caus\u00f3 el fallo.</p>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/03.-Construyendo%20im%C3%A1genes%20con%20docker%20build/#ejemplo-de-dockerfile","title":"Ejemplo de <code>Dockerfile</code>","text":"<p>Vamos a crear un directorio (nuestro entorno) donde vamos a crear un <code>Dockerfile</code> y un fichero <code>index.html</code>:</p> <pre><code>$ cd build\n$ ls\nDockerfile  index.html\n</code></pre> <p>El contenido de Dockerfile es:</p> <pre><code>FROM debian:buster-slim\nMAINTAINER Paco \u00c1vila \"favila@iesromerovargas.com\"\nRUN apt-get update &amp;&amp; apt-get install -y apache2 \nCOPY index.html /var/www/html/\nCMD [\"/usr/sbin/apache2ctl\", \"-D\", \"FOREGROUND\"]\n</code></pre> <p>Para crear la imagen usaremos el comando <code>docker build</code>, indicando el nombre de la nueva imagen (opci\u00f3n -t) e indicando el directorio contexto.</p> <pre><code>$ docker build -t iesromerovargas/myapache2:v2 .\n</code></pre> <p>Nota: Ponemos como directorio el <code>.</code> porque estamos ejecutando esta instrucci\u00f3n desde el directorio donde est\u00e1 el <code>Dockerfile</code>.</p> <p>Una vez terminado, podr\u00edamos ver que hemos generado una nueva imagen:</p> <pre><code>$ docker images\n    REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE\n    iesromerovargas/myapache2 v2                  3bd28de7ae88        43 seconds ago      195MB\n...\n</code></pre> <p>Si usamos el par\u00e1metro <code>--no-cache</code> en <code>docker build</code> har\u00edamos la construcci\u00f3n de una imagen sin usar las capas cacheadas por haber realizado anteriormente im\u00e1genes con capas similares.</p> <p>En este caso al crear el contenedor a partir de esta imagen no hay que indicar el proceso que se va a ejecutar, porque ya se ha indicando en el fichero <code>Dockerfile</code>:</p> <pre><code>$ docker run -d -p 8080:80 --name servidor_web iesromerovargas/myapache2:v2\n</code></pre>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/04.-Organizaci%C3%B3n%20de%20las%20im%C3%A1genes/","title":"04.-Organizaci\u00f3n de las im\u00e1genes","text":"<p>Las im\u00e1genes est\u00e1n hechas de capas ordenadas. Puedes pensar en una capa como un conjunto de cambios en el sistema de archivos. Cuando tomas todas las capas y las apilas, obtienes una nueva imagen que contiene todos los cambios acumulados.</p> <p>Si tienes muchas im\u00e1genes basadas en capas similares, como Sistema Operativo base o paquetes comunes, entonces todas \u00e9stas capas comunes ser\u00e1 almacenadas solo una vez.</p> <p></p> <p>Cuando un nuevo contenedor es creado desde una imagen, todas las capas de la imagen son \u00fanicamente de lectura y una delgada capa lectura-escritura es agregada arriba. Todos los cambios efectuados al contenedor espec\u00edfico son almacenados en esa capa.</p> <p>El contenedor no puede modificar los archivos desde su capa de imagen (que es s\u00f3lo lectura). Crear\u00e1 una copia del fichero en su capa superior, y desde ese punto en adelante, cualquiera que trate de acceder al archivo obtendr\u00e1 la copia de la capa superior.</p> <p></p> <p>Por lo tanto cuando creamos un contenedor ocupa muy poco de disco duro, porque las capas de la imagen desde la que se ha creado se comparten con el contenedor:</p> <p>Veamos el tama\u00f1o de nuestra imagen <code>ubuntu</code>:</p> <pre><code>$ docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nubuntu              latest              f63181f19b2f        7 days ago          72.9MB\n</code></pre> <p>Si creamos un contenedor interactivo:</p> <pre><code>$ docker run -it --name contenedor1 ubuntu /bin/bash \n</code></pre> <p>Nos salimos, y a continuaci\u00f3n visualizamos los contenedores con la opci\u00f3n <code>-s</code> (size):</p> <pre><code>$ docker ps -a -s\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS               NAMES               SIZE\na2d1ce6990d8        ubuntu              \"/bin/bash\"              8 seconds ago       Exited (130) 5 seconds ago                       contenedor1         0B (virtual 72.9MB)\n</code></pre> <p>Nos damos cuenta que el tama\u00f1o real del contenedor es 0B y el virtual, el que comparte con la imagen son los 72,9MB que es el tama\u00f1o de la imagen ubuntu.</p> <p>Si a continuaci\u00f3n volvemos a acceder al contenedor y creamos un fichero:</p> <pre><code>$ docker start contenedor1\ncontenedor1\n$ docker attach contenedor1\nroot@a2d1ce6990d8:/# echo \"00000000000000000\"&gt;file.txt\n</code></pre> <p>Y volvemos a ver el tama\u00f1o, vemos que ha crecido con la creaci\u00f3n del fichero:</p> <pre><code>$ docker ps -a -s\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES               SIZE\na2d1ce6990d8        ubuntu              \"/bin/bash\"              56 seconds ago      Exited (0) 2 seconds ago                        contenedor1         52B (virtual 72.9MB)\n</code></pre> <p>Por todo lo que hemos explicado, ahora se entiende que no podemos eliminar una imagen cuando tenemos contenedores creados a a partir de ella.</p> <p>Por \u00faltimo al solicitar informaci\u00f3n de la imagen, podemos ver informaci\u00f3n sobre sus capas:</p> <pre><code>$ docker inspect ubuntu:latest\n...\n\"RootFS\": {\n        \"Type\": \"layers\",\n        \"Layers\": [\n            \"sha256:9f32931c9d28f10104a8eb1330954ba90e76d92b02c5256521ba864feec14009\",\n            \"sha256:dbf2c0f42a39b60301f6d3936f7f8adb59bb97d31ec11cc4a049ce81155fef89\",\n            \"sha256:02473afd360bd5391fa51b6e7849ce88732ae29f50f3630c3551f528eba66d1e\"\n        ]\n...\n</code></pre>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/05.-Registro%20de%20im%C3%A1genes%20y%20Docker%20Hub/","title":"05.-Registro de im\u00e1genes y Docker Hub","text":"<p>El Registro docker es un componente donde se almacena las im\u00e1genes generadas por el Docker Engine. Puede estar instalada en un servidor independiente y es un componente fundamental, ya que nos permite distribuir nuestras  aplicaciones. Es un proyecto open source que puede ser instalado  gratuitamente en cualquier servidor, pero, como hemos comentado, el proyecto nos ofrece Docker Hub</p> <p></p> <p>El nombre de una imagen suele estar formado por tres partes:</p> <pre><code>usuario/nombre:etiqueta\n</code></pre> <ul> <li><code>usuario</code>: El nombre del usuario que la ha generado. Si la subimos a Docker Hub  debe ser el mismo usuario que tenemos dado de alta en nuestra cuenta.  Las im\u00e1ges oficiales en Docker Hub no tienen nombre de usuario.</li> <li><code>nombre</code>: Nombre significativo de la imagen.</li> <li><code>etiqueta</code>: Nos permite versionar las im\u00e1genes. De esta manera controlamos los cambios que se van produciendo en ella. Si no indicamos etiqueta, por defecto se usa la etiqueta <code>latest</code>, por lo que la mayor\u00eda de las im\u00e1genes tienen una versi\u00f3n con este nombre.</li> </ul>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/06.-Buenas%20pr%C3%A1cticas%20en%20creaci%C3%B3n%20de%20Dockerfile/","title":"06.-Buenas pr\u00e1cticas en creaci\u00f3n de Dockerfile","text":"<ul> <li>Los contenedores deber ser \u201cef\u00edmeros\u201d: Cuando decimos \u201cef\u00edmeros\u201d queremos decir que la creaci\u00f3n, parada, despliegue de los contenedores creados a partir de la imagen que vamos a generar con nuestro <code>Dockerfile</code> debe tener una m\u00ednima configuraci\u00f3n.</li> <li>Uso de ficheros <code>.dockerignore</code>: Como hemos indicado anteriormente, todos los ficheros del contexto se env\u00edan al docker engine, es recomendable usar un directorio vac\u00edo donde vamos creando los ficheros que vamos a enviar. Adem\u00e1s, para aumentar el rendimiento, y no enviar al daemon ficheros innecesarios podemos hacer uso de un fichero <code>.dockerignore</code>, para excluir ficheros y directorios.</li> <li>No instalar paquetes innecesarios: Para reducir la complejidad, dependencias, tiempo de creaci\u00f3n y tama\u00f1o de la imagen resultante, se debe evitar instalar paquetes extras o innecesarios. Si alg\u00fan paquete no es necesario durante la creaci\u00f3n de la imagen, lo mejor es desinstalarlo durante el proceso.</li> <li>Minimizar el n\u00famero de capas: Debemos encontrar el balance entre la legibilidad del <code>Dockerfile</code> y minimizar el n\u00famero de capas que utiliza.</li> <li>Indicar las instrucciones a ejecutar en m\u00faltiples l\u00edneas: Cada vez que sea posible y para hacer m\u00e1s f\u00e1cil futuros cambios, hay que organizar los argumentos de las instrucciones que contengan m\u00faltiples l\u00edneas, esto evitar\u00e1 la duplicaci\u00f3n de paquetes y har\u00e1 que el archivo sea m\u00e1s f\u00e1cil de leer. Por ejemplo:</li> </ul> <pre><code>   RUN apt-get update &amp;&amp; apt-get install -y \\\n   git \\\n   wget \\\n   apache2 \\\n   php5\n</code></pre>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/07.-Ejercicios%20de%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20II/","title":"07.-Ejercicios de creaci\u00f3n de contenedores b\u00e1sicos II","text":""},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/07.-Ejercicios%20de%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20II/#ejercicios-para-repasar","title":"Ejercicios para repasar","text":"<ul> <li>Descarga las siguientes im\u00e1genes: <code>ubuntu:18.04</code>, <code>httpd</code>, <code>tomcat:9.0.74-jdk17-temurin-jammy</code> , <code>jenkins/jenkins:lts</code>, <code>php:7.4-apache</code>.</li> </ul> <pre><code>$ docker pull ubuntu:18.04\n$ docker pull httpd\n$ docker pull tomcat:9.0.74-jdk17-temurin-jammy\n$ docker pull jenkins/jenkins:lts\n$ docker pull php:7.4-apache\n</code></pre> <ul> <li>Muestra las im\u00e1genes que tienes descargadas.</li> </ul> <pre><code>$ docker images\nREPOSITORY        TAG                          IMAGE ID       CREATED        SIZE\ntomcat            9.0.74-jdk17-temurin-jammy   3f55087df9b4   18 hours ago   476MB\nhttpd             latest                       28505717e3ae   37 hours ago   145MB\njenkins/jenkins   lts                          976459dc87b0   45 hours ago   472MB\nubuntu            18.04                        3941d3b032a8   8 weeks ago    63.1MB\nphp               7.4-apache                   20a3732f422b   5 months ago   453MB\n</code></pre> <ul> <li>Crea un contenedor demonio con la imagen <code>php:7.4-apache</code>.</li> </ul> <pre><code>docker run -d --name -p 8080:80 php php:7.4-apache\n</code></pre> <ul> <li>Comprueba el tama\u00f1o del contenedor en el disco duro.</li> </ul> <pre><code>docker ps --sa\n</code></pre> <ul> <li> <p>Con la instrucci\u00f3n <code>docker cp</code> podemos copiar ficheros a o desde un contenedor. Puedes encontrar informaci\u00f3n es esta p\u00e1gina. Crea un fichero en tu ordenador, con el siguiente contenido:</p> <p><code>&lt;?php  echo phpinfo();  ?&gt;</code></p> </li> <li> <p>Copia un fichero <code>info.php</code> al directorio <code>/var/www/html</code> del contenedor con <code>docker cp</code>.</p> </li> </ul> <pre><code>$ docker cp ./info.php php:/var/www/html\n</code></pre> <ul> <li>Vuelve a comprobar el espacio ocupado por el contenedor.</li> </ul> <pre><code>docker ps --sa\n</code></pre> <ul> <li>Accede al fichero <code>info.php</code> desde un navegador web.</li> </ul> <pre><code>firefox http://localhost:8080/info.php/\n</code></pre>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/07.-Ejercicios%20de%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20II/#ejercicio-para-entregar","title":"Ejercicio para entregar","text":""},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/07.-Ejercicios%20de%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20II/#servidor-web","title":"Servidor web","text":"<ul> <li>Arranca un contenedor que ejecute una instancia de la imagen <code>php:7.4-apache</code>, que se llame <code>web</code> y que sea accesible desde tu equipo en el puerto 8000.</li> <li>Colocar en el directorio ra\u00edz del servicio web (<code>/var/www/html</code>) de dicho contenedor un fichero llamado <code>index.html</code> con el siguiente contenido:</li> </ul> <pre><code>&lt;h1&gt;HOLA SOY XXXXXXXXXXXXXXX&lt;/h1&gt;\n</code></pre> <p>Deber\u00e1s sustituir XXXXXXXXXXX por tu nombre y tus apellidos.</p> <ul> <li>Colocar en ese mismo directorio ra\u00edz un archivo llamado <code>index.php</code> con el siguiente contenido: <code>&lt;?php     echo phpinfo();     ?&gt;</code></li> <li>Para crear los ficheros tienes tres alternativas:<ul> <li>Ejecutando bash de forma interactiva en el contenedor y creando los ficheros.</li> <li>Ejecutando un comando <code>echo</code> en el contenedor con <code>docker exec</code>.</li> <li>Usando <code>docker cp</code> como hemos visto en el ejercicio 5.</li> </ul> </li> </ul>"},{"location":"05.-Gesti%C3%B3n%20de%20im%C3%A1genes/07.-Ejercicios%20de%20creaci%C3%B3n%20de%20contenedores%20b%C3%A1sicos%20II/#servidor-de-base-de-datos","title":"Servidor de base de datos","text":"<ul> <li>Arrancar un contenedor que se llame <code>bbdd</code> y que ejecute una instancia de la imagen <code>mariadb</code> para que sea accesible desde el puerto 3336.</li> <li>Antes de arrancarlo visitar la p\u00e1gina del contenedor en Docker Hub y establecer las variables de entorno necesarias para que:<ul> <li>La contrase\u00f1a de root sea <code>root</code>.</li> <li>Crear una base de datos autom\u00e1ticamente al arrancar que se llame <code>prueba</code>.</li> <li>Crear el usuario <code>invitado</code> con las contrase\u00f1a <code>invitado</code>.</li> </ul> </li> </ul> <p>Deber\u00e1s entregar los siguientes pantallazos comprimidos en un zip o en un documento pdf:</p> <ul> <li>Pantallazo que desde el navegador muestre el fichero <code>index.html</code>.</li> <li>Pantallazo que desde el navegador muestre el fichero <code>index.php</code>.</li> <li>Pantallazo donde se vea el tama\u00f1o del contenedor <code>web</code> despu\u00e9s de crear los dos ficheros.</li> <li>Pantallazo donde desde un cliente de base de datos (instalado en tu ordenador) se pueda observar que hemos podido conectarnos al servidor de base de datos con el usuario creado y que se ha creado la base de datos prueba (<code>show databases</code>). El acceso se debe realizar desde el ordenador que ten\u00e9is instalado docker, no hay que acceder desde dentro del contenedor, es decir, no usar <code>docker exec</code>.</li> <li>Pantallazo donde se comprueba que no se puede borrar la imagen <code>mariadb</code> mientras el contenedor <code>bbdd</code> est\u00e1 creado.</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/01.-Vol%C3%BAmenes%20docker%20y%20bind%20mount/","title":"01.-Vol\u00famenes docker y bind mount","text":""},{"location":"06.-Vol%C3%BAmenes/01.-Vol%C3%BAmenes%20docker%20y%20bind%20mount/#los-contenedores-son-efimeros","title":"Los contenedores son ef\u00edmeros","text":"<p>Los contenedores son ef\u00edmeros, es decir, los ficheros, datos y configuraciones que creamos en los contenedores sobreviven a las paradas de los mismos pero, sin embargo, son destruidos si el contenedor es destruido.</p>"},{"location":"06.-Vol%C3%BAmenes/01.-Vol%C3%BAmenes%20docker%20y%20bind%20mount/#los-datos-en-los-contenedores","title":"Los datos en los contenedores","text":"<p>Ante la situaci\u00f3n anteriormente descrita Docker nos proporciona varias soluciones para persistir los datos de los contenedores. En este curso nos vamos a centrar en las dos que considero que son m\u00e1s importantes:</p> <ul> <li>Los vol\u00famenes docker.</li> <li>Los bind mount</li> <li>Los tmpfs mounts: Almacenan en memoria la informaci\u00f3n. (No lo vamos a ver en este curso)</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/01.-Vol%C3%BAmenes%20docker%20y%20bind%20mount/#volumenes-docker","title":"Vol\u00famenes docker","text":"<p>Si elegimos conseguir la persistencia usando vol\u00famenes estamos haciendo que los datos de los contenedores que nosotros decidamos se almacenen en una parte del sistema de ficheros que es gestionada por docker y a la que, debido a sus permisos, s\u00f3lo docker tendr\u00e1 acceso. En linux se guardan en <code>/var/lib/docker/volumes</code>. Este tipo de vol\u00famenes se suele usar en los siguientes casos:</p> <ul> <li>Para compartir datos entre contenedores. Simplemente tendr\u00e1n que usar el mismo volumen.</li> <li>Para copias de seguridad ya sea para que sean usadas posteriormente por otros contenedores o para mover esos vol\u00famenes a otros hosts.</li> <li>Cuando queremos almacenar los datos de nuestro contenedor no localmente sino en un proveedor cloud.</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/01.-Vol%C3%BAmenes%20docker%20y%20bind%20mount/#gestionando-volumenes","title":"Gestionando vol\u00famenes","text":"<p>Algunos comando \u00fatiles para trabajar con vol\u00famenes docker:</p> <ul> <li>docker volumen create: Crea un volumen con el nombre indicado.</li> <li>docker volume rm: Elimina el volumen indicado.</li> <li>docker volumen prune: Para eliminar los vol\u00famenes que no est\u00e1n siendo usados por ning\u00fan contenedor.</li> <li>docker volume ls: Nos proporciona una lista de los vol\u00famenes creados y algo de informaci\u00f3n adicional.</li> <li>docker volume inspect: Nos dar\u00e1 una informaci\u00f3n mucho m\u00e1s detallada de el volumen que hayamos elegido.</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/01.-Vol%C3%BAmenes%20docker%20y%20bind%20mount/#bind-mounts","title":"Bind mounts","text":"<p>Si elegimos conseguir la persistencia de los datos de los contenedores usando bind mount lo que estamos haciendo es \u201cmapear\u201d (montar) una parte de mi sistema de ficheros, de la que yo normalmente tengo el control, con una parte del sistema de ficheros del contenedor. Por lo tanto podemos montar tanto directorios como ficheros. De esta manera conseguimos:</p> <ul> <li>Compartir ficheros entre el host y los containers.</li> <li>Que otras aplicaciones que no sean docker tengan acceso a esos ficheros, ya sean c\u00f3digo, ficheros etc\u2026</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/02.-Asociando%20almacenamiento%20a%20los%20contenedores%20I/","title":"02.-Asociando almacenamiento a los contenedores I","text":"<p>Veamos como puedo usar los vol\u00famenes y los bind mounts en los contenedores. Aunque hay dos formas de asociar el almacenamiento al contenedor nosotros vamos a usar el flag <code>--volume</code> o <code>-v</code>.</p> <p>Si usamos im\u00e1genes de DockerHub, debemos leer la informaci\u00f3n que cada imagen nos proporciona en su p\u00e1gina ya que esa informaci\u00f3n suele indicar c\u00f3mo persistir los datos de esa imagen, ya sea con vol\u00famenes o bind mounts, y cu\u00e1les son las carpetas importantes en caso de ser im\u00e1genes que contengan ciertos servicios (web, base de datos etc\u2026)</p>"},{"location":"06.-Vol%C3%BAmenes/02.-Asociando%20almacenamiento%20a%20los%20contenedores%20I/#ejemplo-usando-volumenes-docker","title":"Ejemplo usando vol\u00famenes docker","text":"<p>Lo primero que vamos a hacer es crear un volumen docker:</p> <pre><code>$ docker volume create miweb\nmiweb\n</code></pre> <p>A continuaci\u00f3n creamos un contenedor con el volumen asociado, usando <code>--mount</code>, y creamos un fichero <code>index.html</code>:</p> <pre><code>$ docker run -d --name my-apache-app -v miweb:/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\nb51f89eb21701362279489c5b52a06b1a44c10194c00291de895b404ab347b80\n</code></pre> <p>-d: Ejecuta el contenedor en segundo plano y muestra el ID del contenedor. --name my-apache-app: Asigna el nombre my-apache-app al contenedor. -v miweb:/usr/local/apache2/htdocs: Monta el volumen <code>miweb</code> en el directorio <code>/usr/local/apache2/htdocs</code> del contenedor, donde se almacenan los archivos web del servidor Apache. -p 8080:80: Publica el puerto <code>80</code> del contenedor en el puerto <code>8080</code> del host, permitiendo acceder al servidor web desde el host. httpd:2.4: Es la imagen base del contenedor, que contiene el servidor web Apache versi\u00f3n 2.4.</p> <pre><code>$ docker exec my-apache-app bash -c 'echo \"&lt;h1&gt;Hola&lt;/h1&gt;\" &gt; /usr/local/apache2/htdocs/index.html'\n\n$ curl http://localhost:8080\n&lt;h1&gt;Hola&lt;/h1&gt;\n\n$ docker rm -f my-apache-app \nmy-apache-app\n</code></pre> <p>Despu\u00e9s de borrar el contenedor, volvemos a crear otro contenedor con el mismo volumen asociado:</p> <pre><code>$ docker run -d --name my-apache-app -v miweb:/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\nbaa3511ca2227e30d90fa2b4b225e209889be4badff583ce58ac1feaa73d5d77\n</code></pre> <p>Y podemos comprobar que no no se ha perdido la informaci\u00f3n (el fichero <code>index.html</code>):</p> <pre><code>$ curl http://localhost:8080\n&lt;h1&gt;Hola&lt;/h1&gt;\n</code></pre> <p>Algunas aclaraciones:</p> <ul> <li>Al no indicar el volumen, se crear\u00e1 un nuevo volumen.</li> <li>Si usamos el flag <code>-v</code> e indicamos un nombre, se crear\u00e1 un volumen docker nuevo.</li> <li>Cuando usamos vol\u00famenes o bind mount, el contenido de lo que tenemos sobreescribir\u00e1 la carpeta destino en el sistema de ficheros del contenedor en caso de que exista.</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/03.-Asociando%20almacenamiento%20a%20los%20contenedores%20II/","title":"03.-Asociando almacenamiento a los contenedores II","text":""},{"location":"06.-Vol%C3%BAmenes/03.-Asociando%20almacenamiento%20a%20los%20contenedores%20II/#ejemplo-montando-directorios-usando-bind-mount","title":"Ejemplo: montando directorios usando bind mount","text":"<p>En este caso vamos a crear un directorio en el sistema de archivo del host, donde vamos a crear un fichero <code>index.html</code>:</p> <pre><code>$ mkdir web\n$ cd web\n/web$ echo \"&lt;h1&gt;Hola&lt;/h1&gt;\" &gt; index.html\n</code></pre> <p>Y podemos montar ese directorio en un contenedor, en este caso usamos la opci\u00f3n <code>-v</code>:</p> <pre><code>$ docker run -d --name my-apache-app -v /home/usuario/web:/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n8de025f6ff4d4b8a5a57d10a9cbb283b103209f358c43148a4716a33a404e208\n</code></pre> <p>Y comprobamos que realmente estamos sirviendo el fichero que tenemos en el directorio que hemos creado.</p> <pre><code>$ curl http://localhost:8080\n&lt;h1&gt;Hola&lt;/h1&gt;\n</code></pre> <p>Eliminamos el contenedor y volvemos a crear otro con el directorio montado:</p> <pre><code>$ docker rm -f my-apache-app \nmy-apache-app\n\n$ docker run -d --name my-apache-app -v /home/usuario/web:/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n1751b04b0548217d7faa628fd69c10e84c695b0e5cc33b482df2c04a6af83292\n\n$ curl http://localhost:8080\n&lt;h1&gt;Hola&lt;/h1&gt;\n</code></pre> <p>Adem\u00e1s podemos comprobar que podemos modificar el contenido del fichero aunque est\u00e9 montado en el contenedor:</p> <pre><code>$ echo \"&lt;h1&gt;Adi\u00f3s&lt;/h1&gt;\" &gt; web/index.html \n$ curl http://localhost:8080\n&lt;h1&gt;Adi\u00f3s&lt;/h1&gt;\n</code></pre> <p>Por \u00faltimo, indicar que si nuestra carpeta origen no existe y hacemos un bind mount con <code>-v</code>, esa carpeta se crear\u00e1 pero lo que tendremos en el contenedor es una carpeta vac\u00eda.</p>"},{"location":"06.-Vol%C3%BAmenes/04.-Redes%20en%20docker/","title":"04.-Redes en docker","text":""},{"location":"06.-Vol%C3%BAmenes/04.-Redes%20en%20docker/#tipos-de-redes-en-docker","title":"Tipos de redes en docker","text":"<p>Cuando instalamos docker tenemos las siguientes redes predefinidas:</p> <pre><code>$ docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\nec77cfd20583        bridge              bridge              local\n69bb21378df5        host                host                local\n089cc966eaeb        none                null                local\n</code></pre> <ul> <li>Por defecto los contenedores que creamos se conectan a la red de tipo bridge llamada <code>bridge</code> (por defecto el direccionamiento de esta red es 172.17.0.0/16). Los contenedores conectados a esta red que quieren exponer alg\u00fan puerto al exterior tienen que usar la opci\u00f3n <code>-p</code> para mapear puertos.</li> </ul> <p>Este tipo de red nos va a permitir:</p> <ul> <li>Aislar los distintos contenedores que tengamos en distintas subredes docker, de tal manera que desde cada una de las subredes solo podremos acceder a los equipos de esa misma subred.</li> <li>Aislar los contenedores del acceso exterior.</li> <li> <p>Publicar servicios que tengamos en los contenedores mediante redirecciones que docker implementar\u00e1 con las pertinentes reglas de iptables (firewall).</p> <p></p> </li> </ul> <p>Veamos un ejemplo:</p> <p>Vamos a crear un contenedor interactivo con la imagen <code>debian</code>:</p> <pre><code>$ docker run -it --name contenedor1 --rm debian bash\n</code></pre> <p>Nota: Hemos usado la opci\u00f3n <code>--rm</code> para al finalizar de ejecutar el proceso, el contenedor se elimina.</p> <p>En otra pesta\u00f1a, podemos ejecutar esta instrucci\u00f3n para obtener la ip que se le ha asignado:</p> <pre><code>$ docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' contenedor1\n172.17.0.2\n</code></pre> <p>Obtenemos informaci\u00f3n del contenedor filtrando el json de salida para obtener la IPv4 que se le ha asignado.</p> <p>Observamos que el contenedor tiene una ip en la red <code>172.17.0.0/16</code>. Adem\u00e1s podemos comprobar que se ha creado un <code>bridge</code> en el host, al que se conectan los contenedores:</p> <pre><code>$ ip a\n...\n5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default \n    link/ether 02:42:be:71:11:9e brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::42:beff:fe71:119e/64 scope link \n       valid_lft forever preferred_lft forever\n...\n</code></pre> <p>Adem\u00e1s podemos comprobar que se han creado distintas cadenas en el cortafuegos para gestionar la comunicaci\u00f3n de los contenedores. Podemos ejecutar como administrador: <code>iptables -L -n</code> y <code>iptables -L -n - t nat</code> y comprobarlo.</p> <ul> <li>Si conecto un contenedor a la red host, el contenedor ofrece el servicio que tiene configurado en el puerto de la red del anfitri\u00f3n. No tiene ip propia, sino es c\u00f3mo si tuviera la ip del anfitri\u00f3n. Por lo tanto, los puertos son accesibles directamente desde el host. Por ejemplo:</li> </ul> <pre><code>$ docker run -d --name mi_servidor --network host josedom24/aplicacionweb:v1\n\n$ docker ps\nCONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS               NAMES\n135c742af1ff        josedom24/aplicacionweb:v1   \"/usr/sbin/apache2ct\u2026\"   3 seconds ago       Up 2 seconds                                  mi_servidor\n</code></pre> <p>Probamos acceder directamente al puerto 80 del servidor para ver la p\u00e1gina web.</p> <ul> <li>La red none no configurar\u00e1 ninguna IP para el contenedor y no tiene acceso a la red externa ni a otros contenedores. Tiene la direcci\u00f3n loopback y se puede usar para ejecutar trabajos por lotes.</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/05.-Ejemplos/","title":"Ejemplo 1: Contenedor nextcloud con almacenamiento persistente","text":"<p>Vamos a desplegar un contenedor con nextcloud, para simplificar la instalaci\u00f3n vamos a realizar la instalaci\u00f3n con una base de dato SQLite. Si estudiamos la documentaci\u00f3n de la imagen <code>nextcloud</code> en Docker Hub, la forma m\u00e1s sencilla de no perder la informaci\u00f3n es crear un volumen para guardar el directorio <code>/var/www/html</code> del contenedor. Vamos a realizar el ejercicio usando vol\u00famenes docker y bind mount.</p>"},{"location":"06.-Vol%C3%BAmenes/05.-Ejemplos/#ejemplo-con-volumenes","title":"Ejemplo con vol\u00famenes","text":"<p>Creamos un volumen:</p> <pre><code>$ docker volume create nextcloud\nnextcloud\n</code></pre> <p>Y creamos el contenedor, guardando el directorio <code>/var/www/html</code> del contenedor en el volumen creado:</p> <pre><code>$ docker run -d -p 80:80  -v nextcloud:/var/www/html --name contenedor_nextcloud nextcloud\n</code></pre> <p>Comprobamos que podemos acceder, terminamos de configurar la aplicaci\u00f3n y una vez operativa subimos los ficheros a la aplicaci\u00f3n:</p> <p></p> <p>A continuaci\u00f3n eliminamos el contenedor y creamos uno nuevo con el mismo volumen:</p> <pre><code>$ docker rm -f contenedor_nextcloud\n\n$ docker run -d -p 80:80  -v nextcloud:/var/www/html --name contenedor_nextcloud nextcloud\n</code></pre> <p>Accede de nuevo a la aplicaci\u00f3n comprueba que la aplicaci\u00f3n sigue configurada y que los ficheros subidos no se han perdido.</p>"},{"location":"06.-Vol%C3%BAmenes/05.-Ejemplos/#ejemplo-con-bind-mount","title":"Ejemplo con bind mount","text":"<p>En este caso, vamos a crear un directorio en nuestro ordenador, que es el que vamos a montar en el contenedor:</p> <pre><code>mkdir datos_nextcloud\n</code></pre> <p>Y creamos el contenedor con la siguiente instrucci\u00f3n:</p> <pre><code>docker run -d -p 80:80 -v /home/vagrant/datos_nextcloud:/var/www/html --name contenedor_nextcloud nextcloud\n</code></pre> <p>Volvemos a acceder, configuramos la aplicaci\u00f3n y subimos alg\u00fan fichero. Usando bind mount tenemos acceso al directorio:</p> <pre><code>$ cd datos_nextcloud/\n~/datos_nextcloud$ ls\n3rdparty  COPYING  config       core      custom_apps  index.html  lib  ocm-provider  ocs-provider  remote.php  robots.txt  themes\nAUTHORS   apps     console.php  cron.php  data         index.php   occ  ocs           public.php    resources   status.php  version.php\n</code></pre> <p>Podemos comprobar que al eliminar el contenedor y crearlo de nuevo usando el mismo directorio bind mount, toda la configuraci\u00f3n y los ficheros subidos no se han perdido.</p>"},{"location":"06.-Vol%C3%BAmenes/05.-Ejemplos/#ejemplo2-contenedor-mariadb-con-almacenamiento-persistente","title":"Ejemplo2: Contenedor mariadb con almacenamiento persistente","text":"<p>Si estudiamos la documentaci\u00f3n de la imagen mariadb en Docker Hub, nos indica que podemos crear un contenedor con informaci\u00f3n persistente de mariadb, de la siguiente forma:</p> <pre><code>$ docker run --name some-mariadb -v /home/\u00abusuario\u00bb/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mariadb\n</code></pre> <p>Es decir se va a crear un directorio <code>/home/\u00abusuario\u00bb/datadir</code> en el host, donde se va a guardar la informaci\u00f3n de la base de datos. Si tenemos que crear de nuevo el contenedor indicaremos ese directorio como bind mount y volveremos a tener accesible la informaci\u00f3n.</p> <pre><code>$ cd datadir/\n~/datadir$ ls\naria_log.00000001  aria_log_control  ib_buffer_pool  ib_logfile0  ibdata1  ibtmp1  multi-master.info  mysql  performance_schema\n\n$ docker exec -it some-mariadb bash -c 'mysql -uroot -p$MYSQL_ROOT_PASSWORD'\n...\nMariaDB [(none)]&gt; create database prueba;\nMariaDB [(none)]&gt; quit\n\n$ docker rm -f some-mariadb \nsome-mariadb\n\n$ docker run --name some-mariadb -v /home/vagrant/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mariadb\nf36589090dd33b116da87e599850b1f25c9ae40e4b28c036c23e602d7bde4cc5\n\n$ docker exec -it some-mariadb bash -c 'mysql -uroot -p $MYSQL_ROOT_PASSWORD'\n...\nMariaDB [(none)]&gt; show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| prueba             |\n+--------------------+\n4 rows in set (0.003 sec)\n</code></pre>"},{"location":"06.-Vol%C3%BAmenes/05.-Ejemplos/#que-informacion-tenemos-que-guardar","title":"\u00bfQu\u00e9 informaci\u00f3n tenemos que guardar?","text":"<p>Para terminar: \u00bfQu\u00e9 debemos guardar de forma persistente en un contenedor?</p> <ul> <li>Los datos de la aplicaci\u00f3n</li> <li>Los logs del servicio</li> <li>La configuraci\u00f3n del servicio: En este caso podemos a\u00f1adirla a la imagen, pero ser\u00e1 necesaria la creaci\u00f3n de una nueva imagen si cambiamos la configuraci\u00f3n. Si la guardamos en un volumen hay que tener en cuanta que ese fichero lo tenemos que tener en el entorno de producci\u00f3n (puede ser bueno, porque las configuraciones de los distintos entornos puede variar).</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/06.-Otros%20usos%20del%20almacenamiento/","title":"06.-Otros usos del almacenamiento","text":"<p>En los ejemplos anteriores hemos usado los vol\u00famenes como copia de seguridad de la informaci\u00f3n, para hacer persistente los contenedores. En este apartado vamos a ver dos ejemplos explicando otros dos usos que le podemos dar al almacenamiento en docker:</p>"},{"location":"06.-Vol%C3%BAmenes/06.-Otros%20usos%20del%20almacenamiento/#compartir-informacion-entre-contenedores","title":"Compartir informaci\u00f3n entre contenedores","text":"<p>En este caso vamos a usar un volumen o bind mount para compartir informaci\u00f3n entre dos contenedores. Si seguimos el principio que un contenedor tiene que ejecutar un s\u00f3lo proceso, en ocasiones nos puede hacer falta que otro contenedor haga una operaci\u00f3n auxiliar y genere una informaci\u00f3n que compartir\u00e1 con el primero por medio de almacenamiento que estar\u00e1 montado en los dos contenedores.</p> <p>Un ejemplo podr\u00eda ser un servicio web que est\u00e1 ofreciendo informaci\u00f3n que tiene que ir leyendo de un repositorio Git. en este caso podr\u00edamos poner un contenedor secundario que cada cierto tiempo leyera el repositorio y le pasara la informaci\u00f3n al primer contenedor por medio de almacenamiento compartido.</p> <p>En nuestro ejemplo vamos a hacer algo mucho m\u00e1s sencillo: el contenedor principal es un servidor web que ofrece un fichero <code>index.html</code> y este fichero se va actualizando por el segundo contenedor, que en el ejemplo lo \u00fanico que va a hacer es escribir la fecha y la hora cada un segundo. Vemos el ejemplo usando vol\u00famenes docker:</p> <p>Lo primero creamos el volumen:</p> <pre><code>$ docker volume create datos_compartidos\n</code></pre> <p>Creamos el primer contenedor con el volumen montado en el DocumentRoot y el tipo de acceso solo lectura, opci\u00f3n <code>ro</code>:</p> <pre><code>$ docker run -d -p 8181:80 --name contenedor1 -v datos_compartidos:/var/www/html:ro php:7.4-apache\n</code></pre> <p>A continuaci\u00f3n creamos el segundo contenedor con un proceso que va a modificar el fichero <code>index.html</code> que guarda en el volumen cada un segundo:</p> <pre><code>$ docker run -d  --name contenedor2 -v datos_compartidos:/srv debian bash -c \"while true; do date &gt;&gt; /srv/index.html;sleep 1;done\"\n</code></pre> <p>Accedemos al puerto 8181 del anfitri\u00f3n y comprueba c\u00f3mo se va actualizando el fichero <code>index.html</code> que estamos viendo.</p> <p>Lo podr\u00edamos hacer tambi\u00e9n con bind mount:</p> <pre><code>$ docker run -d -p 8181:80 --name contenedor1 -v /home/vagrant/compartido:/var/www/html:ro php:7.4-apache\n$ docker run -d  --name contenedor2 -v /home/vagrant/compartido:/srv debian bash -c \"while true; do date &gt;&gt; /srv/index.html;sleep 1;done\"\n</code></pre> <p>Y podr\u00edamos ver el contenido del fichero <code>~/compartido/index.html</code>.</p>"},{"location":"06.-Vol%C3%BAmenes/06.-Otros%20usos%20del%20almacenamiento/#comprobar-compatibilidad-de-codigo-entre-distintas-versiones-de-un-lenguaje-de-programacion","title":"Comprobar compatibilidad de c\u00f3digo entre distintas versiones de un lenguaje de programaci\u00f3n","text":"<p>Otro utilidad que le podemos dar al almacenamiento, en este caso a los bind mount, es la posibilidad de comprobar la compatibilidad de un c\u00f3digo en diferentes versiones del lenguaje de programaci\u00f3n.</p> <p>Veamos un ejemplo en PHP: imaginemos que tenemos un c\u00f3digo que es compatible y funciona bien en PHP 5 y queremos comprobar como se comporta en la versi\u00f3n PHP 7.</p> <p>Siguiendo la documentaci\u00f3n Migraci\u00f3n de PHP 5.6.x a PHP 7.0.x, se ha escogido la funci\u00f3n list que se comporta de manera distinta en PHP5 que en PHP7.</p> <p>Imaginemos que tenemos un directorio <code>codigo</code> con nuestra aplicaci\u00f3n <code>index.php</code>:</p> <pre><code>&lt;?php\n// Funciona bien en php5 ya que list hace la asignaci\u00f3n desde el \u00faltimo al primero\n$info = array('cafe\u00edna','marr\u00f3n', 'caf\u00e9');\n\n// Enumerar todas las variables\nlist($datos[], $datos[], $datos[]) = $info;\necho \"El $datos[0] es $datos[1] y la $datos[2] lo hace especial.\\n\";\n?&gt;\n</code></pre> <p>A continuaci\u00f3n vamos a crear dos contenedores que sirva este c\u00f3digo usando im\u00e1genes distintas , para cada versi\u00f3n de PHP y usando puertos distintos para acceder a cada versi\u00f3n de la aplicaci\u00f3n:</p> <pre><code>$ docker run -d -p 8081:80 --name php56 -v /home/vagrant/codigo:/var/www/html:ro php:5.6-apache\n$ docker run -d -p 8082:80 --name php74 -v /home/vagrant/codigo:/var/www/html:ro php:7.4-apache\n</code></pre> <p>Y ya podemos acceder a los dos puertos de nuestro anfitri\u00f3n y comprobar c\u00f3mo se comporta en PHP5 y en PHP7.</p>"},{"location":"06.-Vol%C3%BAmenes/Ejercicios%20de%20Vol%C3%BAmenes/","title":"Ejercicios para repasar","text":"<p>Vamos a trabajar con vol\u00famenes docker:</p> <ol> <li>Crea un volumen docker que se llame <code>miweb</code>.</li> <li>Crea un contenedor desde la imagen <code>php:7.4-apache</code> donde montes en el directorio <code>/var/www/html</code> (que sabemos que es el DocuemntRoot del servidor que nos ofrece esa imagen) el volumen docker que has creado.</li> <li>Utiliza el comando <code>docker cp</code> para copiar un fichero <code>index.html</code> en el directorio <code>/var/www/html</code>.</li> <li>Accede al contenedor desde el navegador para ver la informaci\u00f3n ofrecida por el fichero <code>index.html</code>.</li> <li>Borra el contenedor</li> <li>Crea un nuevo contenedor y monta el mismo volumen como en el ejercicio anterior.</li> <li>Accede al contenedor desde el navegador para ver la informaci\u00f3n ofrecida por el fichero <code>index.html</code>. \u00bfSegu\u00eda existiendo ese fichero?</li> </ol> <p>Vamos a trabajar con bind mount:</p> <ol> <li>Crea un directorio en tu host y dentro crea un fichero <code>index.html</code>.</li> <li>Crea un contenedor desde la imagen <code>php:7.4-apache</code> donde montes en el directorio <code>/var/www/html</code> el directorio que has creado por medio de <code>bind mount</code>.</li> <li>Accede al contenedor desde el navegador para ver la informaci\u00f3n ofrecida por el fichero <code>index.html</code>.</li> <li>Modifica el contenido del fichero <code>index.html</code> en tu host y comprueba que al refrescar la p\u00e1gina ofrecida por el contenedor, el contenido ha cambiado.</li> <li>Borra el contenedor</li> <li>Crea un nuevo contenedor y monta el mismo directorio como en el ejercicio anterior.</li> <li>Accede al contenedor desde el navegador para ver la informaci\u00f3n ofrecida por el fichero <code>index.html</code>. \u00bfSe sigue viendo el mismo contenido?</li> </ol>"},{"location":"06.-Vol%C3%BAmenes/Ejercicios%20de%20Vol%C3%BAmenes/#ejercicios-para-entregar","title":"Ejercicios para entregar","text":"<p>Entrega uno de estos dos ejercicios (si est\u00e1s muy aburrido puedes entregar los dos):</p>"},{"location":"06.-Vol%C3%BAmenes/Ejercicios%20de%20Vol%C3%BAmenes/#creacion-y-uso-de-volumenes","title":"Creaci\u00f3n y uso de vol\u00famenes","text":"<ol> <li>Crear los siguientes vol\u00famenes con la orden <code>docker volume</code>: volumen_datos y volumen_web.</li> <li>Una vez creados:<ul> <li>Arrancar un contenedor llamado <code>c1</code> sobre la imagen <code>php:7.4-apache</code> que monte el volumen_web en la ruta <code>/var/www/html</code> y que sea accesible en el puerto 8080.</li> <li>Arrancar un contenedor llamado <code>c2</code> sobre la imagen <code>mariadb</code> que monte el volumen_datos en la ruta <code>/var/lib/mysql</code> y cuya contrase\u00f1a de <code>root</code> sea <code>admin</code>.</li> </ul> </li> <li>Intenta borrar el volumen volumen_datos, para ello tendr\u00e1s que parar y borrar el contenedor <code>c2</code> y tras ello borrar el volumen.</li> <li>Copia o crea un fichero <code>index.html</code> al contenedor <code>c1</code>, accede al contenedor y comprueba que se est\u00e1 visualizando.</li> <li>Borra el contenedor <code>c1</code> y crea un contenedor <code>c3</code> con las mismas caracter\u00edsticas que <code>c1</code> pero sirviendo en el puerto 8081.</li> </ol> <p>Deber\u00e1s entregar los siguientes pantallazos comprimidos en un zip o en un documento pdf:</p> <ul> <li>Pantallazo donde se puedan ver los dos vol\u00famenes creados.</li> <li>Pantallazo con la orden correspondiente para arrancar el contenedor c1 usando el volumen_web.</li> <li>Pantallazo con la orden correspondiente para arrancar el contenedor c2 usando el volumen_datos.</li> <li>Pantallazo donde se vea el proceso para poder borrar el volumen_datos.</li> <li>Pantallazo donde se vea el borrado de <code>c1</code> y la creaci\u00f3n de <code>c3</code>.</li> <li>Pantallazo donde se vea el acceso al contenedor <code>c3</code>.</li> </ul>"},{"location":"06.-Vol%C3%BAmenes/Ejercicios%20de%20Vol%C3%BAmenes/#bind-mount-para-compartir-datos","title":"Bind mount para compartir datos","text":"<ol> <li> <p>Crea una carpeta llamada <code>saludo</code> y dentro de ella crea un fichero llamado <code>index.html</code> con el siguiente contenido (Deber\u00e1s sustituir ese XXXXXx por tu nombre.):</p> <p><code>&lt;h1&gt;HOLA SOY XXXXXX&lt;/h1&gt;</code></p> </li> <li> <p>Una vez hecho esto arrancar dos contenedores basados en la imagen php:7.4-apache que hagan un bind mount de la carpeta <code>saludo</code> en la carpeta <code>/var/www/html</code> del contenedor. Uno de ellos vamos a acceder con el puerto 8181 y el otro con el 8282. Y su nombres ser\u00e1n <code>c1</code> y <code>c2</code>.</p> </li> <li>Modifica el contenido del fichero <code>~/saludo/index.html</code>.</li> <li>Comprueba que puedes seguir accediendo a los contenedores, sin necesidad de reiniciarlos.</li> </ol> <p>Deber\u00e1s entregar los siguientes pantallazos comprimidos en un zip o en un documento pdf:</p> <ul> <li>Pantallazo con la orden correspondiente para arrancar el contenedor c1 (puerto 8181) realizando el bind mount solicitado.</li> <li>Pantallazo con la orden correspondiente para arrancar el contenedor c2 (puerto 8282) realizando el bind mount solicitado.</li> <li>Pantallazo donde se pueda apreciar que accediendo a <code>c1</code> se puede ver el contenido de <code>index.html</code>.</li> <li>Pantallazo donde se pueda apreciar que accediendo a <code>c2</code> se puede ver el contenido de <code>index.html</code>.</li> <li>Otro dos pantallazos (o uno) donde se vea accediendo a los contenedores despu\u00e9s de modificar el fichero <code>index.html</code>.</li> </ul>"},{"location":"07.-Redes/01.-Introducci%C3%B3n%20a%20las%20redes%20en%20docker/","title":"Introducci\u00f3n a las redes en docker","text":"<p>Aunque hasta ahora no lo hemos tenido en cuenta, cada vez que creamos un contenedor, est\u00e9 se conecta a una red virtual y docker hace una configuraci\u00f3n del sistema (usando bridges e iptables) para que la m\u00e1quina tenga una ip interna, tenga acceso al exterior, podamos mapear (DNAT) puertos,\u2026</p> <p>Vamos a crear un contenedor interactivos con la imagen <code>debian</code>:</p> <pre><code>$ docker run -it --name contenedor1 --rm debian bash\n</code></pre> <p>Nota: Hemos usado la opci\u00f3n <code>--rm</code> para al finalizar de ejecutar el proceso, el contenedor se elimina.</p> <p>En otra pesta\u00f1a, podemos ejecutar esta instrucci\u00f3n para obtener la ip que se le ha asignado:</p> <pre><code>$ docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' contenedor1\n172.17.0.2\n</code></pre> <p>Obtenemos informaci\u00f3n del contenedor filtrando el json de salida para obtener la IPv4 que se le ha asignado.</p> <p>Observamos que el contenedor tiene una ip en la red <code>172.17.0.0/16</code>. Adem\u00e1s podemos comprobar que se ha creado un <code>bridge</code> en el host, al que se conectan los contenedores:</p> <pre><code>$ ip a\n...\n5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default \n    link/ether 02:42:be:71:11:9e brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::42:beff:fe71:119e/64 scope link \n       valid_lft forever preferred_lft forever\n...\n</code></pre> <p>Adem\u00e1s podemos comprobar que se han creado distintas cadenas en el cortafuegos para gestionar la comunicaci\u00f3n de los contenedores. Podemos ejecutar como administrador: <code>iptables -L -n</code> y <code>iptables -L -n - t nat</code> y comprobarlo.</p>"},{"location":"07.-Redes/02.-Tipos%20de%20redes%20en%20docker/","title":"02.-Tipos de redes en docker","text":"<p>Cuando instalamos docker tenemos las siguientes redes predefinidas:</p> <pre><code>$ docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\nec77cfd20583        bridge              bridge              local\n69bb21378df5        host                host                local\n089cc966eaeb        none                null                local\n</code></pre> <ul> <li> <p>Por defecto los contenedores que creamos se conectan a la red de tipo bridge llamada <code>bridge</code> (por defecto el direccionamiento de esta red es 172.17.0.0/16). Los contenedores conectados a esta red que quieren exponer alg\u00fan puerto al exterior tienen que usar la opci\u00f3n <code>-p</code> para mapear puertos.</p> <p>Este tipo de red nos van a permitir:</p> <ul> <li>Aislar los distintos contenedores que tengo en distintas subredes docker, de tal manera que desde cada una de las subredes solo podremos acceder a los equipos de esa misma subred.</li> <li>Aislar los contenedores del acceso exterior.</li> <li>Publicar servicios que tengamos en los contenedores mediante redirecciones que docker implementar\u00e1 con las pertinentes reglas de iptables.</li> </ul> <p></p> </li> <li> <p>Si conecto un contenedor a la red host, el contenedor ofrece el servicio que tiene configurado en el puerto de la red del anfitri\u00f3n. No tiene ip propia, sino es c\u00f3mo si tuviera la ip del anfitri\u00f3n. Por lo tanto, los puertos son accesibles directamente desde el host. Por ejemplo:</p> <p>```   $ docker run -d --name mi_servidor --network host josedom24/aplicacionweb:v1</p> <p>$ docker ps   CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS               NAMES   135c742af1ff        josedom24/aplicacionweb:v1   \"/usr/sbin/apache2ct\u2026\"   3 seconds ago       Up 2 seconds                                  mi_servidor ```</p> <p>Prueba acceder directamente al puerto 80 del servidor para ver la p\u00e1gina web.</p> </li> <li> <p>La red none no configurar\u00e1 ninguna IP para el contenedor y no tiene acceso a la red externa ni a otros contenedores. Tiene la direcci\u00f3n loopback y se puede usar para ejecutar trabajos por lotes.</p> </li> </ul>"},{"location":"07.-Redes/03.-Gestionando%20redes%20en%20docker/","title":"03.-Gestionando redes en docker","text":"<p>Tenemos que hacer una diferenciaci\u00f3n entre dos tipos de redes bridge:</p> <ul> <li>La red creada por defecto por docker para que funcionen todos los contenedores.</li> <li>Y las redes \u201cbridge\u201d definidas por el usuario.</li> </ul> <p>Esta red \u201cbridge\u201d por defecto, que es la usada por defecto por los contenedores, se diferencia en varios aspectos de las redes \u201cbridge\u201d que creamos nosotros. Estos aspectos son los siguientes:</p> <ul> <li>Las redes que nosotros definamos proporcionan resoluci\u00f3n DNS entre los contenedores, cosa que la red por defecto no hace a no ser que usemos opciones que ya se consideran obsoletas (\u201cdeprectated\u201d) (<code>--link</code>).</li> <li>Puedo conectar en caliente a los contenedores redes \u201cbridge\u201d definidas por el usuario. Si uso la red por defecto tengo que parar previamente el contenedor.</li> <li>Me permite gestionar de manera m\u00e1s segura el aislamiento de los contenedores, ya que si no indico una red al arrancar un contenedor \u00e9ste se incluye en la red por defecto donde pueden convivir servicios que no tengan nada que ver.</li> <li>Tengo m\u00e1s control sobre la configuraci\u00f3n de las redes si las defino yo. Los contenedores de la red por defecto comparten todos la misma configuraci\u00f3n de red (MTU, reglas ip tables etc\u2026).</li> <li>Los contenedores dentro de la red \u201cbridge\u201d por defecto comparten todos ciertas variables de entorno lo que puede provocar ciertos conflictos.</li> </ul> <p>En definitiva: Es importante que nuestro contenedores en producci\u00f3n se est\u00e9n ejecutando sobre una red definida por el usuario.</p> <p>Para gestionar las redes creadas por el usuario:</p> <ul> <li>docker network ls: Listado de las redes.</li> <li>docker network create: Creaci\u00f3n de redes. Ejemplos:<ul> <li><code>docker network create red1</code></li> <li><code>docker network create -d bridge --subnet 172.24.0.0/16 --gateway 172.24.0.1 red2</code></li> </ul> </li> <li>docker network rm/prune: Borrar redes. Teniendo en cuenta que no puedo borrar una red que tenga contenedores que la est\u00e9n usando. deber\u00e9 primero borrar los contenedores o desconectar la red.</li> <li>docker network inspect: Nos da informaci\u00f3n de la red.</li> </ul> <p>Nota: Cada red docker que creo crea un puente de red espec\u00edfico para cada red que podemos ver con <code>ip a</code>:</p> <p></p>"},{"location":"07.-Redes/04.-Uso%20de%20la%20red%20bridge%20por%20defecto/","title":"04.-Uso de la red bridge por defecto","text":"<p>Esta manera en enlazar contenedores no est\u00e1 recomendada y esta obsoleta. Adem\u00e1s el uso de contenedores conectados a la red por defecto no est\u00e1 recomendado en entornos de producci\u00f3n. Para realizar este tipo de enlace vamos a usar el flag <code>--link</code>. Si hemos comentado que no se suele usar. \u00bfPor qu\u00e9 lo vamos a explicar?: La raz\u00f3n es que en la documentaci\u00f3n de las im\u00e1genes en DockerHub se suele explicar el enlazado de contenedores usando esta opci\u00f3n.</p> <p>Veamos un ejemplo, primero creamos un contenedor de mariadb:</p> <pre><code>$ docker run -d --name servidor_mariadb \\\n                -e MYSQL_DATABASE=mi_basededatos \\\n                -e MYSQL_USER=usuario \\\n                -e MYSQL_PASSWORD=asdasd \\\n                -e MYSQL_ROOT_PASSWORD=asdasd \\\n                mariadb\n</code></pre> <p>A continuaci\u00f3n vamos a crear un nuevo contenedor, enlazado con el contenedor anterior:</p> <pre><code>$ docker run -d --name servidor_web --link servidor_mariadb:mariadb nginx\n</code></pre> <p>Para realizar la asociaci\u00f3n entre contenedores (realmente estamos enlazando el contenedor <code>servidor_web</code> al <code>servidor_mariadb</code>) hemos utilizado el par\u00e1metro <code>--link</code>, donde se indica el nombre del contenedor enlazado y un alias por el que nos podemos referir a \u00e9l. Normalmente las aplicaciones utilizan el nombre del alias que hemos indicado para conectarse al otro contenedor. En este tipo de enlace tenemos dos caracter\u00edsticas:</p> <ul> <li>El contenedor al que hemos enlazado es conocido por resoluci\u00f3n est\u00e1tica</li> </ul> <p>El contenedor modifica el fichero <code>/etc/hosts</code> para que tengamos resoluci\u00f3n est\u00e1tica del contenedor enlazado. Podemos comprobarlo:</p> <pre><code>$ docker exec servidor_web cat /etc/hosts\n...\n172.17.0.2  mariadb c76089892798 servidor_mariadb\n</code></pre> <p>Podemos comprobar que el servidor DNS del contenedor, es el mismo que tiene nuestro host, por lo tanto la resoluci\u00f3n no se hace desde un servidor DNS:</p> <pre><code>$ docker exec servidor_web cat /etc/resolv.conf\n...\nnameserver 192.168.121.1\n</code></pre> <p>El servidor DNS <code>192.168.121.1</code> es el que tiene configurado mi ordenador donde tengo instalado docker.</p> <ul> <li>Se comparten las variables de entorno</li> </ul> <p>Las variables de entorno del contenedor enlazado son accesibles desde el contenedor. Por cada asociaci\u00f3n de contenedores, docker crea una serie de variables de entorno, en este caso, en el contenedor servidor, se crear\u00e1n las siguientes variables, donde se utiliza el nombre del alias indicada en el par\u00e1metro <code>--link</code>:</p> <pre><code>$ docker exec servidor_web env\n...\nMARIADB_PORT=tcp://172.17.0.2:3306\nMARIADB_PORT_3306_TCP=tcp://172.17.0.2:3306\nMARIADB_PORT_3306_TCP_ADDR=172.17.0.2\nMARIADB_PORT_3306_TCP_PORT=3306\nMARIADB_PORT_3306_TCP_PROTO=tcp\nMARIADB_NAME=/servidor/mariadb\nMARIADB_ENV_MYSQL_USER=usuario\nMARIADB_ENV_MYSQL_PASSWORD=asdasd\nMARIADB_ENV_MYSQL_ROOT_PASSWORD=asdasd\nMARIADB_ENV_MYSQL_DATABASE=mi_basededatos\nMARIADB_ENV_GOSU_VERSION=1.10\nMARIADB_ENV_GPG_KEYS=177F4010FE56CA3336300305F1656F24C74CD1D8\nMARIADB_ENV_MARIADB_MAJOR=10.4\nMARIADB_ENV_MARIADB_VERSION=1:10.4.11+maria~bionic\n</code></pre>"},{"location":"07.-Redes/05.-Uso%20de%20las%20redes%20bridge%20definidas%20por%20el%20usuario/","title":"05.-Uso de las redes bridge definidas por el usuario","text":"<p>Vamos a crear una red tipo bridge definida por el usuario con la instrucci\u00f3n <code>docker network create</code>:</p> <pre><code>$ docker network create red1\n\n</code></pre> <p>Como no hemos indicado ninguna configuraci\u00f3n en la red que hemos creado, docker asigna un direccionamiento a la red:</p> <pre><code>$ docker network inspect red1\n[\n    {\n        \"Name\": \"red1\",\n        ...\n            \"Config\": [\n                {\n                    \"Subnet\": \"172.18.0.0/16\",\n                    \"Gateway\": \"172.18.0.1\"\n                }\n            ]\n        },\n        ...\n]\n</code></pre> <p>Vamos a crear dos contenedores conectados a dicha red:</p> <pre><code>$ docker run -d --name my-apache-app --network red1 -p 8080:80 httpd:2.4\n</code></pre> <p>Lo primero que vamos a comprobar es la resoluci\u00f3n DNS:</p> <pre><code>$ docker run -it --name contenedor1 --network red1 debian bash\nroot@98ab5a0c2f0c:/# apt update &amp;&amp; apt install dnsutils -y\n...\nroot@98ab5a0c2f0c:/# dig my-apache-app\n...\n;; ANSWER SECTION:\nmy-apache-app.      600 IN  A   172.18.0.2\n...\n;; SERVER: 127.0.0.11#53(127.0.0.11)\n...\n</code></pre> <p>Podemos comprobar la configuraci\u00f3n DNS del contenedor:</p> <pre><code>root@98ab5a0c2f0c:/# cat /etc/resolv.conf \nnameserver 127.0.0.11\n...\n</code></pre> <p>Evidentemente desde los dos contenedores se pueden resolver los dos nombres:</p> <pre><code>root@98ab5a0c2f0c:/# dig contenedor1\n...\n;; ANSWER SECTION:\ncontenedor1.        600 IN  A   172.18.0.3\n...\n;; SERVER: 127.0.0.11#53(127.0.0.11)\n...\n</code></pre>"},{"location":"07.-Redes/05.-Uso%20de%20las%20redes%20bridge%20definidas%20por%20el%20usuario/#conectando-los-contenedores-a-otras-redes","title":"Conectando los contenedores a otras redes","text":"<p>A continuaci\u00f3n vamos a crear otra red bridge, pero vamos a indicar el direccionamiento:</p> <pre><code>$ docker network create red2 --subnet 192.168.100.0/24 --gateway 192.168.100.1\n</code></pre> <p>Creamos un contenedor conectado a esta nueva red y comprobamos que no hay conectividad con los dos anteriores:</p> <pre><code>$ docker run -it --name contenedor2 --network red2 debian bash\nroot@f9c7ac830a18:/# ip a\n...\n    inet 192.168.100.2/24 brd 192.168.100.255 scope global eth0\n...\nroot@f9c7ac830a18:/# ping contenedor1\nping: contenedor1: Name or service not known\n</code></pre> <p>Ahora podemos probar como podemos conectar un contenedor a una red. Para conectar usaremos <code>docker network connect</code> y para desconectarla usaremos <code>docker network disconnect</code>.</p> <pre><code>$ docker network connect red2 contenedor1 \n\n$ docker start contenedor1\ncontenedor1\n\n$ docker start contenedor2\ncontenedor2\n\n$ docker attach contenedor1\nroot@98ab5a0c2f0c:/# ip a\n...\n46: eth0@if47: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default\n    ...\n    inet 172.18.0.3/16 brd 172.18.255.255 scope global eth0\n...\n48: eth1@if49: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default \n...    \n    inet 192.168.100.2/24 brd 192.168.100.255 scope global eth1\n...\nroot@98ab5a0c2f0c:/# ping contenedor2\nPING contenedor2 (192.168.100.3) 56(84) bytes of data.\n64 bytes from contenedor2.red2 (192.168.100.3): icmp_seq=1 ttl=64 time=0.082 ms\n...\n</code></pre> <p>Evidentemente desde el <code>contenedor2</code> tambi\u00e9n tenemos conectividad a contenedor1, pero evidentemente no al contenedor <code>my-apache-app</code>:</p> <pre><code>$ docker attach contenedor2\nroot@f9c7ac830a18:/# ping contenedor1\nPING contenedor1 (192.168.100.2) 56(84) bytes of data.\n64 bytes from contenedor1.red2 (192.168.100.2): icmp_seq=1 ttl=64 time=0.072 ms\n...\nroot@f9c7ac830a18:/# ping my-apache-app\nping: my-apache-app: Name or service not known\n</code></pre>"},{"location":"07.-Redes/05.-Uso%20de%20las%20redes%20bridge%20definidas%20por%20el%20usuario/#mas-opciones-al-trabajar-con-redes-en-docker","title":"M\u00e1s opciones al trabajar con redes en docker","text":"<p>Tanto al crear un contenedor con el flag <code>--network</code>, como con la instrucci\u00f3n <code>docker network connect</code>, podemos usar algunos otros flags:</p> <ul> <li><code>--dns</code>: para establecer unos servidores DNS predeterminados.</li> <li><code>--ip</code>: Para establecer una ip fija en el contenedor.</li> <li><code>--ip6</code>: para establecer la direcci\u00f3n de red ipv6</li> <li><code>--hostname</code> o <code>-h</code>: para establecer el nombre de host del contenedor. Si no lo establezco ser\u00e1 el ID del mismo.</li> <li><code>--add-host</code>: a\u00f1ade entradas de nuevos hosts en el fichero <code>/etc/hosts</code></li> </ul> <p>Veamos un ejemplo:</p> <p>Primero creamos una red:</p> <pre><code>$ docker network create --subnet 192.168.100.0/24 red3\n</code></pre> <p>Y creamos un contenedor conectado a esta red con algunos par\u00e1metros extras:</p> <pre><code>$ docker run -it --name contenedor --network red3 \\\n                                   --ip 192.168.100.10 \\\n                                   --add-host=testing.example.com:192.168.100.20 \\\n                                   --dns 8.8.8.8 \\\n                                   --hostname servidor1 \\\n                                   debian\n</code></pre> <p>Como hemos comentado anteriormente estos par\u00e1metros tambi\u00e9n lo podemos usar al conectar un contenedor a una red con <code>docker network connect</code>. Veamos con detenimiento cada uno de los par\u00e1metros:</p> <ul> <li><code>--hostname servidor1</code>: Indicamos el nombre de la m\u00e1quina. Lo comprobamos:</li> </ul> <pre><code>root@servidor1:/# cat /etc/hostname \nservidor1\n</code></pre> <ul> <li><code>--ip 192.168.100.10</code>: Nos permite poner una ip fija en el contenedor. Vamos a comprobarlo:</li> </ul> <pre><code>root@servidor1:/# ip a\n...\n25: eth0@if26: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default \n    ...\n    inet 192.168.100.10/24 brd 192.168.100.255 scope global eth0\n    ...\n</code></pre> <ul> <li><code>--add-host=testing.example.com:192.168.100.20</code>: A\u00f1adimos un nuevos host como resoluci\u00f3n est\u00e1tica. Lo comprobamos:</li> </ul> <pre><code>root@servidor1:/# cat /etc/hosts\n...\n192.168.100.20  testing.example.com\n192.168.100.10  servidor1\n\nroot@servidor1:/# ping testing.example.com\nPING testing.example.com (192.168.100.20) 56(84) bytes of data.\n...\n</code></pre> <ul> <li><code>--dns 8.8.8.8</code>: Hemos configurado como DNS el servidor <code>8.8.8.8</code>. Veamos esto con detenimiento, como hemos visto anteriormente al conectar el contenedor a una red bridge definida por el usuario se crea un servidor DNS que nos permite la resoluci\u00f3n por el nombre del contenedor (par\u00e1metro <code>--name</code>, no se resuelve el nombre que hayamos indicado con el par\u00e1metro <code>--hostname</code>), veamos el servidor DNS:</li> </ul> <pre><code>root@servidor1:/# cat /etc/resolv.conf \nnameserver 127.0.0.11\n...\n</code></pre> <p>Por defecto este servidor hace forward con el servidor DNS que tenga configurado el anfitri\u00f3n (es decir usa el DNS del anfitri\u00f3n para resolver los nombre que no conoce). Con la opci\u00f3n <code>--dns 8.8.8.8</code>, estamos cambiando el DNS al que hacemos forwarding, por lo tanto ese cambio no se visualizar en el fichero <code>/etc/resolv.conf</code>.</p>"},{"location":"07.-Redes/06.-Convertir%20el%20uso%20de%20la%20red%20bridge%20por%20defecto%20por%20una%20definida%20por%20el%20usuario/","title":"06.-Convertir el uso de la red bridge por defecto por una definida por el usuario","text":"<p>Hemos comentado que en muchos de las descripciones de las im\u00e1genes que encontramos en Docker Hub se sigue utilizando el par\u00e1metro <code>--link</code> para enlazar los contenedores que se conectan en la red bridge por defecto.</p> <p>Por ejemplo, vamos a estudiar la imagen <code>sdelements/lets-chat</code> que nos permite ejecutar una aplicaci\u00f3n desarrollado con node.js y que implementa un chat. Esta aplicaci\u00f3n usa una base de datos mongodb para guardar los datos.</p> <p>Si nos fijamos en la documentaci\u00f3n de la imagen, nos pone la siguiente instrucci\u00f3n para crear el contenedor a partir de la imagen:</p> <pre><code>$ docker run  --name some-letschat --link some-mongo:mongo -p 8080:8080 -d sdelements/lets-chat\n</code></pre> <p>Estamos suponiendo que tenemos un contenedor llamado <code>some-mongo</code> creada a partir de la imagen <code>mongo</code> que esta sirviendo la base de datos:</p> <pre><code>$ docker run -d --name some-mongo mongo\n</code></pre> <p>El contenedor <code>some-letschat</code> se enlaza con el contenedor <code>some-mongo</code> con el par\u00e1metro <code>--link some-mongo:mongo</code>, es decir el contenedor de la aplicaci\u00f3n podr\u00e1 hacer referencia (por resoluci\u00f3n est\u00e1tica) al servidor de base de datos por los dos nombres: el nombre del contenedor <code>some-mongo</code> y el alias que hemos creado <code>mongo</code>. C\u00f3mo coment\u00e1bamos anteriormente el nombre de alias es el que se usa internamente por la aplicaci\u00f3n para conectar con la base de datos.</p>"},{"location":"07.-Redes/06.-Convertir%20el%20uso%20de%20la%20red%20bridge%20por%20defecto%20por%20una%20definida%20por%20el%20usuario/#usando-una-red-bridge-por-defecto","title":"Usando una red bridge por defecto","text":"<p>Vamos a estudiar c\u00f3mo podemos realizar este despliegue usando una red bridge definida por el usuario. En este caso, los contenedores que conectaremos a esa nueva red tendr\u00e1n resoluci\u00f3n DNs usando los nombres de los contenedores. Por lo tanto, como sabemos que la aplicaci\u00f3n usa el nombre del alias (<code>mongo</code>) para conectarse al otro contenedor, lo \u00fanico que tenemos que hacer es poner ese mismo nombre al contenedor de la base de datos.</p> <p>Creamos una red bridge definida por el usuario:</p> <pre><code>$ docker network create red_letschat\n</code></pre> <p>Creamos el contenedor de la base de datos conectado a la nueva red, haciendo coincidir el nombre con el alias que pon\u00edamos anteriormente con el par\u00e1metro <code>--link</code>:</p> <pre><code>$ docker run -d --network red_letschat --name mongo mongo\n</code></pre> <p>Y el contenedor de la aplicaci\u00f3n conectado a la nueva red:</p> <pre><code>$ docker run --name some-letschat --network red_letschat -p 8080:8080 -d sdelements/lets-chat\n</code></pre> <p></p>"},{"location":"07.-Redes/07.-Ejemplos/","title":"Ejemplo 1: Despliegue de la aplicaci\u00f3n Guestbook","text":"<p>En este ejemplo vamos a desplegar una aplicaci\u00f3n web que requiere de dos servicios (servicio web y servicio de base de datos) para su ejecuci\u00f3n. La aplicaci\u00f3n se llama GuestBook y necesita los dos siguientes servicios:</p> <ul> <li>La aplicaci\u00f3n guestbook es una aplicaci\u00f3n web desarrollada en python que es servida por el puerto 5000/tcp. Utilizaremos la imagen <code>iesgn/guestbook</code>.</li> <li>Esta aplicaci\u00f3n guarda la informaci\u00f3n en una base de datos no relacional redis, que utiliza el puerto 6379/tcp para conectarnos. Usaremos la imagen <code>redis</code>.</li> </ul> <p>La aplicaci\u00f3n guestbook por defecto utiliza el nombre <code>redis</code> para conectarse a la base de datos, por lo tanto debemos nombrar al contenedor redis con ese nombre para que tengamos una resoluci\u00f3n de nombres adecuada.</p> <p>Los dos contenedores tienen que estar en la misma red y deben tener acceso por nombres (resoluci\u00f3n DNS) ya que de principio no sabemos que ip va a coger cada contenedor. Por lo tanto vamos a crear los contenedores en la misma red:</p> <pre><code>$ docker network create red_guestbook\n</code></pre> <p>Para ejecutar los contenedores:</p> <pre><code>$ docker run -d --name redis --network red_guestbook redis\n\n$ docker run -d -p 80:5000 --name guestbook --network red_guestbook iesgn/guestbook\n</code></pre> <p>Algunas observaciones:</p> <ul> <li>No es necesario mapear el puerto de <code>redis</code>, ya que no vamos a acceder desde el exterior. Sin embargo la aplicaci\u00f3n <code>guestbook</code> va a poder acceder a la base de datos porque est\u00e1n conectado a la misma red.</li> <li>Al nombrar al contenedor de la base de datos con <code>redis</code> se crea una entrada en el DNS que resuelve ese nombre con la ip del contenedor. Como hemos indicado, por defecto, la aplicaci\u00f3n guestbook usa ese nombre para acceder.</li> </ul> <p></p>"},{"location":"07.-Redes/07.-Ejemplos/#ejemplo-2-despliegue-de-la-aplicacion-temperaturas","title":"Ejemplo 2: Despliegue de la aplicaci\u00f3n Temperaturas","text":"<p>Vamos a hacer un despliegue completo de una aplicaci\u00f3n llamada Temperaturas. Esta aplicaci\u00f3n nos permite consultar la temperatura m\u00ednima y m\u00e1xima de todos los municipios de Espa\u00f1a. Esta aplicaci\u00f3n est\u00e1 formada por dos microservicios:</p> <ul> <li><code>frontend</code>: Es una aplicaci\u00f3n escrita en Python que nos ofrece una p\u00e1gina web para hacer las b\u00fasquedas y visualizar los resultados. Este microservicio har\u00e1 peticiones HTTP al segundo microservicio para obtener la informaci\u00f3n. Este microservicio ofrece el servicio en el puerto 3000/tcp. Usaremos la imagen <code>iesgn/temperaturas_frontend</code>.</li> <li><code>backend</code>: Es el segundo microservicio que nos ofrece un servicio web de tipo API Restful. A esta API Web podemos hacerles consultas sobre los municipios y sobre las temperaturas. En este caso, se utiliza el puerto 5000/tcp para ofrecer el servicio. Usaremos la imagen <code>iesgn/temperaturas_backend</code>.</li> </ul> <p>El microservicio <code>frontend</code> se conecta a <code>backend</code> usando el nombre <code>temperaturas-backend</code>. Por lo tanto el contenedor con el micorservicio <code>backend</code> tendr\u00e1 ese nombre para disponer de una resoluci\u00f3n de nombres adecuada en el dns.</p> <p>Vamos a crear una red para conectar los dos contenedores:</p> <pre><code>$ docker network create red_temperaturas\n</code></pre> <p>Para ejecutar los contenedores:</p> <pre><code>$ docker run -d --name temperaturas-backend --network red_temperaturas iesgn/temperaturas_backend\n\n$ docker run -d -p 80:3000 --name temperaturas-frontend --network red_temperaturas iesgn/temperaturas_frontend\n</code></pre> <p>Algunas observaciones:</p> <ul> <li>Este es un tipo de aplicaci\u00f3n, que se caracteriza por no necesitar guardar informaci\u00f3n para su funcionamiento. Son las denominadas aplicaciones sin estado, por lo tanto no necesitamos almacenamiento adicional para la aplicaci\u00f3n.</li> <li>No es necesario mapear el puerto de <code>backend</code>, ya que no vamos a acceder desde el exterior. Sin embargo el microservicio <code>frontend</code> va a poder acceder a <code>backend</code> al puerto 5000 porque est\u00e1n conectado a la misma red.</li> <li>Al nombrar al contenedor de la base de datos con <code>temperaturas-backend</code> se crea una entrada en el DNS que resuelve ese nombre con la ip del contenedor. Como hemos indicado, por defecto, el microservicio <code>frontend</code> usa ese nombre para acceder.</li> </ul> <p></p>"},{"location":"07.-Redes/07.-Ejemplos/#ejemplo-3-despliegue-de-wordpress-mariadb","title":"Ejemplo 3: Despliegue de Wordpress + mariadb","text":"<p>Para la instalaci\u00f3n de WordPress necesitamos dos contenedores: la base de datos (imagen <code>mariadb</code>) y el servidor web con la aplicaci\u00f3n (imagen <code>wordpress</code>). Los dos contenedores tienen que estar en la misma red y deben tener acceso por nombres (resoluci\u00f3n DNS) ya que de principio no sabemos que ip va a coger cada contenedor. Por lo tanto vamos a crear los contenedores en la misma red:</p> <pre><code>$ docker network create red_wp\n</code></pre> <p>Siguiendo la documentaci\u00f3n de la imagen mariadb y la imagen wordpress podemos ejecutar los siguientes comandos para crear los dos contenedores:</p> <pre><code>$ docker run -d --name servidor_mysql \\\n                --network red_wp \\\n                -v /opt/mysql_wp:/var/lib/mysql \\\n                -e MYSQL_DATABASE=bd_wp \\\n                -e MYSQL_USER=user_wp \\\n                -e MYSQL_PASSWORD=asdasd \\\n                -e MYSQL_ROOT_PASSWORD=asdasd \\\n                mariadb\n\n$ docker run -d --name servidor_wp \\\n                --network red_wp \\\n                -v /opt/wordpress:/var/www/html/wp-content \\\n                -e WORDPRESS_DB_HOST=servidor_mysql \\\n                -e WORDPRESS_DB_USER=user_wp \\\n                -e WORDPRESS_DB_PASSWORD=asdasd \\\n                -e WORDPRESS_DB_NAME=bd_wp \\\n                -p 80:80 \\\n                wordpress\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES\n5b2c5a82a524        wordpress           \"docker-entrypoint.s\u2026\"   9 minutes ago       Up 9 minutes        0.0.0.0:80-&gt;80/tcp   servidor_wp\nf70f22aed3d1        mariadb             \"docker-entrypoint.s\u2026\"   9 minutes ago       Up 9 minutes        3306/tcp             servidor_mysql\n</code></pre> <p>Algunas observaciones:</p> <ul> <li>El contenedor <code>servidor_mysql</code> ejecuta un script <code>docker-entrypoint.sh</code> que es el encargado, a partir de las variables de entorno, configurar la base de datos: crea usuario, crea base de datos, cambia la contrase\u00f1a del usuario root,\u2026 y termina ejecutando el servidor mariadb.</li> <li>Al crear la imagen <code>mariadb</code> han tenido en cuenta de que tiene que permitir la conexi\u00f3n desde otra m\u00e1quina, por lo que en la configuraci\u00f3n tenemos comentado el par\u00e1metro <code>bind-address</code>.</li> <li>Del mismo modo el contenedor <code>servidor_wp</code> ejecuta un script <code>docker-entrypoint.sh</code>, que entre otras cosas, a partir de las variables de entorno, ha creado el fichero <code>wp-config.php</code> de wordpress, por lo que durante la instalaci\u00f3n no te ha pedido las credenciales de la base de datos.</li> <li>Si te das cuenta la variable de entorno <code>WORDPRESS_DB_HOST</code> la hemos inicializado al nombre del servidor de base de datos. Como est\u00e1n conectada a la misma red definida por el usuario, el contenedor wordpress al intentar acceder al nombre <code>servidor_mysql</code> estar\u00e1 accediendo al contenedor de la base de datos.</li> <li>Al servicio al que vamos a acceder desde el exterior es al servidor web, es por lo que hemos mapeado los puertos con la opci\u00f3n <code>-p</code>. Sin embargo en el contenedor de la base de datos no es necesario mapear los puertos porque no vamos a acceder a ella desde el exterior. Sin embargo, el contenedor <code>servidor_wp</code> puede acceder al puerto 3306 del <code>servidor_mysql</code> sin problemas ya que est\u00e1n conectados a la misma red.</li> </ul> <p></p>"},{"location":"07.-Redes/07.-Ejemplos/#ejemplo-4-despliegue-de-tomcat-nginx","title":"Ejemplo 4: Despliegue de tomcat + nginx","text":"<p>En este ejemplo vamos a desplegar una aplicaci\u00f3n muy sencilla en un servidor de aplicaci\u00f3n Tomcat, a la que accederemos utilizando un proxy inverso nginx. En este ejercicio, adem\u00e1s de seguir trabajando con las redes de tipo bridge definida por el usuario, vamos a usar bind mount para montar los ficheros de configuraci\u00f3n y de despliegue en los contenedores.</p>"},{"location":"07.-Redes/07.-Ejemplos/#desplegando-tomcat","title":"Desplegando tomcat","text":"<p>Antes de hacer el despliegue del primer contenedor, vamos a crear una red bridge para conectar los contenedores:</p> <pre><code>$ docker network create red_tomcat\n</code></pre> <p>A continuaci\u00f3n vamos a crear un contenedor a partir de la imagen <code>tomcat</code>. En la documentaci\u00f3n podemos ver que el directorio <code>/usr/local/tomcat/webapps/</code> es donde tenemos que poner el fichero de despliegue <code>war</code> (vamos a usar bind mount para montar el fichero war en el directorio). No vamos a mapear puerto porque no vamos a acceder a este contenedor desde el exterior.</p> <p>Tenemos un directorio donde tenemos el fichero war (puedes encontrar estos ficheros en el repositorio github):</p> <pre><code>$ cd tomcat\n~/tomcat$ ls\ndefault.conf  sample.war\n</code></pre> <p>Y creamos el contenedor conectada a nuestra nueva red:</p> <pre><code>$ docker run -d --name aplicacionjava \\\n                --network red_tomcat \\\n                -v /home/vagrant/tomcat/sample.war:/usr/local/tomcat/webapps/sample.war:ro \\\n                tomcat:9.0\n</code></pre>"},{"location":"07.-Redes/07.-Ejemplos/#desplegando-nginx-como-proxy-inverso","title":"Desplegando nginx como proxy inverso","text":"<p>Como vimos anteriormente en el directorio de trabajo tenemos tambi\u00e9n la configuraci\u00f3n de nginx para que funcione como proxy inverso:</p> <pre><code>server {\n    listen       80;\n    listen  [::]:80;\n    server_name  localhost;\n\n    location / {\n        root   /usr/share/nginx/html;\n    proxy_pass http://aplicacionjava:8080/sample/;\n    }\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n}\n</code></pre> <p>Como vemos para realizar el proxy inverso usamos la directiva <code>proxy_pass</code>indicando la direcci\u00f3n que nos ofrece tomcat, en este caso usamos el nombre del contenedor anterior (<code>aplicacionjava</code>) que ser\u00e1 resuelto por el servidor DNS interno, usando el puerto est\u00e1ndar de tomcat el 8080 y el directorio <code>sample</code> donde se ha desplegado la aplicaci\u00f3n. Para la creaci\u00f3n del contenedor de nginx:</p> <pre><code>$ docker run -d --name proxy \\\n                -p 80:80 \\\n                --network red_tomcat \\\n                -v /home/vagrant/tomcat/default.conf:/etc/nginx/conf.d/default.conf:ro \\\n                nginx\n</code></pre> <p>Y al acceder la ip de nuestro host:</p> <p></p>"},{"location":"08.-Escenarios%20multicontenedor/01.-Instalaci%C3%B3n%20de%20docker-compose/","title":"01.-Instalaci\u00f3n de docker-compose","text":"<p>La manera m\u00e1s sencilla de realizar la instalaci\u00f3n de esta herramienta es utilizar el paquete de nuestra distribuci\u00f3n:</p> <pre><code>apt install docker-compose\n</code></pre> <p>Tambi\u00e9n se puede con <code>pip</code> en un entorno virtual:</p> <pre><code>python3 -m venv docker-compose\nsource docker-compose/bin/activate\n(docker-compose) ~# pip install docker-compose\n</code></pre> <p>Puedes acceder a la documentaci\u00f3n oficial para ver otras posibilidades de instalaci\u00f3n.</p>"},{"location":"08.-Escenarios%20multicontenedor/02.-El%20fichero%20docker-compose.yml/","title":"02.-El fichero docker-compose.yml","text":"<p>En el fichero <code>docker-compose.yml</code> vamos a definir el escenario. El programa docker-compose se debe ejecutar en el directorio donde este ese fichero. Por lo tanto tenderemos un directorio con un fichero <code>docker-compose.yml</code> para cada una las aplicaciones que queremos desplegar. Por ejemplo para la ejecuci\u00f3n de la aplicaci\u00f3n Let\u2019s Chat podr\u00edamos tener un fichero <code>docker-compose.yml</code>, dentro de una carpeta, con el siguiente contenido:</p> <pre><code>version: '3.1'\nservices:\n  app:\n    container_name: letschat\n    image: sdelements/lets-chat\n    restart: always\n    environment:\n      LCB_DATABASE_URI: mongodb://mongo/letschat\n    ports:\n      - 80:8080\n    depends_on:\n      - db\n  db:\n    container_name: mongo\n    image: mongo\n    restart: always\n    volumes:\n      - /opt/mongo:/data/db\n</code></pre> <p>Puedes encontrar todos los par\u00e1metros que podemos definir en la documentaci\u00f3n oficial.</p> <p>Algunos par\u00e1metros interesantes:</p> <ul> <li>Es escenario est\u00e1 formado por <code>services</code>. Cada uno ello va a crear un contenedor.</li> <li><code>restart: always</code>: Indicamos la pol\u00edtica de reinicio del contenedor si por cualquier condici\u00f3n se para. M\u00e1s informaci\u00f3n.</li> <li><code>depend on</code>: Indica la dependencia entre contenedores. No se va a iniciar un contenedor hasta que otro este funcionando. M\u00e1s informaci\u00f3n.</li> </ul> <p>Cuando creamos un escenario con <code>docker-compose</code> se crea una nueva red definida por el usuario donde se conectan los contenedores, por lo tanto, obtenemos resoluci\u00f3n por dns que resuelve tanto el nombre del contenedor (por ejemplo, <code>mongo</code>) como el nombre del servicio (por ejemplo, <code>db</code>).</p>"},{"location":"08.-Escenarios%20multicontenedor/03.-El%20comando%20docker-compose/","title":"03.-El comando docker-compose","text":"<p>Una vez hemos creado el archivo <code>docker-compose.yml</code> tenemos que empezar a trabajar con \u00e9l, es decir a crear los contenedores que describe su contenido.</p> <p>Esto lo haremos mediante el ejecutable <code>docker-compose</code>. Es importante destacar que debemos invocarla desde el directorio en el que se encuentra el fichero <code>docker-compose.yml</code>.</p> <p>Los subcomandos m\u00e1s usados son:</p> <ul> <li><code>docker-compose up</code>: Crear los contenedores (servicios) que est\u00e1n descritos en el <code>docker-compose.yml</code>.</li> <li><code>docker-compose up -d</code>: Crear en modo detach los contenedores (servicios) que est\u00e1n descritos en el <code>docker-compose.yml</code>. Eso significa que no muestran mensajes de log en el terminal y que se nos vuelve a mostrar un prompt.</li> <li><code>docker-compose stop</code>: Detiene los contenedores que previamente se han lanzado con <code>docker-compose up</code>.</li> <li><code>docker-compose run</code>: Inicia los contenedores descritos en el <code>docker-compose.yml</code> que est\u00e9n parados.</li> <li><code>docker-compose rm</code>: Borra los contenedores parados del escenario. Con las opci\u00f3n <code>-f</code> elimina tambi\u00e9n los contenedores en ejecuci\u00f3n.</li> <li><code>docker-compose pause</code>: Pausa los contenedores que previamente se han lanzado con <code>docker-compose up</code>.</li> <li><code>docker-compose unpause</code>: Reanuda los contenedores que previamente se han pausado.</li> <li><code>docker-compose restart</code>: Reinicia los contenedores. Orden ideal para reiniciar servicios con nuevas configuraciones.</li> <li><code>docker-compose down</code>: Para los contenedores, los borra y tambi\u00e9n borra las redes que se han creado con <code>docker-compose up</code> (en caso de haberse creado).</li> <li><code>docker-compose down -v</code>: Para los contenedores y borra contenedores, redes y vol\u00famenes.</li> <li><code>docker-compose logs</code>: Muestra los logs de todos los servicios del escenario. Con el par\u00e1metro <code>-f</code>podremos ir viendo los logs en \u201cvivo\u201d.</li> <li><code>docker-compose logs servicio1</code>: Muestra los logs del servicio llamado <code>servicio1</code> que estaba descrito en el <code>docker-compose.yml</code>.</li> <li><code>docker-compose exec servicio1 /bin/bash</code>: Ejecuta una orden, en este caso <code>/bin/bash</code> en un contenedor llamado <code>servicio1</code> que estaba descrito en el <code>docker-compose.yml</code></li> <li><code>docker-compose build</code>: Ejecuta, si est\u00e1 indicado, el proceso de construcci\u00f3n de una imagen que va a ser usado en el <code>docker-compose.yml</code> a partir de los ficheros <code>Dockerfile</code> que se indican.</li> <li><code>docker-compose top</code>: Muestra los procesos que est\u00e1n ejecut\u00e1ndose en cada uno de los contenedores de los servicios.</li> </ul>"},{"location":"08.-Escenarios%20multicontenedor/03.-El%20comando%20docker-compose/#despliegue-de-lets-chat","title":"Despliegue de Let\u2019s Chat","text":"<p>Para desplegar la aplicaci\u00f3n Let\u2019s Chat que vimos en el punto anterior, ejecutamos la siguiente instrucci\u00f3n en el directorio donde tengamos el fichero <code>docker-compose.yml</code>:</p> <pre><code>$ docker-compose up -d\nCreating network \"letschat_default\" with the default driver\nCreating mongo ... done\nCreating letschat ... done\n</code></pre> <p>Podemos ver los contenedores que se est\u00e1n ejecutando:</p> <pre><code>$ docker-compose ps\n  Name               Command             State               Ports             \n-------------------------------------------------------------------------------\nletschat   npm start                     Up      5222/tcp, 0.0.0.0:80-&gt;8080/tcp\nmongo      docker-entrypoint.sh mongod   Up      27017/tcp                   \n</code></pre> <p>Podemos acceder desde el navegador a la aplicaci\u00f3n:</p> <p></p> <p>Finalmente podemos destruir el escenario:</p> <pre><code>$ docker-compose down \nStopping letschat ... done\nStopping mongo   ... done\nRemoving letschat ... done\nRemoving mongo   ... done\nRemoving network letschat_default\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/04.-Almacenamiento%20con%20docker-compose/","title":"04.-Almacenamiento con docker-compose","text":""},{"location":"08.-Escenarios%20multicontenedor/04.-Almacenamiento%20con%20docker-compose/#definiendo-volumenes-docker-con-docker-compose","title":"Definiendo vol\u00famenes docker con docker-compose","text":"<p>Adem\u00e1s de definir los <code>services</code>, con docker-compose podemos definir los vol\u00famenes que vamos a necesitar en nuestra infraestructura. Adem\u00e1s, como hemos visto, podremos indicar que vol\u00famen va a utilizar cada contenedor.</p> <p>Veamos un ejemplo:</p> <pre><code>version: '3.1'\nservices:\n  db:\n    container_name: contenedor_mariadb\n    image: mariadb\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: asdasd\n    volumes:\n      - mariadb_data:/var/lib/mysql\nvolumes:\n    mariadb_data:\n</code></pre> <p>Y podemos iniciar el escenario:</p> <pre><code>$ docker-compose up -d\nCreating network \"docker-compose_default\" with the default driver\nCreating volume \"docker-compose_mariadb_data\" with default driver\nCreating contenedor_mariadb ... done\n\n$ docker-compose ps\n       Name                    Command             State    Ports  \n-------------------------------------------------------------------\ncontenedor_mariadb   docker-entrypoint.sh mysqld   Up      3306/tcp\n</code></pre> <p>Y comprobamos que se ha creado un nuevo volumen:</p> <pre><code>$ docker volume ls\nDRIVER    VOLUME NAME\nlocal     docker-compose_mariadb_data\n...\n</code></pre> <p>En la definici\u00f3n del servicio <code>db</code> hemos indicado que el contenedor montar\u00e1 el volumen en un directorio determinado con el par\u00e1metro <code>volumes</code>. Podemos comprobar que efectivamente se ha realizado el montaje:</p> <pre><code>$ docker inspect contenedor_mariadb\n...\n\"Mounts\": [\n    {\n        \"Type\": \"volume\",\n        \"Name\": \"docker-compose_mariadb_data\",\n        \"Source\": \"/var/lib/docker/volumes/docker-compose_mariadb_data/_data\",\n        \"Destination\": \"/var/lib/mysql\",\n        \"Driver\": \"local\",\n        \"Mode\": \"rw\",\n        \"RW\": true,\n        \"Propagation\": \"\"\n    }\n],\n...\n</code></pre> <p>Recuerda que si necesitas iniciar el escenario desde 0, debes eliminar el volumen:</p> <pre><code>$ docker-compose down -v\nStopping contenedor_mariadb ... done\nRemoving contenedor_mariadb ... done\nRemoving network docker-compose_default\nRemoving volume docker-compose_mariadb_data\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/04.-Almacenamiento%20con%20docker-compose/#utilizacion-de-bind-mount-con-docker-compose","title":"Utilizaci\u00f3n de bind mount con docker-compose","text":"<p>De forma similar podemos indicar que un contenedor va a utilizar bind mount como almacenamiento. En este caso ser\u00eda:</p> <pre><code>version: '3.1'\nservices:\n  db:\n    container_name: contenedor_mariadb\n    image: mariadb\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: asdasd\n    volumes:\n      - ./data:/var/lib/mysql\n</code></pre> <p>Y despu\u00e9s de iniciar el escenario podemos ver c\u00f3mo se ha creado el directorio <code>data</code>:</p> <pre><code>$ cd data/\n/data$ ls\naria_log.00000001  aria_log_control  ibdata1  ib_logfile0  ibtmp1  mysql\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/05.-Redes%20con%20docker-compose/","title":"05.-Redes con docker-compose","text":"<p>Como hemos indicado anteriormente, cuando creamos un escenario con <code>docker-compose</code> se crea una nueva red definida por el usuario donde se conectan los contenedores, por lo tanto, obtenemos resoluci\u00f3n por dns que resuelve tanto el nombre del contenedor, como el nombre del servicio.</p> <p>Sin embargo en el fichero <code>docker-compose.yaml</code> podemos definir y configurar las redes que necesitemos en nuestro escenario, as\u00ed como la conexi\u00f3n de los distintos contenedores a dichas redes.</p> <p>Veamos un ejemplo:</p> <pre><code>version: '3.1'\nservices:\n  app:\n    container_name: servidor_web\n    image: httpd:2.4\n    restart: always\n    ports:\n      - 8080:80\n    networks:\n      red_web:\n        ipv4_address: 192.168.10.10\n      red_interna:\n        ipv4_address: 192.168.20.10\n    hostname: servidor_web\n\n  db:\n    container_name: servidor_mariadb\n    image: mariadb\n    environment:\n      MYSQL_ROOT_PASSWORD: asdasd\n    restart: always\n    networks:\n      red_interna:\n        ipv4_address: 192.168.20.20\n    hostname: servidor_mariadb\nnetworks:\n    red_web:\n        ipam:\n            config:\n              - subnet: 192.168.10.0/24\n    red_interna:\n        ipam:\n            config:\n              - subnet: 192.168.20.0/24\n</code></pre> <p>Iniciamos el escenario:</p> <pre><code>$ docker-compose up -d\nCreating network \"docker-compose_red_web\" with the default driver\nCreating network \"docker-compose_red_interna\" with the default driver\nCreating servidor_mariadb ... done\nCreating servidor_web     ... done\n</code></pre> <p>Comprobamos que los dos contenedores se est\u00e1n ejecutando:</p> <pre><code>$ docker-compose ps\n      Name                   Command             State                  Ports                \n---------------------------------------------------------------------------------------------\nservidor_mariadb   docker-entrypoint.sh mysqld   Up      3306/tcp                            \nservidor_web       httpd-foreground              Up      0.0.0.0:8080-&gt;80/tcp,:::8080-&gt;80/tcp\n</code></pre> <p>Accedemos al servidor web e instalamos los paquetes necesarios para hacer las comprobaciones de configuraci\u00f3n de la red:</p> <pre><code>$ docker-compose exec app bash\nroot@servidor_web::/usr/local/apache2# apt-get update &amp;&amp; apt-get install -y inetutils-ping \\\n   iproute2 \\\n   dnsutils\n</code></pre> <p>Comprobamos que el hostname se ha configurado de manera adecuada:</p> <pre><code>root@servidor_web:/usr/local/apache2# cat /etc/hostname\nservidor_web\n</code></pre> <p>Comprobamos que el contenedor est\u00e1 conectado a las dos redes y tiene las direcciones que hemos indicado:</p> <pre><code>root@servidor_web:/usr/local/apache2# ip a\n...\n401: eth0@if402: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc \n...\n    inet 192.168.20.10/24 brd 192.168.20.255 scope global eth0\n...\n403: eth1@if404: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc \n...\n    inet 192.168.10.10/24 brd 192.168.10.255 scope global eth1\n</code></pre> <p>Comprobamos que tenemos resoluci\u00f3n DNS tanto con el nombre del servicio como con el nombre del contenedor:</p> <pre><code>root@servidor_web:/usr/local/apache2# dig servidor_mariadb\n\n...\n;; ANSWER SECTION:\nservidor_mariadb.   600 IN  A   192.168.20.20\n...\n\nroot@servidor_web:/usr/local/apache2# dig db\n\n...\n;; ANSWER SECTION:\ndb.         600 IN  A   192.168.20.20\n...\n</code></pre> <p>Y por \u00faltimos comprobamos que hay conectividad:</p> <pre><code>root@servidor_web:/usr/local/apache2# ping servidor_mariadb\nPING servidor_mariadb (192.168.20.20): 56 data bytes\n64 bytes from 192.168.20.20: icmp_seq=0 ttl=64 time=0.195 ms\n...\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/06.-Ejemplos/","title":"Ejemplo 1: Despliegue de la aplicaci\u00f3n guestbook","text":"<p>En este ejemplo vamos a desplegar con docker-compose la aplicaci\u00f3n guestbook, que estudiamos en el m\u00f3dulo de redes: Ejemplo 1: Despliegue de la aplicaci\u00f3n Guestbook.</p> <p>Puedes encontrar el fichero <code>docker-compose.yml</code> en en este directorio del repositorio.</p> <p>En el fichero <code>docker-compose.yml</code> vamos a definir el escenario. El programa <code>docker-compose</code> se debe ejecutar en el directorio donde este ese fichero.</p> <pre><code>version: '3.1'\nservices:\n  app:\n    container_name: guestbook\n    image: iesgn/guestbook\n    restart: always\n    ports:\n      - 80:5000\n  db:\n    container_name: redis\n    image: redis\n    restart: always\n</code></pre> <p>Para crear el escenario:</p> <pre><code>$ docker-compose up -d\nCreating network \"guestbook_default\" with the default driver\nCreating guestbook ... done\nCreating redis     ... done\n</code></pre> <p>Para listar los contenedores:</p> <pre><code>$ docker-compose ps\n  Name                 Command               State          Ports        \n-------------------------------------------------------------------------\nguestbook   python3 app.py                   Up      0.0.0.0:80-&gt;5000/tcp\nredis       docker-entrypoint.sh redis ...   Up      6379/tcp            \n</code></pre> <p>Para parar los contenedores:</p> <pre><code>$ docker-compose stop \nStopping guestbook    ... done\nStopping redis ... done\n</code></pre> <p>Para eliminar el escenario:</p> <pre><code>docker-compose down\nStopping guestbook ... done\nStopping redis     ... done\nRemoving guestbook ... done\nRemoving redis     ... done\nRemoving network guestbook_default\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/06.-Ejemplos/#ejemplo-2-despliegue-de-la-aplicacion-temperaturas","title":"Ejemplo 2: Despliegue de la aplicaci\u00f3n Temperaturas","text":"<p>En este ejemplo vamos a desplegar con docker-compose la aplicaci\u00f3n Temperaturas, que estudiamos en el m\u00f3dulo de redes: Ejemplo 2: Despliegue de la aplicaci\u00f3n Temperaturas.</p> <p>Puedes encontrar el fichero <code>docker-compose.yml</code> en en este directorio del repositorio.</p> <p>En este caso el fichero <code>docker-compose.yml</code> puede tener esta forma:</p> <pre><code>version: '3.1'\nservices:\n  frontend:\n    container_name: temperaturas-frontend\n    image: iesgn/temperaturas_frontend\n    restart: always\n    ports:\n      - 80:3000\n    depends_on:\n      - backend\n  backend:\n    container_name: temperaturas-backend\n    image: iesgn/temperaturas_backend\n    restart: always\n</code></pre> <p>Para crear el escenario:</p> <pre><code>$ docker-compose up -d\nCreating network \"temperaturas_default\" with the default driver\nCreating temperaturas-backend ... done\nCreating temperaturas-frontend ... done\n\n</code></pre> <p>Para listar los contenedores:</p> <pre><code>$ docker-compose ps\n---------------------------------------------------------------------\ntemperaturas-backend    python3 app.py   Up      5000/tcp            \ntemperaturas-frontend   python3 app.py   Up      0.0.0.0:80-&gt;3000/tcp\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/06.-Ejemplos/#ejemplo-3-despliegue-de-wordpress-mariadb","title":"Ejemplo 3: Despliegue de WordPress + Mariadb","text":"<p>En este ejemplo vamos a desplegar con docker-compose la aplicaci\u00f3n WordPress + MariaDB, que estudiamos en el m\u00f3dulo de redes: Ejemplo 3: Despliegue de Wordpress + mariadb .</p> <p>Puedes encontrar los ficheros <code>docker-compose.yml</code> en este directorio del repositorio.</p>"},{"location":"08.-Escenarios%20multicontenedor/06.-Ejemplos/#utilizando-volumenes-docker","title":"Utilizando vol\u00famenes docker","text":"<p>Por ejemplo para la ejecuci\u00f3n de wordpress persistente con vol\u00famenes docker podr\u00edamos tener un fichero <code>docker-compose.yml</code> con el siguiente contenido:</p> <pre><code>version: '3.1'\nservices:\n  wordpress:\n    container_name: servidor_wp\n    image: wordpress\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: user_wp\n      WORDPRESS_DB_PASSWORD: asdasd\n      WORDPRESS_DB_NAME: bd_wp\n    ports:\n      - 80:80\n    volumes:\n      - wordpress_data:/var/www/html/wp-content\n  db:\n    container_name: servidor_mysql\n    image: mariadb\n    restart: always\n    environment:\n      MYSQL_DATABASE: bd_wp\n      MYSQL_USER: user_wp\n      MYSQL_PASSWORD: asdasd\n      MYSQL_ROOT_PASSWORD: asdasd\n    volumes:\n      - mariadb_data:/var/lib/mysql\nvolumes:\n    wordpress_data:\n    mariadb_data:\n</code></pre> <p>Para crear el escenario:</p> <pre><code>$ docker-compose up -d\nCreating network \"wp_default\" with the default driver\nCreating servidor_wp    ... done\nCreating servidor_mysql ... done\n</code></pre> <p>Para listar los contenedores:</p> <pre><code>$ docker-compose ps\n     Name                   Command               tate         Ports       \n---------------------------------------------------------------------------\nservidor_mysql   docker-entrypoint.sh mysqld      Up      306/tcp          \nservidor_wp      docker-entrypoint.sh apach ...   Up      0.0.0.0:80-&gt;80/tcp\n</code></pre> <p>Para parar los contenedores:</p> <pre><code>$ docker-compose stop \nStopping servidor_wp    ... done\nStopping servidor_mysql ... done\n</code></pre> <p>Para borrar los contenedores:</p> <pre><code>$ docker-compose rm\nGoing to remove servidor_wp, servidor_mysql\nAre you sure? [yN] y\nRemoving servidor_wp    ... done\nRemoving servidor_mysql ... done\n</code></pre> <p>Para eliminar el escenario (contenedores, red y vol\u00famenes):</p> <pre><code>$ docker-compose down -v\nStopping servidor_mysql ... done\nStopping servidor_wp    ... done\nRemoving servidor_mysql ... done\nRemoving servidor_wp    ... done\nRemoving network volumen_default\nRemoving volume volumen_wordpress_data\nRemoving volume volumen_mariadb_data\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/06.-Ejemplos/#utilizando-bind-mount","title":"Utilizando bind-mount","text":"<p>Por ejemplo para la ejecuci\u00f3n de wordpress persistente con bind mount podr\u00edamos tener un fichero <code>docker-compose.yml</code> con el siguiente contenido:</p> <pre><code>version: '3.1'\nservices:\n  wordpress:\n    container_name: servidor_wp\n    image: wordpress\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: user_wp\n      WORDPRESS_DB_PASSWORD: asdasd\n      WORDPRESS_DB_NAME: bd_wp\n    ports:\n      - 80:80\n    volumes:\n      - ./wordpress:/var/www/html/wp-content\n  db:\n    container_name: servidor_mysql\n    image: mariadb\n    restart: always\n    environment:\n      MYSQL_DATABASE: bd_wp\n      MYSQL_USER: user_wp\n      MYSQL_PASSWORD: asdasd\n      MYSQL_ROOT_PASSWORD: asdasd\n    volumes:\n      - ./mysql:/var/lib/mysql\n</code></pre>"},{"location":"08.-Escenarios%20multicontenedor/06.-Ejemplos/#ejemplo-4-despliegue-de-tomcat-nginx","title":"Ejemplo 4: Despliegue de tomcat + nginx","text":"<p>En este ejemplo vamos a desplegar con docker-compose la aplicaci\u00f3n Java con Tomcat y nginx como proxy inverso que vimos en la sesi\u00f3n anterior en el Ejemplo 4: Despliegue de tomcat + nginx .</p> <p>Puedes encontrar el fichero <code>docker-compose.yml</code> en en este directorio del repositorio.</p> <p>El fichero <code>docker-compose.yaml</code> ser\u00eda:</p> <pre><code>version: '3.1'\nservices:\n  aplicacionjava:\n    container_name: tomcat\n    image: tomcat:9.0\n    restart: always\n    volumes:\n      - ./sample.war:/usr/local/tomcat/webapps/sample.war:ro\n  proxy:\n    container_name: nginx\n    image: nginx\n    ports:\n      - 80:80\n    volumes:\n      - ./default.conf:/etc/nginx/conf.d/default.conf:ro\n</code></pre> <p>Como podemos ver en el directorio donde tenemos guardado el <code>docker-compose.yaml</code>, tenemos los dos ficheros necesarios para la configuraci\u00f3n: <code>sample.war</code> y <code>default.conf</code>.</p> <p>Creamos el escenario:</p> <pre><code>$ docker-compose up -d\nCreating network \"ejemplo4_default\" with the default driver\nCreating nginx  ... done\nCreating tomcat ... done\n</code></pre> <p>Comprobar que los contenedores est\u00e1n funcionando:</p> <pre><code>$ docker-compose ps\n Name               Command               State         Ports       \n--------------------------------------------------------------------\nnginx    /docker-entrypoint.sh ngin ...   Up      0.0.0.0:80-&gt;80/tcp\ntomcat   catalina.sh run                  Up      8080/tcp          \n</code></pre> <p>Y acceder al puerto 80 de nuestra IP para ver la aplicaci\u00f3n.</p>"},{"location":"08.-Escenarios%20multicontenedor/06.-Ejemplos/#ejemplos-reales-de-despliegues-usando-docker-compose","title":"Ejemplos reales de despliegues usando docker-compose","text":"<p>En la actualidad la mayor\u00eda de los despliegues reales que se hacen con docker, se realizan usando la herramienta docker-compose, veamos algunos ejemplos:</p> <ul> <li>Despliegue de jitsi: Jitsi es una aplicaci\u00f3n de videoconferencia, VoIP, y mensajer\u00eda instant\u00e1nea con aplicaciones nativas para iOS y Android, y con soporte para Windows, Linux y Mac OS X a trav\u00e9s de la web.\u200b Es compatible con varios protocolos populares de mensajer\u00eda instant\u00e1nea y de telefon\u00eda, y se distribuye bajo los t\u00e9rminos de la licencia Apache, por lo que es software libre y de c\u00f3digo abierto. Podemos encontar las instrucciones para desplegarlo con docker en esta p\u00e1gina y podemos acceder al fichero docker-compose.yml.</li> <li>Despliegue de las aplicaciones de Bitnami: Bitnami es una empresa que nos proporciona distintas formas de despliegues de aplicaciones web en la nube. Una de estas formas es la utilizaci\u00f3n de docker, y podemos ver que todas las aplicaciones que nos ofrece Bitnami tienen el fichero <code>docker-compose.yml</code> para realizar el despliegue, por ejemplo podemos ver el fichero de la aplicaci\u00f3n PrestaShop de Bitnami.</li> <li>Despliegue de Guacamole: Apache Guacamole es un cliente (aplicaci\u00f3n web HTML5) capaz de ofrecerte funcionalidades para acceso remoto a servidores y otros equipos remotos desde cualquier parte solo con la ayuda de una conexi\u00f3n y un navegador web. Podemos instalar Guacamole con docker y aunque en esa p\u00e1gina no tenemos el fichero <code>docker-compse-yml</code> podemos encontrar ejemplos de muchos usuarios en GitHub.</li> </ul>"},{"location":"09.-Ejercicios/","title":"Ejercicios","text":"<p>Ejercicios creaci\u00f3n de contenedores b\u00e1sicos I</p> <p>Ejercicios de creaci\u00f3n de contenedores b\u00e1sicos II</p> <p>Ejercicios de Vol\u00famenes</p>"},{"location":"10.-Cheatsheet/","title":"07.-Cheatsheet","text":""},{"location":"10.-Cheatsheet/#docker-run","title":"Docker Run","text":"<pre><code>docker run -it --name=cont1 ubuntu /bin/bash\n</code></pre> <ul> <li>Crea un contenedor con la imagen \u201cubuntu\u201d (al no especificar, toma versi\u00f3n \u201clatest\u201d), le establece un nombre \u201ccont1\u201d y lanza en modo interactivo una shell \u201cbash\u201d.</li> </ul> <pre><code>docker run -d -p 1200:80 nginx\n</code></pre> <ul> <li>Crea un contenedor con la versi\u00f3n \u201clatest\u201d de la imagen \u201cnginx\u201d y lo lanza en \u201cbackground\u201d, exponiendo el puerto 80 del contenedor en el puerto 1200 de la m\u00e1quina anfitri\u00f3n.</li> </ul> <pre><code>docker run -it -e MENSAJE=HOLA ubuntu:14.04 bash\n</code></pre> <ul> <li>Crea un contenedor con la imagen \u201cubuntu\u201d, versi\u00f3n \u201c14.04\u201d y establece la variable de entorno \u201cMENSAJE\u201d.</li> </ul>"},{"location":"10.-Cheatsheet/#docker-ps","title":"Docker ps","text":"<pre><code>docker ps\n</code></pre> <ul> <li>Muestra informaci\u00f3n de los contenedores en ejecuci\u00f3n.</li> </ul> <pre><code>docker ps -a\n</code></pre> <ul> <li>Muestra informaci\u00f3n de todos los contenedores, tanto parados como en ejecuci\u00f3n.</li> </ul>"},{"location":"10.-Cheatsheet/#docker-startstoprestart","title":"Docker Start/Stop/Restart","text":"<pre><code>docker start micontenedor\n</code></pre> <ul> <li>Arranca el contenedor con nombre \u201cmi contenedor\u201d.</li> </ul> <pre><code>docker start -ai micontenedor\n</code></pre> <ul> <li>Arranca el contenedor con nombre \u201cmi contenedor\u201d, enlazando el comando ejecutado al arranque a la entrada y salida est\u00e1ndar de la terminal del anfitri\u00f3n.</li> </ul>"},{"location":"10.-Cheatsheet/#docker-exec","title":"Docker Exec","text":"<pre><code>docker exec -it -e FICHERO=prueba cont bash\n</code></pre> <ul> <li>Lanza en el contenedor \u201ccont\u201d (que debe estar arrancado) el comando \u201cbash\u201d, estableciendo la variable de entorno \u201cFICHERO\u201d y enlazando la ejecuci\u00f3n de forma interactiva a la entrada y salida est\u00e1ndar del anfitri\u00f3n.</li> </ul> <pre><code>docker exec -d cont touch /tmp/prueba\n</code></pre> <ul> <li>Lanza en el contenedor \u201ccont\u201d (que debe estar arrancado) el comando \u201ctouch /tmp/prueba\u201d. Este comando se ejecuta en segundo plano, generando el fichero \u201c/tmp/prueba\u201d.</li> </ul>"},{"location":"10.-Cheatsheet/#docker-attach","title":"Docker attach","text":"<pre><code>docker attach idcontainer\n</code></pre> <ul> <li>Enlaza nuestra terminal la entrada/salida de nuestra al proceso en segundo plano del contenedor \u201cidcontainer\u201d.</li> </ul>"},{"location":"10.-Cheatsheet/#docker-logs","title":"Docker logs","text":"<pre><code>docker logs -n 10 idcontainer\n</code></pre> <ul> <li>Muestra las 10 \u00faltimas l\u00edneas de la salida estandar producida por el proceso en ejecuci\u00f3n en el contendor.</li> </ul>"},{"location":"10.-Cheatsheet/#docker-cp","title":"Docker cp","text":"<pre><code>docker cp idcontainer:/tmp/prueba ./\n</code></pre> <ul> <li>Copia el fichero \u201c/tmp/prueba\u201d del contenedor \u201cidcontainer\u201d al directorio actual del anfitri\u00f3n.</li> </ul> <pre><code>docker cp ./miFichero idcontainer:/tmp\n</code></pre> <ul> <li>Copia el fichero \u201cmiFichero\u201d del directorio actual del anfitri\u00f3n a la carpeta \u201c/tmp\u201d del contenedor.</li> </ul>"},{"location":"10.-Cheatsheet/#gestion-de-imagenes","title":"Gesti\u00f3n de im\u00e1genes","text":"<pre><code>docker images\n</code></pre> <ul> <li>Informaci\u00f3n de im\u00e1genes locales disponibles.</li> </ul> <pre><code>docker search ubuntu\n</code></pre> <ul> <li>Busca la imagen \u201cubuntu\u201d en el repositorio remoto (por defecto Docker Hub).</li> </ul> <pre><code>docker pull alpine\n</code></pre> <ul> <li>Descarga localmente imagen \u201calpine\u201d.</li> </ul> <pre><code>docker history alpine\n</code></pre> <ul> <li>Muestra la historia de creaci\u00f3n de la imagen \u201calpine\u201d.</li> </ul> <pre><code>docker rmi ubuntu:14.04\n</code></pre> <ul> <li>Elimina localmente la imagen \u201cubuntu\u201d con tag \u201c14.04\u201d.</li> </ul> <pre><code>docker rmi $(docker images -q)\n</code></pre> <ul> <li>Borra toda imagen local que no est\u00e9 siendo usada por un contenedor.</li> </ul> <pre><code>docker rm IDCONTENEDOR\n</code></pre> <ul> <li>Borra un contenedor con IDCONTENEDOR.</li> </ul> <pre><code>docker stop $(docker ps -a -q)\n</code></pre> <ul> <li>Para todos los contenedores del sistema.</li> </ul> <pre><code>docker rm $(docker ps -a -q)\n</code></pre> <ul> <li>Borra todos los contenedores parados del sistema.</li> </ul> <pre><code>docker system prune -a\n</code></pre> <ul> <li>Borra todas las im\u00e1genes y contenedores parados del sistema.</li> </ul>"},{"location":"10.-Cheatsheet/#creacion-de-imagenes-a-partir-de-contenedores","title":"Creaci\u00f3n de im\u00e1genes a partir de contenedores","text":"<pre><code>docker commit -m \u201ccomentario\u201d IDCONTENEDOR usuario/imagen:version\n</code></pre> <ul> <li>Hace commit de un contenedor existente a una imagen local.</li> </ul> <pre><code>docker save -o copiaSeguridad.tar imagenA\n</code></pre> <ul> <li>Guarda una copia de seguridad de una imagen en fichero \u201c.tar\u201d.</li> </ul> <pre><code>docker load -i copiaSeguridad.tar\n</code></pre> <ul> <li>Restaura una copia de seguridad de una imagen en fichero \u201c.tar\u201d.</li> </ul>"},{"location":"10.-Cheatsheet/#docker-hub","title":"Docker Hub","text":"<pre><code>docker login\n</code></pre> <ul> <li>Permite introducir credenciales del registro (por defecto \u201cDocker Hub\u201d).</li> </ul> <pre><code>docker push usuario/imagen:version\n</code></pre> <ul> <li>Permite subir al repositorio una imagen mediante \u201cpush\u201d.</li> </ul>"},{"location":"10.-Cheatsheet/#ejemplo-de-dockerfile","title":"Ejemplo de Dockerfile","text":"<pre><code>FROM alpine\nLABEL maintainer=\"email@gmail.com\"\n\n#Actualizamos e instalamos paquetes con APK para Alpine\nRUN apk update &amp;&amp; apk add apache2 php php-apache2 openrc tar\n\n#Copiamos script para lanzar Apache 2\nADD ./start.sh /start.sh\n\n#Descargamos un ejemplo de &lt;?php phpinfo(); ?&gt; por ense\u00f1ar como bajar algo de Internet\n#Podr\u00eda haber sido simplemente\n#RUN echo \"&lt;?php phpinfo(); ?&gt;\" &gt; /var/www/localhost/htdocs/index.php\nADD https://gist.githubusercontent.com/SyntaxC4/5648247/raw/94277156638f9c309f2e36e19bff378ba7364907/info.php\n/var/www/localhost/htdocs/index.php\n\n# Si quisi\u00e9ramos algo como Wordpress har\u00edamos\n#ADD http://wordpress.org/latest.tar.gz /var/www/localhost/htdocs/wordpress.tar.gz\n#RUN tar xvzf /var/www/localhost/htdocs/wordpress.tar.gz &amp;&amp; rm -rf /var/www/localhost/htdocs/wordpress.tar.gz\n\n# Usamos usuario y grupo www-data. El grupo lo crea Apache, pero si quisi\u00e9ramos crear grupo\n# Grupo www-data RUN set -x &amp;&amp; addgroup -g 82 -S www-data\n# Creamos usuario www-data y lo a\u00f1adimos a ese grupo\nRUN adduser -u 82 -D -S -G www-data www-data\n\n# Hacemos todos los ficheros de /var/www propiedad de www-data\n# Y damos permisos a esos ficheros y a start.sh\nRUN chown -R www-data:www-data /var/www/ &amp;&amp; chmod -R 775 /var/www/ &amp;&amp; chmod 755 /start.sh\n\n#Indicamos puerto a exponer (para otros contenedores) 80\nEXPOSE 80\n\n#Comando lanzado por defecto al instalar el contendor\nCMD /start.sh\n</code></pre> <ul> <li>Ejemplo de fichero \u201cDockerfile\u201d.</li> </ul>"},{"location":"10.-Cheatsheet/#gestion-de-redes","title":"Gesti\u00f3n de redes","text":"<pre><code>docker network create redtest\n</code></pre> <ul> <li>Creamos la red \u201credtest\u201d</li> </ul> <pre><code>docker network ls\n</code></pre> <ul> <li>Nos permite ver el listado de redes existentes.</li> </ul> <pre><code>docker network rm redtest\n</code></pre> <ul> <li>Borramos la red \u201credtest\u201d.</li> </ul> <pre><code>docker run -it --network redtest ubuntu /bin/bash\n</code></pre> <ul> <li>Conectamos el contenedor que creamos a la red \u201credtest\u201d.</li> </ul> <pre><code>docker network connect IDRED IDCONTENEDOR\n</code></pre> <ul> <li>Conectamos un contenedor a una red.</li> </ul> <pre><code>docker network disconnect IDRED IDCONTENEDOR\n</code></pre> <ul> <li>Desconectamos un contenedor de una red</li> </ul>"},{"location":"10.-Cheatsheet/#volumenes","title":"Vol\u00famenes","text":"<pre><code>docker run -d -it --name appcontainer -v /home/sergi/target:/app nginx:latest\n</code></pre> <ul> <li>Creamos un contenedor y asignamos un volumen con \u201cbinding mount\u201d.</li> </ul> <pre><code>docker run -d -it --name appcontainer -v micontenedor:/app nginx:latest\n</code></pre> <ul> <li>Creamos un contenedor y asignamos un volumen Docker llamado \u201cmicontenedor\u201d.</li> </ul> <pre><code>docker volume create/ls/rm mivolumen\n</code></pre> <ul> <li>Permite crear, listar o eliminar vol\u00famenes Docker.</li> </ul> <pre><code>docker run -d -it --tmpfs /app nginx\n</code></pre> <ul> <li>Permite crear un contenedor y asociar un volumen \u201ctmpfs\u201d.</li> </ul> <pre><code>docker run --rm --volumes-from contenedor1 -v /home/sergi/backup:/backup ubuntu bash -c \"cd\n/datos &amp;&amp; tar cvf /backup/copiaseguridad.tar .\"\n</code></pre> <ul> <li>Permite realizar una copia de seguridad de un volumen asociado a \u201ccontenedor1\u201d y que se monta en \u201c/datos\u201d. Dicha copia finalmente acabar\u00e1 en \u201c/home/sergi/backup\u201d de la m\u00e1quina anfitri\u00f3n.</li> </ul> <pre><code>docker volume rm $(docker volume ls -q)\n</code></pre> <ul> <li>Permite eliminar todos los l\u00famenes de tu m\u00e1quina.</li> </ul>"},{"location":"10.-Cheatsheet/#ejemplo-basico-de-fichero-docker-composeyml","title":"Ejemplo b\u00e1sico de fichero \u201cdocker-compose.yml\u201d","text":"<pre><code>version: \"3.9\"\nservices:\n    db:\n        image: mariadb:10.11.2\n        volumes:\n        - db_data:/var/lib/mysql\n        environment:\n            MARIADB_ROOT_PASSWORD: somewordpress\n            MARIADB_DATABASE: wordpress\n            MARIADB_USER: wordpress\n            MARIADB_PASSWORD: wordpress\n    wordpress:\n            image: wordpress:latest\n            ports:\n            - \"8000:80\"\n            environment:\n                WORDPRESS_DB_HOST: db:3306\n                WORDPRESS_DB_USER: wordpress\n                WORDPRESS_DB_PASSWORD: wordpress\n                WORDPRESS_DB_NAME: wordpress\nvolumes:\n    db_data:\n</code></pre>"},{"location":"10.-Cheatsheet/#principales-comandos-de-docker-compose","title":"Principales comandos de \u201cDocker Compose\u201d","text":"<pre><code>docker compose up -d\n</code></pre> <ul> <li>Inicia el sistema definido en \u201cdocker-compose.yml\u201d en segundo plano. Genera y descarga im\u00e1genes requeridas.</li> </ul> <pre><code>docker compose down\n</code></pre> <ul> <li>Detiene y elimina los contenedores seg\u00fan la configuraci\u00f3n de \u201cdocker-compose.yml\u201d.</li> </ul> <pre><code>docker compose build/pull\n</code></pre> <ul> <li>Construye/descarga las im\u00e1genes de contenedores seg\u00fan la configuraci\u00f3n de \u201cdocker-compose.yml\u201d.</li> </ul> <pre><code>docker compose ps\n</code></pre> <ul> <li>Muestra informaci\u00f3n de los contenedores seg\u00fan la configuraci\u00f3n de \u201cdocker-compose.yml\u201d.</li> </ul> <pre><code>docker compose up -d --scale web=3\n</code></pre> <ul> <li>Similar a \u201cdocker compose up -d\u201d solo que adem\u00e1s, el servicio definido como \u201cweb\u201d en el fichero \u201cdocker-compose.yml\u201d lo escala creando 3 copias y realizando balanceo autom\u00e1tico si se realiza una petici\u00f3n al host llamado como el servicio \u201cweb\u201d.</li> </ul>"},{"location":"10.-Cheatsheet/#principales-comandos-de-kubernetes","title":"Principales comandos de \u201cKubernetes\u201d","text":"<pre><code>kubectl apply -f \u201cfichero.yaml\u201d\n</code></pre> <ul> <li>Aplica en Kubernetes la configuraci\u00f3n especificada en \u201cfichero.yaml\u201d.</li> </ul> <pre><code>kubectl create deployment midespliegue --image=sergarb1/flaskparakubernetes --port=5000\n</code></pre> <ul> <li>Crea un despliegue basado en una imagen dada y en el puerto 5000.</li> </ul> <pre><code>kubectl expose deployment midespliegue --type=LoadBalancer --name=midespliegue-http\n</code></pre> <ul> <li>Crea un servicio de tipo \u201cLoadBalancer\u201d exponeniendo \u201cmidespliegue\u201d.</li> </ul> <pre><code>kubectl get pods; kubectl get services; kubectl get deployments\n</code></pre> <ul> <li>Muestra informaci\u00f3n de pods, servicios o despliegues.</li> </ul> <pre><code>kubectl scale deployment midespliegue --replicas=3\n</code></pre> <ul> <li>Escala horizontalmente un despliegue a 3 r\u00e9plicas.</li> </ul> <pre><code>kubectl autoscale deployment midespliegue --min=5 --max=10\n</code></pre> <ul> <li>Configura autoescalado horizontal, aceptando entre 5 y 10 r\u00e9plicas.</li> </ul> <pre><code>kubectl delete pod/deployment/service/autoscale nombre\n</code></pre> <ul> <li>Permite eliminar un pod, despliegue, servicio o autoescalado.</li> </ul>"},{"location":"10.-Cheatsheet/#principales-comandos-de-mnikube","title":"Principales comandos de \u201cMniKube\u201d","text":"<pre><code>minikube start\n</code></pre> <ul> <li>Inicia la m\u00e1quina virtual que contiene MiniKube y pone el cluster Kubernetes en marcha</li> </ul> <pre><code>minikube service miservicio\n</code></pre> <ul> <li>Nos permite acceder a un servicio dentro de MiniKube desde la m\u00e1quina local.</li> </ul> <pre><code>minikube tunnel\n</code></pre> <ul> <li>Mientras est\u00e9 en ejecuci\u00f3n, expone un servicio dentro de MiniKube a la m\u00e1quina local</li> </ul>"},{"location":"10.-Cheatsheet/#ejemplo-de-fichero-yaml-despliegueserviciopersistencia-con-kubernetes","title":"Ejemplo de fichero YAML despliegue/servicio/persistencia con Kubernetes","text":"<pre><code>#Definimos la informaci\u00f3n del servicio\napiVersion: v1\nkind: Service\nmetadata:\n  name: wordpress\n  labels:\n    app: wordpress\nspec:\n  ports:\n    #El servicio se expone en el puerto 80\n    - port: 80\n  selector:\n    app: wordpress\n    tier: frontend\n  #Aplicamos balanceo de carga para facilitar su escalado horizontal\n  type: LoadBalancer\n\n---\n#Definimos un volumen persistente\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: wp-pv-claim\n  labels:\n    app: wordpress\nspec:\n  #Indica que solo puede ser montado para lectura/escritura por un nodo. Para el resto lectura.\n  #En este caso, se usa para modificar un fichero de configuraci\u00f3n.\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n    storage: 20Gi\n\n---\n#definimos el despliegue\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: wordpress\n  labels:\n    app: wordpress\nspec:\n  selector:\n    matchLabels:\n    app: wordpress\n    tier: frontend\n  strategy:\n    type: Recreate\n  template:\n    metadata:\n    labels:\n    app: wordpress\n    tier: frontend\n    spec:\n      #Imagen\n    containers:\n      - image: wordpress:4.8-apache\n    name: wordpress\n\n    #Indicamos variables de entorno\n    env:\n    - name: WORDPRESS_DB_HOST\n    value: wordpress-mysql\n    - name: WORDPRESS_DB_PASSWORD\n    value: CEFIREdocker\n    ports:\n    - containerPort: 80\n    name: wordpress\n    volumeMounts:\n    - name: wordpress-persistent-storage\n    mountPath: /var/www/html\n    volumes:\n    - name: wordpress-persistent-storage\n    persistentVolumeClaim:\n    claimName: wp-pv-claim\n\n</code></pre>"},{"location":"intermezzo/Docker%20Compose/","title":"Docker Compose","text":"<p>Docker Compose es una herramienta que se utiliza para definir y ejecutar aplicaciones Docker de m\u00faltiples contenedores. Con Docker Compose, se puede definir una aplicaci\u00f3n en un archivo YAML y luego ejecutarla con un solo comando. Docker Compose tambi\u00e9n permite la creaci\u00f3n de redes personalizadas y vol\u00famenes de datos para los contenedores.</p> <p>Docker Compose es \u00fatil para simplificar la gesti\u00f3n de aplicaciones Docker complejas. Por ejemplo, si una aplicaci\u00f3n consta de varios contenedores que deben comunicarse entre s\u00ed, Docker Compose puede definir f\u00e1cilmente las relaciones entre los contenedores y las redes que los conectan. Tambi\u00e9n puede definir vol\u00famenes de datos para los contenedores, lo que permite el almacenamiento persistente de datos.</p> <p>Presentamos a continuaci\u00f3n un ejemplo de un archivo YAML de Docker Compose para una aplicaci\u00f3n Django:</p> <pre><code>version: '3'\n\nservices:\n    db:\n        image: postgres\n    environment:\n        POSTGRES_DB: django_db\n        POSTGRES_USER: django_user\n        POSTGRES_PASSWORD: django_password\n\n    web:\n        build: .\n            command: python manage.py runserver 0.0.0.0:8000\n        volumes:\n        -  .:/code\n\nports:\n    - \"8000:8000\"\n\ndepends_on:\n    - db\n</code></pre> <p>En este ejemplo, se definen dos servicios: <code>db</code> y <code>web</code>. El servicio <code>db</code> utiliza la imagen de <code>postgres</code> y se definen las variables de entorno para la base de datos. El servicio <code>web</code> se construye a partir del directorio actual y se ejecuta el comando para iniciar el servidor Django. Tambi\u00e9n se define un volumen para el c\u00f3digo fuente y se expone en el puerto 8000. El servicio <code>web</code> depende del servicio <code>db</code>.</p>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/","title":"Docker en python y django","text":"<p>Ok, suficiente teor\u00eda. Empecemos a usar Docker y Django juntos. El primer paso es registrarse en Docker Hub para obtener una cuenta gratuita y luego instalar la aplicaci\u00f3n de escritorio Docker en nuestra m\u00e1quina local:</p> <ul> <li>Docker para Linux</li> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker</code></li> <li>Docker para Mac</li> <li>Docker para Windows</li> </ul> <p>Esta descarga puede tomarse alg\u00fan tiempo ya que es un archivo grande.</p> <p>Una vez que Docker se haya terminado de instalar, podemos confirmar que se est\u00e1 ejecutando la versi\u00f3n correcta escribiendo <code>docker --version</code> en la l\u00ednea de comandos. Debe ser al menos la versi\u00f3n 18.</p> <pre><code>$ docker --version\nDocker versi\u00f3n 19.03.5-ce, build 633a0ea838\n</code></pre> <p>Docker se utiliza a menudo con una herramienta adicional, Docker Compose, para ayudar a automatizar los comandos. Docker Compose se incluye con las descargas de Mac y Windows, pero si se est\u00e1 en Linux, tendr\u00e1 que a\u00f1adirse manualmente. Puede hacerse ejecutando el comando <code>sudo pip install docker-compose</code> despu\u00e9s de que la instalaci\u00f3n de Docker haya finalizado.</p> <ul> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker-compose</code>. (Si surgen problemas con alg\u00fan fichero ya instalado en el sistema, borrar todos aquellos ficheros que est\u00e9n involucrados y proceder con la instalaci\u00f3n como se indica)</li> </ul>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#docker-hola-mundo","title":"Docker, Hola Mundo","text":"<p>Docker se env\u00eda con su propia imagen de \"Hello, World\" que es un primer paso \u00fatil para comprobar la instalaci\u00f3n. Introducir en la l\u00ednea de comandos el comando <code>docker run hello-world</code>. Esto descargar\u00e1 una imagen Docker oficial y luego se ejecutar\u00e1 dentro de un contenedor. Se discutir\u00e1 sobre las im\u00e1genes y los contenedores en breve.</p> <pre><code>$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete\nDigest: sha256:b8ba256769a0ac28dd126d584e0a2011cd2877f3f76e093a7ae560f2a5301c00\nStatus: Downloaded newer image for hello-world:latest\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n(amd64)\n 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.\nTo try something more ambitious, you can run an Ubuntu container with:\n$ docker run -it ubuntu bash\nShare images, automate workflows, and more with a free Docker ID:\nhttps://hub.docker.com/\nFor more examples and ideas, visit:\nhttps://docs.docker.com/get-started/\n</code></pre> <p>El comando <code>docker info</code> nos permite inspeccionar Docker. Contendr\u00e1 una gran cantidad de informaci\u00f3n, pero si nos centramos en las l\u00edneas superiores tenemos 1 contenedor que se detenido y 1 imagen.</p> <pre><code>$ docker info\nClient:\n Debug Mode: false\n\nServer:\n Containers: 1\n  Running: 0\n  Paused: 0\n  Stopped: 1\n Images: 1\n...\n</code></pre>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#django-hola-mundo","title":"Django, Hola mundo","text":"<p>Ahora vamos a crear un proyecto de Django \"Hello, World\" que se ejecuta localmente en nuestro ordenador y luego lo moveremos por completo dentro de Docker para que se pueda ver c\u00f3mo encajan todas las piezas.</p> <p>El primer paso es elegir una ubicaci\u00f3n para nuestro c\u00f3digo. Esto puede ser en cualquier parte del ordenador pero si est\u00e1s en Linux, una ubicaci\u00f3n f\u00e1cil de encontrar es el Escritorio . Desde la l\u00ednea de comandos navegamos hasta el <code>Escritorio</code> y creamos un directorio <code>code</code> para todos los ejemplos:</p> <pre><code>$ cd ~/Desktop\n$ mkdir code &amp;&amp; cd code\n</code></pre> <p>Luego creeamos un directorio <code>hello</code> donde  instalaremos Django usando Pipenv que crea un archivo Pipfile y un archivo Pipfile.lock.  Activamos el entorno virtual con el comando <code>shell</code>.</p> <pre><code>$ mkdir hello &amp;&amp; cd hello\npipenv install django==2.2.7\n$ pipenv shell\n(hello) $\n</code></pre> <p>Si se necesita ayuda para instalar Pipenv o Python 3, se pueden encontrar m\u00e1s detalles aqu\u00ed. Ahora podemos usar el comando <code>startproject</code> para crear un nuevo proyecto de Django llamado <code>hello_project</code>. A\u00f1adir un punto, <code>.</code>, al final del comando es un paso opcional pero muchos desarrolladores de Django lo hacen. Sin el punto, Django a\u00f1ade un directorio adicional al proyecto; con el <code>.</code>, esto no ocurre. Por \u00faltimo, utilice el comando <code>migrate</code> para inicializar la base de datos e iniciar la web local con el comando <code>runserver</code>.</p> <pre><code>(hola) $ django-admin startproject hello_project .\n(hola) $ python manage.py migrate\n(hola) $ python manage.py runserver\n</code></pre> <p>Suponiendo que todo ha funcionado correctamente, ahora deber\u00edamos poder navegar para ver el la p\u00e1gica de bienvenida de Django en http://127.0.0.1:8000/ en su navegador web.</p> <p></p>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#pages-app","title":"Pages App","text":"<p>Ahora haremos una p\u00e1gina de inicio simple creando una <code>pages</code> app espec\u00edfica  para ello. Parar el servidor local escribiendo Control+c y luego usar el comando <code>startapp</code> a\u00f1adiendo el nombre de la <code>pages</code> que se desee.</p> <pre><code>(hola) $ python manage.py startapp pages\n</code></pre> <p>Django instala autom\u00e1ticamente un nuevo directorio de p\u00e1ginas y varios archivos para nosotros. Pero incluso aunque la app ha sido creada, nuestro <code>hello_project</code> no la reconocer\u00e1 hasta que la a\u00f1adamos a la configuraci\u00f3n de <code>INSTALLED_APPS</code> de archivo <code>hello_project/settings.py</code>.</p> <p>Django carga las apps de arriba a abajo, por lo que, en general, es una buena pr\u00e1ctica a\u00f1adir las nuevas aplicaciones debajo de las aplicaciones incorporadas en las que pueden confiar, tales como <code>admin</code>, <code>auth</code>, y todas las aplicaciones restantes.</p> <p>T\u00e9ngase en cuenta que si bien es posible simplemente escribir el nombre de la app, <code>pages</code>,  es mejor escribir la <code>pages.apps.apps.PagesConfig</code> completa lo que abre m\u00e1s posibilidades en la configuraci\u00f3n de las apps.</p> <pre><code># hello_project/settings.py\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'pages.apps.apps.PagesConfig', # nuevo\n]\n</code></pre> <p>Ahora podemos establecer la ruta URL para la app <code>pages</code>. Ya que queremos que nuestro mensaje aparezca en la p\u00e1gina de inicio usaremos la cadena vac\u00eda <code>''</code> . No olvidar a\u00f1adir la importaci\u00f3n de <code>include</code> en la segunda l\u00ednea tambi\u00e9n.</p> <pre><code># hello_project/urls.py\nfrom django.contrib import admin\nfrom django.urls import path, include # nuevo\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('pages.urls')), # nuevo\n]\n</code></pre> <p>En lugar de crear una plantilla en este punto, podemos simplemente codificar un mensaje en nuestra capa de la vista <code>pages/views.py</code> que producir\u00e1 la cadena <code>Hello, World!</code>.</p> <pre><code># pages/views.py\nfrom django.http import HttpResponse\n\ndef home_page_view(request):\n    return HttpResponse('Hello, World!')\n</code></pre> <p>\u00bfQu\u00e9 es lo siguiente? El \u00faltimo paso es crear un archivo <code>urls.py</code> dentro de la app <code>pages</code>y enlazarlo to <code>home_page_view</code>. Si se encuentra en un ordenador Mac o Linux, el comando <code>touch</code> se puede usar desde la l\u00ednea de comandos para crear nuevos archivos. En Windows habr\u00e1 que crear el nuevo archivo con un editor de texto.</p> <pre><code>(hola) $ touch pages/urls.py\n</code></pre> <p>En el editor de texto importar <code>path</code> en la primera l\u00ednea, a\u00f1adir la <code>home_page_view</code>, y colocar su ruta para otra vez ser la cadena vac\u00eda ''. N\u00f3tese que tambi\u00e9n provee un nombre opcional, <code>home</code>, para esta ruta lo cual es una buena pr\u00e1ctica.</p> <pre><code># pages/urls.py\nfrom django.urls import path\n\nfrom .views import home_page_view\n\n\nurlpatterns = [\npath('', home_page_view, name='home')\n]\n\n</code></pre> <p>El flujo completo de nuestra p\u00e1gina web Django es el siguiente:</p> <ul> <li>cuando un usuario va a su homepage ser\u00e1 primero encaminado a <code>hello_project/urls.py</code></li> <li>luego a <code>pages/urls.py</code></li> <li>y finalmente dirigido a la <code>home_page_view</code> que devuelve la cadena <code>Hello, World!</code></li> </ul> <p>El trabajo para una p\u00e1gina de inicio b\u00e1sica ha terminado. Iniciemos de nuevo el servidor local.</p> <pre><code>(hola) $ python manage.py runserver\n</code></pre> <p>Si se actualiza el navegador web en http://127.0.0.1:8000/, ahora saldr\u00e1 nuestro deseado mensaje.</p> <p></p> <p>Ahora es el momento de cambiar a Docker. Detengamos de nuevo el servidor local con Ctrl+C y salgamos de nuestro entorno virtual, que ya no necesitamos, escribiendo <code>exit</code>.</p> <pre><code>(hello) $ exit\n$\n</code></pre> <p>\u00bfC\u00f3mo sabemos que nuestro entorno virtual ya no est\u00e1 activo? No habr\u00e1 un par\u00e9ntesis alrededor del nombre de directorio en el prompt. Cualquier comando Django normal que se intente ejecutar en este punto fallar\u00e1. Por ejemplo, probar <code>python manage.py runserver</code> para ver lo que ocurre.</p> <pre><code>$ python manage.py runserver\nFile \"./manage.py\", line 14\n  ) from exc\n       ^\nSyntaxError: invalid syntax\n</code></pre> <p>Esto significa que estamos totalmente fuera del entorno virtual y preparados para Docker.</p>"},{"location":"intermezzo/Docker%20en%20python%20y%20django/#imagenes-contenedores-y-el-docker-host","title":"Im\u00e1genes, Contenedores y el \"Docker Host\"","text":"<p>Una imagen Docker es una instant\u00e1nea en el tiempo de lo que contiene un proyecto. Est\u00e1 representado por un <code>Dockerfile</code> y es literalmente una lista de instrucciones que deben ser construidas/ejecutadas. Un contenedor Docker es una instancia en ejecuci\u00f3n de una imagen. Para continuar con la analog\u00eda de nuestro apartamento de antes, la imagen es el plano o conjunto de planos del apartamento; el contenedor es el edificio real totalmente construido.</p> <p>El tercer concepto central es el Docker host, que es el sistema operativo subyacente. Es posible tener varios contenedores ejecut\u00e1ndose dentro de un mismo Docker host. Cuando nos referimos a c\u00f3digo o procesos que se ejecutan en el Docker, significa que se ejecutan en el Docker host.</p> <p>Creemos nuestro primer <code>Dockerfile</code> para ver toda esta teor\u00eda en acci\u00f3n.</p> <pre><code>$ touch Dockerfile\n</code></pre> <p>Dentro del <code>Dockerfile</code> agregamos el siguiente c\u00f3digo que recorreremos l\u00ednea por l\u00ednea m\u00e1s abajo.</p> <pre><code># Pull base image\nFROM python:3.8\n\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n\n# Set work directory\nWORKDIR /code\n\n\n# Install dependencies\nCOPY Pipfile Pipfile.lock /code/\nRUN pip install pipenv &amp;&amp; pipenv install --system\n\n\n# Copy project\nCOPY . /code/\n</code></pre> <p>Los <code>Dockerfiles</code> se leen de arriba hacia abajo cuando se crea una imagen. La primera instrucci\u00f3n debe ser el comando <code>FROM</code> que nos permite importar una imagen base que usar, en nuestro caso Python 3.8.</p> <p>Luego usamos el comando <code>ENV</code> para establecer dos variables de entorno:</p> <ul> <li><code>PYTHONUNBUFFERED</code> asegura que la salida de nuestra consola se vea familiar y que no est\u00e9 almacenada en un b\u00fafer de Docker, lo cual no queremos</li> <li><code>PYTHONDONTWRITEBYTECODE</code> significa que Python no intentar\u00e1 escribir archivos <code>.pyc</code>, que tampoco deseamos</li> </ul> <p>A continuaci\u00f3n usamos <code>WORKDIR</code> para establecer una ruta de directorio de trabajo por defecto dentro de nuestra imagen llamada <code>code</code>que es donde guardaremos nuestro c\u00f3digo. Si no lo hicimos, entonces cada vez que queramos ejecutar comandos dentro de nuestro contenedor tendr\u00edamos que escribir una ruta muy larga. En su lugar, Docker asumir\u00e1 que queremos ejecutar todos los comandos desde este directorio.</p> <p>Para nuestras dependencias estamos usando <code>pipenv</code>, as\u00ed que copiamos tanto el archivo <code>Pipfile</code> como el archivo <code>Pipfile.lock</code> en el directorio <code>/code/</code> en Docker.</p> <p>Vale la pena tomarse un momento para explicar por qu\u00e9 <code>pipenv</code> crea un <code>Pipfile.lock</code>. El concepto de bloqueo de archivos no es exclusivo de Python o Pipenv; de hecho ya est\u00e1 presente en los gestores de paquetes de los lenguajes de programaci\u00f3n m\u00e1s modernos: <code>Gemfile.lock</code> en Ruby, <code>yarn.lock</code> en JavaScript, <code>composer.lock</code> en PHP, etc. Pipenv fue el primer proyecto popular en incorporarlos en la paqueter\u00eda de Python.</p> <p>La ventaja de un archivo de bloqueo es que esto conduce a una construcci\u00f3n determinista: no importa cu\u00e1ntas veces se instalen los paquetes de software, se obtendr\u00e1 el mismo resultado. Sin un fichero lock que \"bloquee\" las dependencias y su orden, no se cumplir\u00eda necesariamente. Lo que significa que dos miembros del equipo que instalan la misma lista de software pueden tener instalaciones de construcci\u00f3n ligeramente diferentes.</p> <p>Cuando estamos trabajando con Docker donde hay c\u00f3digo tanto local en nuestro ordenador como tambi\u00e9n dentro de Docker, el potencial de conflictos de <code>Pipfile.lock</code> surge cuando se actualizan paquetes de software.</p> <p>Siguiendo adelante usamos el comando <code>RUN</code> para instalar primero <code>pipenv</code> y luego <code>pipenv install</code> para instalar los paquetes de software listados en nuestro Pipfile.lock, actualmente s\u00f3lo Django. Es un es importante a\u00f1adir tambi\u00e9n el indicador <code>--system</code>, ya que por defecto Pipenv buscar\u00e1 el par\u00e1metro en el que instalar cualquier paquete, pero como estamos dentro de Docker ahora, t\u00e9cnicamente no hay ning\u00fan entorno virtual. En cierto modo, el contenedor Docker es nuestro entorno virtual y mucho m\u00e1s. As\u00ed que debemos usar la bandera <code>--system</code> para asegurarnos de que nuestros paquestes est\u00e1n disponibles en todo el Docker para nosotros.</p> <p>Como paso final copiamos el resto de nuestro c\u00f3digo local en el directorio <code>/code/</code> dentro de Docker. \u00bfPor qu\u00e9 copiamos el c\u00f3digo local dos veces, primero el Pipfile y Pipfile.lock y luego el resto? La raz\u00f3n es que las im\u00e1genes se crean en base a instrucciones de arriba hacia abajo por lo que queremos que las cosas que cambian a menudo -como nuestro c\u00f3digo local- sea el \u00faltimo. De esta manera s\u00f3lo tenemos que regenerar esa parte de la imagen ante un cambio y no se reinstala todo cada vez que lo haya. Como el software de los paquetes contenidos en nuestros <code>Pipfile</code> y <code>Pipfile.lock</code> cambian con poca frecuencia, implica que no tiene sentido copiarlos e instalarlos antes.</p> <p>Nuestras instrucciones de imagen ya est\u00e1n hechas, as\u00ed que vamos a construir la imagen usando el comando <code>docker build .</code>. El punto <code>.</code> indica que el directorio actual es donde se debe ejecutar el comando comando. Se genera una gran cantidad de texto en pantalla; s\u00f3lo se incluye las dos primeras l\u00edneas y las tres \u00faltimas.</p> <pre><code>$ docker build .\nSending build context to Docker daemon 154.1kB\nStep 1/7 : FROM python:3.8\n...\nStep 7/7 : COPY . /code/\n---&gt; a48b2acb1fcc\nSuccessfully built a48b2acb1fcc\n</code></pre> <p>Pasando a lo siguiente, ahora necesitamos crear un archivo <code>docker-composition.yml</code> para controlar c\u00f3mo ejecutar el comando que ser\u00e1 construido en base a nuestra imagen de <code>Dockerfile</code>.</p> <pre><code>$ touch docker-compose.yml\n</code></pre> <p>Contendr\u00e1 el siguiente c\u00f3digo</p> <pre><code>version: '3.7'\n\nservices:\n  web:\n    build: .\n    command: python /code/manage.py runserver 0.0.0.0:8000\n    volumes:\n      - .:/code\n    ports:\n      - 8000:8000\n</code></pre> <p>En la l\u00ednea superior se especifica la versi\u00f3n m\u00e1s reciente de Docker Compose que es actualmente 3.7  (no confundir con la versi\u00f3n de Python que puede ser bien parecida) A continuaci\u00f3n, especificamos qu\u00e9 <code>services</code> (o contenedores) queremos que funcionen en nuestro \"Docker host\". Es posible tener varios <code>services</code> funcionando, pero por ahora s\u00f3lo tenemos uno para el servidor <code>web</code>. Especificaremos c\u00f3mo construir el contenedor diciendo, \"Busca el directorio en curso <code>.</code> el <code>Dockerfile</code>\" . Luego, dentro del contenedor, ejecute el comando para arrancar el servidor local. El montaje de los vol\u00famenes sincroniza autom\u00e1ticamente el sistema de archivos Docker con nuestro sistema de archivos local. \u00a1Esto significa que no tenemos que reconstruir la imagen cada vez que cambiamos un solo fichero!.</p> <p>Por \u00faltimo especificamos los puertos (<code>ports</code>) a exponer dentro de Docker que solo ser\u00e1 el 8000, que es el puerto Django por defecto.</p> <p>Si es la primera vez que utiliza Docker, es muy probable que se est\u00e9 muy confundido en este momento. No hay motivo de preocupaci\u00f3n. Crearemos m\u00faltiples im\u00e1genes y contenedores Docker y, con la pr\u00e1ctica, el flujo comenzar\u00e1 a tener m\u00e1s sentido. Se ver\u00e1 como se usan archivos <code>Dockerfile</code> y <code>docker-composition.yml</code> muy similares en cada uno de los proyectos.</p> <p>El paso final es ejecutar nuestro contenedor Docker usando el comando <code>docker-compose up</code>. Este comando resultar\u00e1 en otro largo flujo de texto de salida en la l\u00ednea de comandos.</p> <pre><code>$ docker-compose up\nCreating network \"hello_default\" with the default driver\nBuilding web\nStep 1/7 : FROM python:3.8\n...\nCreating hello_web_1 ... done\nAttaching to hello_web_1\nweb_1 | Performing system checks...\nweb_1 |\nweb_1 | System check identified no issues (0 silenced).\nweb_1 | September 20, 2019 - 17:21:57\nweb_1 | Django version 2.2.5, using settings 'hello_project.settings'\nweb_1 | Starting development server at http://0.0.0.0:8000/\nweb_1 | Quit the server with CONTROL-C.\n</code></pre> <p>Para confirmar que realmente funcion\u00f3, volveremos a poner http://127.0.0.1:8000/ en el navegador web. Actualizaremos la p\u00e1gina y aparecer\u00e1 la p\u00e1gina \"Hello, World\".</p> <p>Django se est\u00e1 ejecutando ahora puramente dentro de un contenedor Docker. No estamos trabajando dentro de un entorno virtual local. No ejecutamos el comando <code>runserver</code>. Todo nuestro c\u00f3digo y nuestro servidor Django se est\u00e1 ejecutando desde dentro de un Docker aut\u00f3nomo. !Todo un \u00e9xito!</p> <p>Detendremos el contenedor con Ctrl+C y adem\u00e1s escribiremos <code>docker-compose down</code>. Los contenedores absorben una gran cantidad de memoria, as\u00ed que es una buena idea detenerlos de esta manera cuando hayamos terminado de usarlos.</p> <p>Los contenedores se han concebido para ser est\u00e1ticos (no pueden cambiar), por lo que utilizamos <code>volumes</code> para copiar nuestro c\u00f3digo en sitios donde si que pueda guardarse.</p> <pre><code>$ docker-compose down\nRemoving hello_web_1 ... done\nRemoving network hello_default\n</code></pre>"},{"location":"intermezzo/Instalaci%C3%B3n%20de%20zsh%20en%20ubuntu/","title":"Instalaci\u00f3n de zsh en ubuntu","text":"<p>Para instalar Zsh en Ubuntu, sigue los siguientes pasos:</p> <ul> <li>Abre una terminal en tu sistema Ubuntu.</li> <li>Actualiza la lista de paquetes de Ubuntu con el siguiente comando:</li> </ul> <pre><code>$ sudo apt update\n</code></pre> <ul> <li>Ahora, instala Zsh con el siguiente comando:</li> </ul> <pre><code> sudo apt install zsh\n</code></pre> <ul> <li>Despu\u00e9s de la instalaci\u00f3n, verifica que la versi\u00f3n de Zsh instalada es la \u00faltima disponible con:</li> </ul> <pre><code>zsh --version\n</code></pre> <ul> <li>Para configurar Zsh como tu shell predeterminada, utiliza el siguiente comando:</li> </ul> <pre><code>sudo chsh -s $(which zsh)\n</code></pre> <ul> <li>Cierra la sesi\u00f3n actual (saliendo del modo gr\u00e1fico) e inicia sesi\u00f3n nuevamente para que los cambios surtan efecto.</li> <li>Instalar Oh-my-zsh seg\u00fan las instrucciones de su p\u00e1gina web es decir, ejecutar el comando:</li> </ul> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre> <ul> <li>Abre tu terminal y ejecuta el siguiente comando para abrir el archivo de configuraci\u00f3n de Oh My Zsh:</li> </ul> <pre><code>vi ~/.zshrc\n</code></pre> <ul> <li>Busca la l\u00ednea que comienza con <code>ZSH_THEME</code> y cambia el valor despu\u00e9s del signo igual por el nombre del te   ma que quieres utilizar. Por ejemplo, si quieres utilizar el tema agnoster, la l\u00ednea deber\u00eda verse as\u00ed:</li> </ul> <pre><code>ZSH_THEME=\"agnoster\"\n</code></pre> <ul> <li> <p>Guarda los cambios y cierra el archivo de configuraci\u00f3n.</p> </li> <li> <p>Sal de tu sesi\u00f3n de terminal actual y vuelve a iniciarla para que los cambios tengan efecto.</p> </li> </ul> <p>instalacion_del_plugin_en_ZSH</p>"},{"location":"intermezzo/ejercicios/","title":"Ejercicios","text":"<p>https://osl.ugr.es/2021/03/24/tutorial-basico-de-docker/</p> <p>https://iesgn.github.io/curso_docker_2021/sesion1/ejercicios.html</p>"},{"location":"intermezzo/instalacion_del_plugin_en_ZSH/","title":"Instalaci\u00f3n del plugin de ZSH","text":"<p>La instalaci\u00f3n del plugin de Docker en Zsh puede variar dependiendo del m\u00e9todo que se utilice para instalar Zsh en tu sistema operativo. A continuaci\u00f3n, se describe el proceso de instalaci\u00f3n en sistemas operativos basados en Linux:</p> <ol> <li>Abre una terminal y aseg\u00farate de tener instalado Zsh en tu sistema y el gestor de paquetes Oh My Zsh. </li> <li>Ahora, abre el archivo de configuraci\u00f3n de Zsh en un editor de texto. Puedes hacerlo ejecutando el siguiente comando en la terminal:</li> </ol> <p><code>vim ~/.zshrc</code></p> <ol> <li>Busca la l\u00ednea que comienza con <code>plugins=</code> y agrega <code>docker</code> al final de la lista de plugins separados por espacios. Debe quedar algo como esto:</li> </ol> <p><code>plugins=(git docker)</code></p> <ol> <li> <p>Guarda los cambios y cierra el archivo.</p> </li> <li> <p>Ahora, reinicia Zsh para que los cambios tengan efecto:</p> </li> </ol> <p><code>source ~/.zshrc</code></p> <p>Una vez completados estos pasos, el plugin de Docker deber\u00eda estar instalado y listo para usarse en Zsh. Puedes probarlo ejecutando un comando de Docker en la terminal.</p>"},{"location":"intermezzo/instalacion_del_plugin_en_ZSH/#otros-plugins","title":"Otros plugins","text":"<p>Aparte del plugin oficial de Docker, hay varios otros plugins que puedes instalar en Zsh para trabajar con Docker. Algunos de los plugins m\u00e1s populares son:</p> <ul> <li>zsh-autosuggestions-docker: Este plugin agrega sugerencias autom\u00e1ticas para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/hlissner/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</code></p> <ul> <li>zsh-completion-docker: Este plugin agrega completado de tabulaci\u00f3n para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/docker/cli.git ~/.oh-my-zsh/custom/plugins/zsh-completion-docker</code></p> <ul> <li>zsh-syntax-highlighting-docker: Este plugin agrega resaltado de sintaxis para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ul> <p><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting-docker</code></p> <p>Para utilizar estos plugins, debes agregarlos a la lista de plugins en el archivo de configuraci\u00f3n de Zsh (<code>~/.zshrc</code>) de la misma manera que se agreg\u00f3 el plugin de Docker. Por ejemplo:</p> <pre><code>plugins=(git docker zsh-autosuggestions zsh-completion-docker zsh-syntax-highlighting-docker)\n</code></pre> <p>Igual que antes y una vez que hayas agregado estos plugins, reinicia <code>zsh</code> para que los cambios tengan efecto. Luego, podr\u00e1s utilizar las funciones adicionales que ofrecen estos plugins para trabajar con <code>docker</code> en <code>zsh</code>.</p>"}]}